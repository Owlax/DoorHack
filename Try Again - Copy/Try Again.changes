----QUIT----2024-03-01T12:34:42.799915+01:00 Pharo10-SNAPSHOT-64bit-28169ae.image priorSource: 0!----QUIT----2024-03-01T12:35:12.44966+01:00 Pharo10-SNAPSHOT-64bit-28169ae.image priorSource: 0!!BaselineOfPharoJS commentStamp: '' prior: 0!Baseline managing the PharoJS project on Git!!ManifestBaselineOfPharoJS commentStamp: '' prior: 0!I store metadata for this package. These meta data are used by other tools such as the SmalllintManifestChecker and the critics Browser!!BaselineOfPharoJS methodsFor: 'baselines'!baseline: spec	<baseline>	self compatibility: spec.			spec for: #'common' do: [		self 			prerequisites: spec;					packages: spec;			groups: spec		]! !!BaselineOfPharoJS methodsFor: 'private - accessing'!compatibility: spec	"Define a 'Compatibility' group that can be used as a dependency later to overcome differences in Pharo releases"		spec for: #'common' do: [ spec group: 'Compatibility' with: #() ].	"no compatibility by default"	spec for: #('pharo9.x') do: [ spec package: 'PharoJs-Compatibility-Pharo9';				     							   group: 'Compatibility' with: #('PharoJs-Compatibility-Pharo9') ].						spec for: #('pharo8.x') do: [ spec package: 'PharoJs-Compatibility-Pharo8';				     							   group: 'Compatibility' with: #('PharoJs-Compatibility-Pharo8') ].	spec for: #('pharo7.x') do: [ spec package: 'PharoJs-Compatibility-Pharo7';				     							   group: 'Compatibility' with: #('PharoJs-Compatibility-Pharo7') ].! !!BaselineOfPharoJS methodsFor: 'private - accessing'!groups: spec		"Define groups for loading"				"Transpiler"		spec 			group: 'Transpiler' with: #('PharoJs-Base-Transpiler');						group: 'OptimizedTranspiler' with: #('PharoJs-Base-Transpiler' 'PharoJs-Base-Transpiler-Optimizations').						"Other"			spec 			group: 'App' with: #('PharoJs-Base-App');			group: 'Exporter' with: #('PharoJs-Base-Exporter');			group: 'Bridge' with: #('PharoJs-Base-Bridge')	;			group: 'Examples' with: #('PharoJs-Examples');			group: 'Benchmarks' with: #('PharoJs-Benchmarking');			group: 'Statistics' with: #('PharoJs-Utilities-Statistics');			group: 'Tools' with: #('PharoJs-Tools').					spec			group: 'Electron' with: #('PharoJs-Base-JS-Electron');			group: 'Express' with: #('PharoJs-Base-JS-Express');			group: 'Node' with: #('PharoJs-Base-JS-Node');			group: 'Seaside' with: #('PharoJs-Base-JS-Seaside').					spec 				group: 'Tests' with: #(				'PharoJs-Base-Transpiler-Tests'				'PharoJs-Base-Transpiler-Optimizations-Tests'				'PharoJs-Base-Exporter-Tests'				'PharoJs-Base-JS-CoreLibraries-Tests'				'PharoJs-Base-Serialization-Tests'				'PharoJs-Base-Bridge-Tests'				'PharoJs-Examples-Tests'				'PharoJs-Tools-Tests' 			).							spec group: 'Deprecated' with: #('PharoJs-Base-Serialization-Deprecated').			   "Virtual groups (lowercase) from Metacello"		spec group: 'default' with: #('Compatibility' 'Transpiler' 'OptimizedTranspiler' 'App' 'Exporter' 'Bridge' 'Examples' 'Benchmarks' 'Statistics' 'Tools' 'Deprecated' 'Tests').		spec group: 'all' with: #('default' 'Express' 'Electron' 'Node' 'Seaside' 'LightweightObserverJS')! !!BaselineOfPharoJS methodsFor: 'private - accessing'!packages: spec		"Define and list all packages and their dependencies"				"Transpiler"		spec package: 'PharoJs-Base-Transpiler' with: [ spec requires: #('Equals' 'Compatibility') ];			  package: 'PharoJs-Base-Transpiler-Tests' with: [ spec requires: #('PharoJs-Base-Transpiler') ];            package: 'PharoJs-Base-Transpiler-Optimizations' with: [ spec requires: #('PharoJs-Base-Transpiler') ];			  package: 'PharoJs-Base-Transpiler-Optimizations-Tests' with: [ spec requires: #('PharoJs-Base-Transpiler-Optimizations' 'PharoJs-Base-Bridge-Tests' 'PharoJs-Base-Transpiler-Tests') ].				"Exporter"				spec package: 'PharoJs-Base-Exporter' with: [ spec requires: #('PharoJs-Base-Transpiler' 'PharoJs-Base-App' ) ];			  package: 'PharoJs-Base-Exporter-Tests' with: [ spec requires: #('PharoJs-Base-Exporter' 'PharoJs-Base-Transpiler-Tests') ].											"TestFramework"			spec package: 'PharoJs-TestFramework' with: [ spec requires: #('PharoJs-Base-Exporter' 'PharoJs-Base-Bridge' 'PharoJs-Base-App') ].					"JS - CoreLibraries"		spec package: 'PharoJs-Base-JS-CoreLibraries' with: [ spec requires: #('PharoJs-Base-Transpiler' 'PharoExtra') ];			  package: 'PharoJs-Base-JS-CoreLibraries-Tests' with: [ spec requires: #('PharoJs-Base-JS-CoreLibraries' 'PharoJs-TestFramework' 'PharoJs-Base-Bridge-Tests' 'PharoJs-Base-Transpiler-Tests') ].							"Serialization"  		spec package: 'PharoJs-Base-Serialization' with: [ spec requires: #('PharoJs-Base-JS-CoreLibraries')];			  package: 'PharoJs-Base-Serialization-Tests' with: [ spec requires: #('PharoJs-Base-Serialization' 'PharoJs-Base-Bridge-Tests')];			  package: 'PharoJs-Base-Serialization-Deprecated' with: [ spec requires: #('PharoJs-Base-App' 'PharoJs-Base-Transpiler' 'PharoJs-TestFramework') ].									"Bridge"	  		spec package: 'PharoJs-Base-Bridge' with: [ spec requires: #('PharoJs-Base-JS-CoreLibraries' 'PharoJs-Base-Exporter' 'PharoJs-Base-App' 'Zinc-WebSocket-Core' 'PharoJs-Base-Serialization')];			  package: 'PharoJs-Base-Bridge-Tests' with: [ spec requires: #('PharoJs-TestFramework' 'PharoJs-Base-Bridge') ].				"App"		spec package: 'PharoJs-Base-App' with: [ spec requires: #('PharoJs-Base-Transpiler' 'PharoJs-Base-JS-CoreLibraries') ].				"Examples"			spec package: 'PharoJs-Examples' with: [ spec requires: #('PharoJs-Base-App' 'PharoJs-Base-Transpiler' 'PharoJs-TestFramework' 'PharoJs-Base-Exporter') ];			  package: 'PharoJs-Examples-Tests' with: [ spec requires: #('PharoJs-Examples' 'PharoJs-TestFramework') ].										"Benchmarking (Timing)"		spec package: 'PharoJs-Benchmarking' with: [ spec requires: #('PharoJs-Base-Transpiler-Optimizations' 'PharoJs-Base-Bridge') ].				"Utilities - Statistics"							spec package: 'PharoJs-Utilities-Statistics' with: [ spec requires: #('PharoJs-Base-Exporter') ].															"Tools"   				spec package: 'PharoJs-Tools' with: [ spec requires: #('PharoJs-Base-Bridge') ];			  package: 'PharoJs-Tools-Tests' with: [ spec requires: #('PharoJs-Tools' 'PharoJs-TestFramework') ].				"Apps and Frameworks (Electron, Express, Node, ...)"		spec package: 'PharoJs-Base-JS-Electron' with: [ spec requires: #('PharoJs-Base-App') ];			  package: 'PharoJs-Base-JS-Express' with: [ spec requires: #('PharoJs-Base-App') ];			  package: 'PharoJs-Base-JS-Node' with: [ spec requires: #('PharoJs-Base-App') ];			  package: 'PharoJs-Base-JS-Seaside' with: [ spec requires: #('PharoJs-Base-App' 'Seaside3') ];			  package: 'LightweightObserverJS' with: [ spec requires: #('PharoJs-Base-App' 'LightweightObserver') ] 		 ! !!BaselineOfPharoJS methodsFor: 'private - accessing'!prerequisites: spec	"Add the projects prerequisite definitions to the given spec"		"Prerequisite Baselines"	spec		baseline: 'PharoExtra' with: [ spec repository: 'github://bouraqadi/PharoMisc' ];		baseline: 'Equals' with: [ spec repository: 'github://bouraqadi/PharoMisc' ];		baseline: 'LightweightObserver' with: [ spec repository: 'github://bouraqadi/PharoMisc' ];		baseline: 'Seaside3' with: [ spec repository: 'github://SeasideSt/Seaside:master/repository' ].					"Prerequisite Packages"		spec		package: 'Zinc-WebSocket-Core' with: [ spec repository: 'github://svenvc/zinc' ]			 ! !!ManifestBaselineOfPharoJS class methodsFor: 'code-critics'!ruleRBLongMethodsRuleV1FalsePositive	^ #(#(#(#RGClassDefinition #(#BaselineOfPharoJS)) #'2020-02-14T19:08:56.237579-05:00') )! !!ManifestBaselineOfPharoJS class methodsFor: 'code-critics'!ruleRBUtilityMethodsRuleV1FalsePositive	^ #(#(#(#RGClassDefinition #(#BaselineOfPharoJS)) #'2020-02-14T19:09:03.794682-05:00') )! !"BaselineOfPharoJS"!!BaselineOfEquals methodsFor: 'baselines'!baseline: spec	<baseline>	spec for: #'common' do: [		spec 			blessing: #'baseline';			repository: 'github://bouraqadi/PharoMisc'; 			package: #Equals ].! !"BaselineOfEquals"!!BaselineOfPharoExtra methodsFor: 'baselines'!baseline: spec	<baseline>	spec for: #'common' do: [		spec 			blessing: #'baseline';			repository: 'github://bouraqadi/PharoMisc'; 			package: #PharoExtra. ].! !"BaselineOfPharoExtra"!!DateAndTime class methodsFor: '*PharoExtra-Chronology'!todayHour: hour minute: minute 	^self todayHour: hour minute: minute second: 0! !!DateAndTime class methodsFor: '*PharoExtra-Chronology'!todayHour: hour minute: minute second: second	^self date: Date today time: (Time hour: hour minute: minute second: second)! !!DateAndTime class methodsFor: '*PharoExtra-Chronology'!tomorrowHour: hour minute: minute 	^self tomorrowHour: hour minute: minute second: 0! !!DateAndTime class methodsFor: '*PharoExtra-Chronology'!tomorrowHour: hour minute: minute second: second	^self date: Date tomorrow time: (Time hour: hour minute: minute second: second)! !!DateAndTime methodsFor: '*PharoExtra-Chronology'!milliSecond	^self nanoSecond // 1000000! !!Time class methodsFor: '*PharoExtra-instance creation'!hour: hour minute: minute	^self hour: hour minute: minute second: 0! !!Time class methodsFor: '*PharoExtra-instance creation'!hour: hour0to23 minute: minute0to59 second: second0to59 milliSecond: millis0to999 	^self hour: hour0to23 minute: minute0to59 second: second0to59  nanoSecond: (millis0to999 * 1000000)! !!Time methodsFor: '*PharoExtra-Chronology'!+ aDuration	^self asDateAndTime + aDuration! !!Duration class methodsFor: '*PharoExtra-Chronology'!months: aNumber	^self seconds: aNumber * self secondsInMonth! !!Duration class methodsFor: '*PharoExtra-Chronology'!secondsInDay	^86400! !!Duration class methodsFor: '*PharoExtra-Chronology'!secondsInMonth	^2628000! !!Duration class methodsFor: '*PharoExtra-Chronology'!secondsInWeek	^604800! !!Duration class methodsFor: '*PharoExtra-Chronology'!secondsInYear	^31536000! !!Duration methodsFor: '*PharoExtra-Chronology'!daysCount	^self daysSecondsCount quo: self secondsInDay! !!Duration methodsFor: '*PharoExtra-Chronology'!daysSecondsCount	^self weeksSecondsCount rem: self secondsInWeek! !!Duration methodsFor: '*PharoExtra-Chronology'!hoursCount	^self hoursSecondsCount quo: SecondsInHour! !!Duration methodsFor: '*PharoExtra-Chronology'!hoursSecondsCount	^self daysSecondsCount rem: self secondsInDay! !!Duration methodsFor: '*PharoExtra-Chronology'!millisecondsCount	^self wholeMilliseconds! !!Duration methodsFor: '*PharoExtra-Chronology'!minutesCount	^self minutes! !!Duration methodsFor: '*PharoExtra-Chronology'!monthSecondsCount	^ self totalSeconds rem: self secondsInYear! !!Duration methodsFor: '*PharoExtra-Chronology'!monthsCount	^ self monthSecondsCount quo: self secondsInMonth! !!Duration methodsFor: '*PharoExtra-Chronology'!secondsCount	^self seconds! !!Duration methodsFor: '*PharoExtra-Chronology'!secondsInDay	^self class secondsInDay! !!Duration methodsFor: '*PharoExtra-Chronology'!secondsInMonth	^self class secondsInMonth! !!Duration methodsFor: '*PharoExtra-Chronology'!secondsInWeek	^self class secondsInWeek! !!Duration methodsFor: '*PharoExtra-Chronology'!secondsInYear	^self class secondsInYear! !!Duration methodsFor: '*PharoExtra-Chronology'!weeksCount	^ self weeksSecondsCount quo: self secondsInWeek! !!Duration methodsFor: '*PharoExtra-Chronology'!weeksSecondsCount	^ self monthSecondsCount rem: self secondsInMonth! !!Duration methodsFor: '*PharoExtra-Chronology'!yearsCount	^self totalSeconds quo: self secondsInYear! !!PeSequenceableCollectionGroupingTest methodsFor: 'testing'!assertGroupCount: expectedGroupCount of: collection groupSize: groupSize	| actualGroupCount |	actualGroupCount := 0.	collection groupsOfAtMost: groupSize atATimeDo: [ actualGroupCount := actualGroupCount + 1 ].	self assert: actualGroupCount equals: expectedGroupCount.! !!PeSequenceableCollectionGroupingTest methodsFor: 'testing'!assertGroupElements: expectedGroups of: collection groupSize: groupSize	| actualGroups |	actualGroups := OrderedCollection new.	collection groupsOfAtMost: groupSize atATimeCollect: [: aGroup | actualGroups add: aGroup].	self assert: actualGroups size equals: expectedGroups size.	actualGroups 		with: expectedGroups		do: [ : actual : expected |			self assertCollection: actual equals: expected  ]! !!PeSequenceableCollectionGroupingTest methodsFor: 'testing'!testGroupCount	self assertGroupCount: 0 of: #() groupSize: 1.	self assertGroupCount: 1 of: #(a) groupSize: 1.	self assertGroupCount: 10 of: (1 to: 10) groupSize: 1.	self assertGroupCount: 0 of: #() groupSize: 2.	self assertGroupCount: 1 of: #(a) groupSize: 2.	self assertGroupCount: 1 of: #(a b) groupSize: 2.	self assertGroupCount: 5 of: (1 to: 10) groupSize: 2.		self assertGroupCount: 0 of: #() groupSize: 3.	self assertGroupCount: 1 of: #(a) groupSize: 3.	self assertGroupCount: 1 of: #(a b) groupSize: 3.	self assertGroupCount: 1 of: #(a b c) groupSize: 3.	self assertGroupCount: 2 of: #(a b c d) groupSize: 3.	self assertGroupCount: 4 of: (1 to: 10) groupSize: 3.! !!PeSequenceableCollectionGroupingTest methodsFor: 'testing'!testGroupElements	self assertGroupElements: #() of: #() groupSize: 1.	self assertGroupElements: #(#(a)) of: #(a) groupSize: 1.	self assertGroupElements: #(#(a) #(b) #(c)) of: #(a b c) groupSize: 1.	self assertGroupElements: #() of: #() groupSize: 2.	self assertGroupElements: #(#(a)) of: #(a) groupSize: 2.	self assertGroupElements: #(#(a b)) of: #(a b) groupSize: 2.	self assertGroupElements: #(#(a b) #(c)) of: #(a b c) groupSize: 2.	self assertGroupElements: #() of: #() groupSize: 3.	self assertGroupElements: #(#(a)) of: #(a) groupSize: 3.	self assertGroupElements: #(#(a b)) of: #(a b) groupSize: 3.	self assertGroupElements: #(#(a b c)) of: #(a b c) groupSize: 3.	self assertGroupElements: #(#(a b c) #(d)) of: #(a b c d) groupSize: 3.	self assertGroupElements: #(#(a b c) #(d e)) of: #(a b c d e) groupSize: 3.	self assertGroupElements: #(#(a b c) #(d e f)) of: #(a b c d e f) groupSize: 3.	self assertGroupElements: #(#(a b c) #(d e f) #(g)) of: #(a b c d e f g) groupSize: 3.! !!PhDateAndTimeTest methodsFor: 'testing'!testToday	| today |	today := DateAndTime todayHour: 14 minute: 59 second: 33.	self assert: today year equals: Date today year. 	self assert: today day equals: Date today day. 	self assert: today hour24 equals: 14.	self assert: today minute equals: 59.	self assert: today second equals: 33.! !!PhDurationTest methodsFor: 'testing'!testDaysCount	self assert: 1 day daysCount equals: 1.	self assert: 6 days daysCount equals: 6.	self assert: 7 days daysCount equals: 0.	self assert: 8 days daysCount equals: 1.	self assert: 14 days daysCount equals: 0.	self assert: 30 days daysCount equals: 2.	self assert: 1 week daysCount equals: 0.	self assert: 4 weeks daysCount equals: 0.	self assert: 1 month daysCount equals: 0.	self assert: 6 months daysCount equals: 0.	self assert: 1 year daysCount equals: 0.	self assert: 5 years daysCount equals: 0.	! !!PhDurationTest methodsFor: 'testing'!testHoursMinutesSecondsCount	| duration |	duration := 26 hours + 83 minutes + 75 seconds.	self assert: duration daysCount equals: 1.	self assert: duration hoursCount equals: 3.	self assert: duration minutesCount equals: 24.	self assert: duration secondsCount equals: 15.	! !!PhDurationTest methodsFor: 'testing'!testMonthsCount	self assert: 1 day monthsCount equals: 0.	self assert: 30 days monthsCount equals: 0.	self assert: 31 days monthsCount equals: 1.	self assert: 60 days monthsCount equals: 1.	self assert: 61 days monthsCount equals: 2.	self assert: 365 days monthsCount equals: 0.	self assert: 400 days monthsCount equals: 1.	self assert: 1 week monthsCount equals: 0.	self assert: 4 weeks monthsCount equals: 0.	self assert: 5 weeks monthsCount equals: 1.	self assert: 10 weeks monthsCount equals: 2.	self assert: 1 month monthsCount equals: 1.	self assert: 6 months monthsCount equals: 6.	self assert: 12 months monthsCount equals: 0.	self assert: 13 months monthsCount equals: 1.	self assert: 0 year monthsCount equals: 0.	self assert: 1 year monthsCount equals: 0.	self assert: 23 years monthsCount equals: 0.	! !!PhDurationTest methodsFor: 'testing'!testWeeksCount	self assert: 1 day weeksCount equals: 0.	self assert: 6 days weeksCount equals: 0.	self assert: 7 days weeksCount equals: 1.	self assert: 13 days weeksCount equals: 1.	self assert: 14 days weeksCount equals: 2.	self assert: 30 days weeksCount equals: 4.	self assert: 40 days weeksCount equals: 1.	self assert: 1 week weeksCount equals: 1.	self assert: 4 weeks weeksCount equals: 4.	self assert: 5 weeks weeksCount equals: 0.	self assert: 8 weeks weeksCount equals: 3.	self assert: 1 month weeksCount equals: 0.	self assert: 6 months weeksCount equals: 0.	self assert: 1 year weeksCount equals: 0.	self assert: 5 years weeksCount equals: 0.	! !!PhDurationTest methodsFor: 'testing'!testYearsCount	self assert: 1 day yearsCount equals: 0.	self assert: 364 days yearsCount equals: 0.	self assert: 365 days yearsCount equals: 1.	self assert: 366 days yearsCount equals: 1.	self assert: 400 days yearsCount equals: 1.	self assert: 1095 days yearsCount equals: 3.	self assert: 1 week yearsCount equals: 0.	self assert: 52 weeks yearsCount equals: 0.	self assert: 53 weeks yearsCount equals: 1.	self assert: 54 weeks yearsCount equals: 1.	self assert: 104 weeks yearsCount equals: 1.	self assert: 105 weeks yearsCount equals: 2.	self assert: 106 weeks yearsCount equals: 2.	self assert: 1 month yearsCount equals: 0.	self assert: 11 months yearsCount equals: 0.	self assert: 12 months yearsCount equals: 1.	self assert: 13 months yearsCount equals: 1.	self assert: 48 months yearsCount equals: 4.	self assert: 0 year yearsCount equals: 0.	self assert: 1 year yearsCount equals: 1.	self assert: 23 years yearsCount equals: 23.	! !!Number methodsFor: '*PharoExtra-Chronology'!month	^self months! !!Number methodsFor: '*PharoExtra-Chronology'!months	^Duration months: self! !!SequenceableCollection methodsFor: '*PharoExtra-Collections'!groupsOfAtMost: maxGroupSize atATimeCollect: aBlock	"As opposite to groupsOf:atATimeCollect: I process all elements. The last group might be smaller than the others since it includes the leftovers."		| newCollection |	newCollection := OrderedCollection new.	self groupsOfAtMost: maxGroupSize atATimeDo: [:each | newCollection add: (aBlock value: each)].	^newCollection! !!SequenceableCollection methodsFor: '*PharoExtra-Collections'!groupsOfAtMost: maxGroupSize atATimeDo: aBlock	"As opposite to groupsOf:atATimeDo: I process all elements. The last group might be smaller than the others since it includes the leftovers."	| groupIndex firstIndex lastIndex group |	groupIndex := 1.	firstIndex := 1.	[ firstIndex <= self size  ] whileTrue: [		lastIndex := (firstIndex + maxGroupSize - 1) min: self size.	"self halt."		group := self copyFrom: firstIndex to: lastIndex.		aBlock cull: group.		firstIndex := lastIndex + 1.		groupIndex := groupIndex + 1 ].! !"PharoExtra"!!TEquality commentStamp: '' prior: 0!TEquality is a trait that provides a generic implementation for = and hash.It aims avoiding to implement = and hash for simple cases.To make instances of some class comparable, simply make the class use this trait.TEquality relies on message valuesToCompareForEquality sent to objects for both = and hash.The default implmentation of this message is provided by Object.Override ONLY valuesToCompareForEquality method for custom equality check.!!TEquality methodsFor: 'comparing'!= anObject 	self species = anObject species ifFalse: [^false].	^self valuesToCompareForEquality = anObject valuesToCompareForEquality! !!TEquality methodsFor: 'comparing'!hash	^self valuesToCompareForEquality inject: self species hash into: [:hash :comparisonValue|		(hash bitXor: comparisonValue hash) hashMultiply]! !!EqualityTest methodsFor: 'setUp-tearDown'!setUp	super setUp.	classFactory := ClassFactoryForTestCase new.! !!EqualityTest methodsFor: 'setUp-tearDown'!tearDown	super tearDown.	classFactory cleanUp! !!EqualityTest methodsFor: 'testing'!testSetContainsOnlyOneInstanceOfAClassWithIVs	| set object class |	class  := classFactory newSubclassOf: ComparableObjectForEqualityTest  instanceVariableNames: 'x y' classVariableNames:  ''.	class compile: 'x: newX y: newY		x := newX.		y := newY'.	class class compile: 'x: newX y: newY		^self new			x: newX y: newY;			yourself'.	set := Set new.	10 timesRepeat: [		object  := class x: 1 y: 2.		set add: object].	self assert: set size = 1.! !!EqualityTest methodsFor: 'testing'!testSetContainsOnlyOneInstanceOfAClassWithNoIVs	| set |	set := Set new.	10 timesRepeat: [set add: ComparableObjectForEqualityTest new].	self assert: set size = 1.	self assert: (set includes: ComparableObjectForEqualityTest new)! !!EqualityTest methodsFor: 'testing'!testSetContainsTwoInstancesOfTwoDiffrentClassesWithIVs	| set otherClass yetAnotherClass |	otherClass := classFactory newSubclassOf: ComparableObjectForEqualityTest  instanceVariableNames: 'x y' classVariableNames:  ''.	yetAnotherClass := classFactory newSubclassOf: ComparableObjectForEqualityTest  instanceVariableNames: 'x y' classVariableNames:  ''.	{otherClass. yetAnotherClass} do: [:class|		class compile: 'x: newX y: newY			x := newX.			y := newY'.		class class compile: 'x: newX y: newY			^self new				x: newX y: newY;				yourself'.	].	set := Set with: (otherClass x: 'abc' y: 123) with: (yetAnotherClass x: 'abc' y: 123).	self assert: set size = 2.	self assert: (set includes: (otherClass x: 'abc' y: 123)).	self assert: (set includes: (yetAnotherClass x: 'abc' y: 123)).! !!EqualityTest methodsFor: 'testing'!testSetContainsTwoInstancesOfTwoDiffrentClassesWithNoIVs	| set otherClass |	otherClass := classFactory newSubclassOf: ComparableObjectForEqualityTest  instanceVariableNames: '' classVariableNames:  ''.	set := Set with: ComparableObjectForEqualityTest new with: otherClass new.	self assert: set size = 2.	self assert: (set includes: ComparableObjectForEqualityTest new).	self assert: (set includes: otherClass new).! !!EqualityTest methodsFor: 'testing'!testTwoInstancesOfTheSameClassWithDifferentIvValuessAreNOTEqual	| class |	class  := classFactory newSubclassOf: ComparableObjectForEqualityTest  instanceVariableNames: 'x y' classVariableNames:  ''.	class compile: 'x: newX y: newY		x := newX.		y := newY'.	class class compile: 'x: newX y: newY		^self new			x: newX y: newY;			yourself'.	self deny: (class x: 1 y: 'abc') = (class x: 1 y: 'zyx').! !!EqualityTest methodsFor: 'testing'!testTwoInstancesOfTheSameClassWithNoIVsAreEqual	self assert: ComparableObjectForEqualityTest new = ComparableObjectForEqualityTest new	! !!EqualityTest methodsFor: 'testing'!testTwoInstancesOfTheSameClassWithSameIvValuessAreEqual	| class |	class  := classFactory newSubclassOf: ComparableObjectForEqualityTest  instanceVariableNames: 'x y' classVariableNames:  ''.	class compile: 'x: newX y: newY		x := newX.		y := newY'.	class class compile: 'x: newX y: newY		^self new			x: newX y: newY;			yourself'.	self assert: (class x: 1 y: 'abc') = (class x: 1 y: 'abc').! !!EqualityTest methodsFor: 'testing'!testTwoInstancesOfTowDifferentClassesWithNoIVsAreNOTEqual	| otherClass |	otherClass := classFactory newSubclassOf: ComparableObjectForEqualityTest  instanceVariableNames: '' classVariableNames:  ''.	self deny: otherClass new = ComparableObjectForEqualityTest new! !!ProtoObject class methodsFor: '*Equals'!allInstVarNamesForEqualityComparison	^#()! !!Comparisons class methodsFor: 'displaying'!display: aBoolean	| displayColor displayLabel |	displayLabel := aBoolean ifTrue: [ 'Equal' ] ifFalse: [ 'Different' ].	displayColor := aBoolean ifTrue: [ Color green ] ifFalse: [ Color yellow ].	GrowlMorph 		openWithLabel: displayLabel		contents: ''		backgroundColor: displayColor		labelColor: Color black! !!FruitComparisons class methodsFor: 'comparisons'!compareApplesOfDifferentColors	"self compareApplesOfDifferentColors"	| apple1 apple2 |	apple1 := Apple color: Color red.	apple2 := Apple color: Color yellow.	self display: apple1 = apple2! !!FruitComparisons class methodsFor: 'comparisons'!compareApplesOfSameColor	"self compareApplesOfSameColor"	| apple1 apple2 |	apple1 := Apple color: Color red.	apple2 := Apple color: Color red.	self display: apple1 = apple2! !!FruitComparisons class methodsFor: 'comparisons'!compareApplesOfSameColorAtDifferentStages	"self compareApplesOfSameColorAtDifferentStages"	| apple1 apple2 |	apple1 := Apple color: Color red.	apple1 beRipe.	apple2 := Apple color: Color yellow.	apple2 beRotten.		self display: apple1 = apple2! !!FruitComparisons class methodsFor: 'comparisons'!compareYellowAppleAndBanana	"self compareYellowAppleAndBanana"	| apple banana |	apple := Apple color: Color yellow.	banana := Banana new.	self display: apple = banana! !!PersonComparisons class methodsFor: 'comparisons'!compareStudentsAndTeacherOfSameAge	"self compareStudentsAndTeacherOfSameAge"	| luc tom |	luc := Teacher name: 'Luc' age: 24.	tom := Student name: 'Tom' age: 24.	self display: luc = tom! !!PersonComparisons class methodsFor: 'comparisons'!compareStudentsAndTeacherOfSameNameAndAge	"self compareStudentsAndTeacherOfSameNameAndAge"	| smith1 smith2 |	smith1 := Teacher name: 'Smith' age: 24.	smith2 := Student name: 'Smith' age: 24.	self display: smith1 = smith2! !!PersonComparisons class methodsFor: 'comparisons'!compareStudentsOfDifferentAge	"self compareStudentsOfDifferentAge"	| luc tom |	luc := Student name: 'Luc' age: 24.	tom := Student name: 'Tom' age: 5.	self display: luc = tom! !!PersonComparisons class methodsFor: 'comparisons'!compareStudentsOfDifferentLevels	"self compareStudentsOfDifferentLevels"	| luc tom |	luc := Student name: 'Luc' age: 24.	luc level: 7.	tom := Student name: 'Tom' age: 24.	tom level: 4.	self display: luc = tom! !!PersonComparisons class methodsFor: 'comparisons'!compareStudentsOfSameAgeAndLevel	"self compareStudentsOfSameAgeAndLevel"	| luc tom |	luc := Student name: 'Luc' age: 24.	luc level: 5.	tom := Student name: 'Tom' age: 24.	tom level: 5.	self display: luc = tom! !!Apple class methodsFor: 'instance creation'!color: aColor	^self new		color: aColor;		yourself! !!Apple methodsFor: 'accessing'!color	^ color! !!Apple methodsFor: 'accessing'!color: anObject	color := anObject! !!Banana methodsFor: 'accessing'!color	^Color yellow! !!Fruit methodsFor: 'comparing'!= anObject 	self species = anObject species ifFalse: [^false].	^self valuesToCompareForEquality = anObject valuesToCompareForEquality! !!Fruit methodsFor: 'staging'!beRipe	stage := #ripe! !!Fruit methodsFor: 'staging'!beRotten	stage := #rotten! !!Fruit methodsFor: 'staging'!beUnripe	stage := #unripe! !!Fruit methodsFor: 'accessing'!color	^self subclassResponsibility! !!Fruit methodsFor: 'comparing'!hash	^self valuesToCompareForEquality inject: self species hash into: [:hash :comparisonValue|		(hash bitXor: comparisonValue hash) hashMultiply]! !!Fruit methodsFor: 'initialize - release'!initialize	super initialize.	self beUnripe! !!Object class methodsFor: '*Equals'!allInstVarNamesForEqualityComparison	^self superclass allInstVarNamesForEqualityComparison, self instVarNamesForEqualityComparison! !!Object class methodsFor: '*Equals'!instVarNamesForEqualityComparison	^self instVarNames! !!Object methodsFor: '*Equals'!instVarNamesForEqualityComparison	^self class allInstVarNamesForEqualityComparison! !!Object methodsFor: '*Equals'!valuesToCompareForEquality	^self instVarNamesForEqualityComparison collect: [:ivName|		self instVarNamed: ivName]! !!Person class methodsFor: 'comparing'!instVarNamesForEqualityComparison	^#(age)! !!Person class methodsFor: 'instance-creation'!name: aString age: positiveInt	^self new		name: aString;		age: positiveInt;		yourself! !!Person methodsFor: 'comparing'!= anObject 	self species = anObject species ifFalse: [^false].	^self valuesToCompareForEquality = anObject valuesToCompareForEquality! !!Person methodsFor: 'accessing'!age	^ age! !!Person methodsFor: 'accessing'!age: anObject	age := anObject! !!Person methodsFor: 'comparing'!hash	^self valuesToCompareForEquality inject: self species hash into: [:hash :comparisonValue|		(hash bitXor: comparisonValue hash) hashMultiply]! !!Person methodsFor: 'accessing'!name	^ name! !!Person methodsFor: 'accessing'!name: anObject	name := anObject! !!Student methodsFor: 'initialize - release'!initialize	super initialize.	self level: 1! !!Student methodsFor: 'accessing'!level	^ level! !!Student methodsFor: 'accessing'!level: anObject	level := anObject! !!Teacher methodsFor: 'accessing'!experience	^ experience! !!Teacher methodsFor: 'accessing'!experience: anObject	experience := anObject! !!Teacher methodsFor: 'initialize'!initialize	super initialize.	self experience: 0! !"Equals"!!ZnWebSocketResponse commentStamp: '<historical>' prior: 0!I am ZnWebSocketResponse used to continue the WebSocket conversation after the connection upgrade.I am a ZnResponse.Part of Zinc HTTP Components.!!ZnWebSocketLogEvent commentStamp: 'SvenVanCaekenberghe 8/2/2014 18:53' prior: 0!I am ZnWebSocketLogEvent, a ZnLogEvent.I am the abstract superclass of all log events generated by the WebSocket subsystem.!!ZnWebSocketControlFrameHandledEvent commentStamp: 'SvenVanCaekenberghe 6/16/2014 13:10' prior: 0!I am ZnWebSocketControlFrameHandledEvent.I am a ZnLogEvent.I am emitted when a WebSocket control frame is handled automatically. I know the type of frame that is being handled.!!ZnWebSocketGenericLogEvent commentStamp: 'SvenVanCaekenberghe 6/16/2014 13:24' prior: 0!I am ZnWebSocketGenericLogEvent communicating about a subject.!!ZnWebSocketFailed commentStamp: '<historical>' prior: 0!I am ZnWebSocketFailed, an exception thrown when a client WebSocket cannot be created successfully.I am an Error.Part of Zinc HTTP Components. !!ZnWebSocketClosed commentStamp: '<historical>' prior: 0!I am ZnWebSocketClosed, signalled when WebSocket close frame is received.I am a ConnectionClosed and a NetworkError.Part of Zinc HTTP Components.!!ZnWebSocket commentStamp: '<historical>' prior: 0!I am ZnWebSocket, a bi-directional, full-duplex communication channel over a single TCP connection.WebSockets send reliable messages to each other, a String or ByteArrat.Each message is one-way (does not have a direct synchroneous reply). Each party, both client and/or server can take the initiative.This implementation follows RFC 6455. See also:	http://en.wikipedia.org/wiki/Websockets	http://tools.ietf.org/html/rfc6455Here is a client side example taking to a public echo service: | webSocket |webSocket := ZnWebSocket to: 'ws://echo.websocket.org'.[ webSocket 	sendMessage: 'Pharo Smalltalk using Zinc WebSockets !!';	readMessage ] ensure: [ webSocket close ].Here is the same example using secure web sockets:| webSocket |webSocket := ZnWebSocket to: 'wss://echo.websocket.org'.[ webSocket 	sendMessage: 'Pharo Smalltalk using Zinc WebSockets & Zodiac !!';	readMessage ] ensure: [ webSocket close ].Here is how to start a local server running in the image implementing the same echo service:ZnWebSocket startServerOn: 8080 do: ZnWebSocketEchoHandler new.A full inline implementation of the echo handler would look like:ZnWebSocket 	startServerOn: 8080 	do: [ :webSocket | 		[ 			webSocket runWith: [ :message |				self crLog: 'Received message: ', message printString, ' echoing...'.				webSocket sendMessage: message ] ] 			on: ConnectionClosed 			do: [ self crLog: 'Ignoring connection close, done' ] ].Part of Zinc HTTP Components.!!ZnWebSocketChatroomHandler commentStamp: '<historical>' prior: 0!I am ZnWebSocketChatroomHandler, I send a copy of each incoming message over a WebSocket to all WebSockets currently open, thus implementing a simple chat room.See the class comment of ZnWebSocketDelegate for an example using ZnWebSocketChatroomHandler.Part of Zinc HTTP Components.!!ZnWebSocketDelegate commentStamp: '<historical>' prior: 0!I am ZnWebSocketDelegate, a plugin to allow a ZnServer to accept incoming WebSocket requests.When accepted, the request is upgraded and a new WebSocket is created and handed to the handler block.Here is how to get 3 examples up and running:	ZnServer startDefaultOn: 1701.	ZnServer default logToTranscript.	ZnWebSocketDelegate installExamplesInDefaultServer.	ZnServer stopDefault.Part of Zinc HTTP Components.!!ZnWebSocketEchoHandler commentStamp: '<historical>' prior: 0!I am ZnWebSocketEchoHandler, implementing an echo service conversation as a WebSocket server: reading messages and echoing them back until ConnectionClosed.See the class comment of ZnWebSocketDelegate for an example using ZnWebSocketEchoHandler.Part of Zinc HTTP Components.!!ZnWebSocketFrame commentStamp: '<historical>' prior: 0!I am ZnWebSocketFrame, the elementary, low-level unit of data transfer in the WebSocket protocol.A frame has an opcode (a type), a flag indicating whether it is the final frame in a sequence, a flag indicating whether it is masked and a body (a ByteArray).The wire encoding of a frame consists minimally of 2 bytes: the first holds the opcode and final bit, the second the size and masked bit. Sizes strictly smaller than 126 are encoded directly. If the first byte is 126, the size is encoded in 2 successive bytes. If the first byte is 127, the size is encoded in 8 successive bytes. Client to server messages are masked. A 4 byte mask is XOR-ed with all body bytes. See #readFrom: and #writeOn: for the details.This implementation follows RFC 6455. See also:	http://en.wikipedia.org/wiki/Websockets	http://tools.ietf.org/html/rfc6455Part of Zinc HTTP Components.!!ZnWebSocketStatusHandler commentStamp: '<historical>' prior: 0!I am ZnWebSocketStatusHandler, emitting some Smalltalk image status data every second as a stream of WebSocket messages.See the class comment of ZnWebSocketDelegate for an example using ZnWebSocketStatusHandler.Part of Zinc HTTP Components.!!ZnWebSocketUtils commentStamp: '<historical>' prior: 0!I am ZnWebSocketUtils.Part of Zinc HTTP Components.!!ZnWebSocketResponse methodsFor: 'accessing' stamp: 'CompatibleUserName 2/13/2024 13:57:00'!continuation	"Return the block that represents the continuation 	when the server call #useConnection: on me.	The block will be evaluated with an instanciated WebSocket."	^ continuation! !!ZnWebSocketResponse methodsFor: 'initialize-release' stamp: 'CompatibleUserName 2/13/2024 13:57:00'!continuation: block	"Set the block that represents the continuation 	when the server call #useConnection: on me.	The block will be evaluated with an instanciated WebSocket."		continuation := block! !!ZnWebSocketResponse methodsFor: 'accessing' stamp: 'CompatibleUserName 2/13/2024 13:57:00'!useConnection: connection	"Hook method overwritten to give the receiver the chance to 	keep using connection in the current thread/process after the server wrote the response.	We start a conversation by instanciating a WebSocket and passing it to our continuation."		| webSocket |	webSocket := ZnWebSocket onStream: connection.	self continuation value: webSocket! !!ZnWebSocketResponse methodsFor: 'testing' stamp: 'CompatibleUserName 2/13/2024 13:57:00'!wantsConnectionClose	"After we are done, the server can close the connection we were using"	 	^ true! !!ZnWebSocketControlFrameHandledEvent methodsFor: 'printing' stamp: 'CompatibleUserName 2/13/2024 13:57:00'!printContentsOn: stream	super printContentsOn: stream.	stream << 'WebSocket Control Frame Handled '; print: type! !!ZnWebSocketControlFrameHandledEvent methodsFor: 'accessing' stamp: 'CompatibleUserName 2/13/2024 13:57:00'!type	^ type! !!ZnWebSocketControlFrameHandledEvent methodsFor: 'accessing' stamp: 'CompatibleUserName 2/13/2024 13:57:00'!type: anObject	type := anObject! !!ZnWebSocketGenericLogEvent methodsFor: 'printing' stamp: 'CompatibleUserName 2/13/2024 13:57:00'!printContentsOn: stream	super printContentsOn: stream.	stream << 'WebSocket Generic Log Event ';  print: subject! !!ZnWebSocketGenericLogEvent methodsFor: 'accessing' stamp: 'CompatibleUserName 2/13/2024 13:57:00'!subject	^ subject! !!ZnWebSocketGenericLogEvent methodsFor: 'accessing' stamp: 'CompatibleUserName 2/13/2024 13:57:00'!subject: anObject	subject := anObject! !!ZnWebSocketFailed class methodsFor: 'instance creation' stamp: 'CompatibleUserName 2/13/2024 13:57:00'!response: response	^ self new		response: response;		yourself! !!ZnWebSocketFailed methodsFor: 'accessing' stamp: 'CompatibleUserName 2/13/2024 13:57:00'!response	^ response! !!ZnWebSocketFailed methodsFor: 'accessing' stamp: 'CompatibleUserName 2/13/2024 13:57:00'!response: anObject	response := anObject! !!ZnWebSocketClosed methodsFor: 'accessing' stamp: 'CompatibleUserName 2/13/2024 13:57:00'!code	^ code! !!ZnWebSocketClosed methodsFor: 'accessing' stamp: 'CompatibleUserName 2/13/2024 13:57:00'!code: anObject	code := anObject! !!ZnWebSocketClosed methodsFor: 'accessing' stamp: 'CompatibleUserName 2/13/2024 13:57:00'!reason	^ reason! !!ZnWebSocketClosed methodsFor: 'accessing' stamp: 'CompatibleUserName 2/13/2024 13:57:00'!reason: anObject	reason := anObject! !!ZnWebSocket class methodsFor: 'protocol' stamp: 'CompatibleUserName 2/13/2024 13:57:00'!isValidWebSocketResponse: client	"Return true when client contains a valid WebSocket response for its WebSocket request"	| acceptKey response |	acceptKey := ZnWebSocketUtils handshake: (client request headers at: 'Sec-WebSocket-Key').	response := client response.	^ response code = 101		and: [			(response headers at: 'Upgrade') asLowercase = 'websocket' 				and: [					(ZnWebSocketUtils containsConnectionUpgrade: response headers)						and: [ 							(response headers at: 'Sec-WebSocket-Accept') = acceptKey ] ] ]! !!ZnWebSocket class methodsFor: 'instance creation' stamp: 'CompatibleUserName 2/13/2024 13:57:00'!onClient: client	"Create and return a functioning ZnWebSocket object based on an HTTP client,	assuming the initial upgrade handshake was executed. The validity of the response is checked.	Signals a ZnWebSocketFailed error when unsuccessful."	(self isValidWebSocketResponse: client)		ifTrue: [			^ (self onStream: client connection)				role: #client;				yourself ]		ifFalse: [			client close.			(ZnWebSocketFailed response: client response) signal ]! !!ZnWebSocket class methodsFor: 'instance creation' stamp: 'CompatibleUserName 2/13/2024 13:57:00'!onStream: socketStream	"Return a new ZnWebSocket instance on socketStream.	It is assumed that the initial handshake was successful."		^ self new		onStream: socketStream;		yourself! !!ZnWebSocket class methodsFor: 'instance creation' stamp: 'CompatibleUserName 2/13/2024 13:57:00'!startServerOn: port do: handler	"Start and return a new ZnServer listening on port and / for client WebSocket connections.	After a successful initial handshake, sent #value: to handler with a server side ZnWebSocket instance."		^ self startServerOn: port prefix: '' do: handler  ! !!ZnWebSocket class methodsFor: 'instance creation' stamp: 'CompatibleUserName 2/13/2024 13:57:00'!startServerOn: port prefix: prefix do: handler	"Start and return a new ZnServer listening on port and /prefix for client WebSocket connections.	After a successful initial handshake, sent #value: to handler with a server side ZnWebSocket instance."		^ (ZnServer on: port)		delegate: (ZnWebSocketDelegate map: prefix to: handler);		start;		yourself! !!ZnWebSocket class methodsFor: 'instance creation' stamp: 'CompatibleUserName 2/13/2024 13:57:00'!to: urlObject	"Attempt to create a new client WebSocket to urlObject.	Do the initial upgrade handshake and return a functioning ZnWebSocket object.	Signals a ZnWebSocketFailed error when unsuccessful."	^ self to: urlObject config: [ :httpClient | ]! !!ZnWebSocket class methodsFor: 'instance creation' stamp: 'CompatibleUserName 2/13/2024 13:57:00'!to: urlObject config: block	"Attempt to create a new client WebSocket to urlObject.	Execute block to further configure the HTTP client before the upgrade request.	Do the initial upgrade handshake and return a functioning ZnWebSocket object.	Signals a ZnWebSocketFailed error when unsuccessful."	| client |	client := self webSocketClientTo: urlObject asZnUrl.	block value: client.	client execute.	^ self onClient: client! !!ZnWebSocket class methodsFor: 'protocol' stamp: 'CompatibleUserName 2/13/2024 13:57:00'!webSocketClientTo: url	"Create and return a new ZnClient instance ready for the initial client side WebSocket setup request"		| client |	self assert: (#(ws wss) includes: url scheme).	(client := ZnClient new)		url: url;		method: #GET;		headerAt: 'Upgrade' put: 'websocket';		headerAt: 'Connection' put: 'Upgrade';		headerAt: 'Sec-WebSocket-Version' put: '13';		headerAt: 'Sec-WebSocket-Key' put: ZnWebSocketUtils newClientKey.	^ client   	! !!ZnWebSocket methodsFor: 'initialize-release' stamp: 'CompatibleUserName 2/13/2024 13:57:00'!close	"Send a close frame and close the connection"	self sendFrame: ZnWebSocketFrame close.	stream close.! !!ZnWebSocket methodsFor: 'private' stamp: 'CompatibleUserName 2/13/2024 13:57:00'!handleControlFrame: frame	"Handle a control frame. ConnectionClosed is signalled when the other end closes."		frame isClose 		ifTrue: [ 			self logControlFrameHandled: #close.			self close. 			^ self signalClosed: frame ].	frame isPing 		ifTrue: [ 			self logControlFrameHandled: #ping.			self pong: frame body ].	frame isPong 		ifTrue: [			self logControlFrameHandled: #pong ]! !!ZnWebSocket methodsFor: 'protocol' stamp: 'CompatibleUserName 2/13/2024 13:57:00'!handleControlFrameNoWait	"Peek for a control frame if any and handle it. Do not wait.	Return true when a control frame was handled, false otherwise."		(stream isDataAvailable and: [ (stream peek bitAnd: 127) > 7 ])		ifTrue: [ | frame |			frame := ZnWebSocketFrame readFrom: stream.			self handleControlFrame: frame.			^ true ].	^ false! !!ZnWebSocket methodsFor: 'initialize-release' stamp: 'CompatibleUserName 2/13/2024 13:57:00'!initialize	super initialize.	role := #server! !!ZnWebSocket methodsFor: 'testing' stamp: 'CompatibleUserName 2/13/2024 13:57:00'!isClient	"Return true if the receiver is the client in a WebSocket conversation"		^ role = #client! !!ZnWebSocket methodsFor: 'testing' stamp: 'CompatibleUserName 2/13/2024 13:57:00'!isConnected	"Return true when I am connected, 	i.e. not closed and still connected at the socket level"	^ stream notNil and: [ stream isConnected ]! !!ZnWebSocket methodsFor: 'testing' stamp: 'CompatibleUserName 2/13/2024 13:57:00'!isServer	"Return true if the receiver is the server in a WebSocket conversation"	^ role = #server! !!ZnWebSocket methodsFor: 'private' stamp: 'CompatibleUserName 2/13/2024 13:57:00'!logControlFrameHandled: type	ZnWebSocketControlFrameHandledEvent new		type: type;		emit! !!ZnWebSocket methodsFor: 'accessing' stamp: 'CompatibleUserName 2/13/2024 13:57:00'!logGeneric: subject	ZnWebSocketGenericLogEvent new		subject: subject;		emit! !!ZnWebSocket methodsFor: 'initialize-release' stamp: 'CompatibleUserName 2/13/2024 13:57:00'!onStream: socketStream	"Initialize the receiver on socketStream"		stream := socketStream ! !!ZnWebSocket methodsFor: 'protocol' stamp: 'CompatibleUserName 2/13/2024 13:57:00'!ping	"Send a generic ping (with an empty payload).	Ping messages are sent automatically from #runWith: as a keep alive	whenever the connection times out and loops. 	The interval is thus the connection's read time out"		self pingEmpty! !!ZnWebSocket methodsFor: 'protocol' stamp: 'CompatibleUserName 2/13/2024 13:57:00'!ping: payload	"Send a ping frame with payload"	| frame |	frame := ZnWebSocketFrame ping: payload.	self sendFrame: frame! !!ZnWebSocket methodsFor: 'protocol' stamp: 'CompatibleUserName 2/13/2024 13:57:00'!pingEmpty	"Send a ping with an empty payload."	self ping: #[ ]! !!ZnWebSocket methodsFor: 'protocol' stamp: 'CompatibleUserName 2/13/2024 13:57:00'!pingRandom	"Send a ping with a 4-byte random payload."	self ping: ZnWebSocketUtils newPingPayload! !!ZnWebSocket methodsFor: 'private' stamp: 'CompatibleUserName 2/13/2024 13:57:00'!pong: payload	"Send a pong frame containing payload (in reply to a ping with that payload)"		| frame |	frame := ZnWebSocketFrame pong: payload.	self sendFrame: frame ! !!ZnWebSocket methodsFor: 'printing' stamp: 'CompatibleUserName 2/13/2024 13:57:00'!printOn: aStream	super printOn: aStream.	aStream 		nextPut: $(; 		print: role;		nextPut: $)! !!ZnWebSocket methodsFor: 'private' stamp: 'CompatibleUserName 2/13/2024 13:57:00'!readFrame	"Read and return the next non-control frame. Wait.	Control frames are handled. ConnectionClosed is signalled when the other end closes."		| frame |	frame := ZnWebSocketFrame readFrom: stream.	frame isControl 		ifTrue: [			self handleControlFrame: frame.			^ self readFrame ].	^ frame! !!ZnWebSocket methodsFor: 'protocol' stamp: 'CompatibleUserName 2/13/2024 13:57:00'!readMessage	"Read and return a complete message String or ByteArray, joining frames. 	ConnectionClosed is signalled when the other end closes."		| frame bytes isText |	frame := self readFrame.	frame isFinal ifTrue: [ ^ frame contents ].	isText := frame isText.	bytes := ByteArray new: frame size * 2 streamContents: [ :output |		frame writeRawBodyOn: output.		[ 			frame := self readFrame.			self assert: frame isContinuation. 			frame writeRawBodyOn: output.			frame isFinal ] whileFalse ].	^ isText 		ifTrue: [ ZnUTF8Encoder new decodeBytes: bytes ]		ifFalse: [ bytes ]! !!ZnWebSocket methodsFor: 'accessing' stamp: 'CompatibleUserName 2/13/2024 13:57:00'!role	"Return the role of the receiver, either #client or #server"		^ role! !!ZnWebSocket methodsFor: 'initialize-release' stamp: 'CompatibleUserName 2/13/2024 13:57:00'!role: symbol	"Set the role of the receiver, either #client or #server"		self assert: (#(client server) includes: symbol).	role := symbol! !!ZnWebSocket methodsFor: 'protocol' stamp: 'CompatibleUserName 2/13/2024 13:57:00'!runWith: block	"Start a run loop handling the WebSocket protocol.	When a message is received, block will be passed a String or ByteArray.	ConnectionClosed will be signalled when the other end closes."		[ | message |		message := nil.		[ message := self readMessage ] 			on: ConnectionTimedOut 			do: [ "Ignore & continue" self ping ].		message ifNotNil: [			block value: message ] ] repeat! !!ZnWebSocket methodsFor: 'protocol' stamp: 'CompatibleUserName 2/13/2024 13:57:00'!sendByteFrames: sequenceableCollection	"Send a binary message consisting of sequenceableCollection byte array frames"	| frame |	self assert: sequenceableCollection size > 1.	(frame := ZnWebSocketFrame bytes: sequenceableCollection first)		final: false.	self sendFrame: frame.	2 to: sequenceableCollection size - 1 do: [ :each |		(frame := ZnWebSocketFrame bytes: (sequenceableCollection at: each))			final: false; opcode: 0.		self sendFrame: frame ].	(frame := ZnWebSocketFrame bytes: sequenceableCollection last)		final: true; opcode: 0.	self sendFrame: frame	! !!ZnWebSocket methodsFor: 'private' stamp: 'CompatibleUserName 2/13/2024 13:57:00'!sendBytes: bytes	"Send bytes in one binary frame"	| frame |	frame := ZnWebSocketFrame bytes: bytes.	self sendFrame: frame! !!ZnWebSocket methodsFor: 'private' stamp: 'CompatibleUserName 2/13/2024 13:57:00'!sendFrame: frame	"Send a single frame, masked when I am in a client role, flush"		frame masked: self isClient.	frame writeOn: stream.	stream flush.! !!ZnWebSocket methodsFor: 'protocol' stamp: 'CompatibleUserName 2/13/2024 13:57:00'!sendMessage: stringOrByteArray	"Send stringOrByteArray in one textual or binary frame"	stringOrByteArray isString		ifTrue: [ self sendText: stringOrByteArray ] 		ifFalse: [ self sendBytes: stringOrByteArray ]! !!ZnWebSocket methodsFor: 'private' stamp: 'CompatibleUserName 2/13/2024 13:57:00'!sendText: string	"Send string in one textual frame"	| frame |	frame := ZnWebSocketFrame text: string.	self sendFrame: frame! !!ZnWebSocket methodsFor: 'protocol' stamp: 'CompatibleUserName 2/13/2024 13:57:00'!sendTextFrames: sequenceableCollection	"Send a textual message consisting of sequenceableCollection string frames"	| frame |	self assert: sequenceableCollection size > 1.	(frame := ZnWebSocketFrame text: sequenceableCollection first)		final: false.	self sendFrame: frame.	2 to: sequenceableCollection size - 1 do: [ :each |		(frame := ZnWebSocketFrame text: (sequenceableCollection at: each))			final: false; opcode: 0.		self sendFrame: frame ].	(frame := ZnWebSocketFrame text: sequenceableCollection last)		final: true; opcode: 0.	self sendFrame: frame	! !!ZnWebSocket methodsFor: 'private' stamp: 'CompatibleUserName 2/13/2024 13:57:00'!signalClosed: frame	"Turn a close frame that we received into a ZnWebSocketClosed exception and signal it."		| exception |	exception := ZnWebSocketClosed new.	frame isEmpty 		ifFalse: [			exception 				code: frame closeCode;				reason: frame closeReason ].	exception signal.! !!ZnWebSocket methodsFor: 'accessing' stamp: 'CompatibleUserName 2/13/2024 13:57:00'!stream	^ stream! !!ZnWebSocketChatroomHandler class methodsFor: 'constants' stamp: 'CompatibleUserName 2/13/2024 13:57:00'!clientHtml	^ '<!!DOCTYPE html><meta charset="utf-8" /><title>WebSocket Chatroom</title><script language="javascript" type="text/javascript">  var wsUri = "ws://" + location.host + "/ws-chatroom";  var websocket;  var output, handleInput, messageInput, sendButton, closeButton;  function init() {    output = document.getElementById("output");    handleInput = document.getElementById("handleInput");    messageInput = document.getElementById("messageInput");    sendButton = document.getElementById("sendButton");    closeButton = document.getElementById("closeButton");    handleInput.value = "user-" + (new Date()).getMilliseconds();    messageInput.onkeyup = function (evt) { if (evt.keyCode == 13) sendChatMessage(evt) }    sendButton.onclick = function (evt) { sendChatMessage(evt) };    closeButton.onclick = function (evt) { closeChat(evt) };    testWebSocket();  }  function testWebSocket() {    writeToScreen(wsUri);    websocket = new WebSocket(wsUri);    websocket.onopen = function(evt) { onOpen(evt) };    websocket.onclose = function(evt) { onClose(evt) };    websocket.onmessage = function(evt) { onMessage(evt) };    websocket.onerror = function(evt) { onError(evt) };  }  function onOpen(evt) {    writeToScreen("CONNECTED");    doSend("Hi there !!");  }  function onClose(evt) {    writeToScreen("DISCONNECTED");  }  function onMessage(evt) {    writeToScreen(evt.data);   }  function onError(evt) {    writeToScreen("<span style=''color: red''>ERROR:</span> " + evt.data);  }  function doSend(message) {     websocket.send(handleInput.value + ">>" + message);  }  function writeToScreen(message) {    var pre = document.createElement("p");    pre.style.wordWrap = "break-word";    pre.innerHTML = message;    output.appendChild(pre);  }  function sendChatMessage(evt) {    doSend(messageInput.value);    messageInput.value = "";  }  function closeChat(evt) {    doSend("Bye!!");    websocket.close();  }  window.addEventListener("load", init, false);</script><h2>WebSocket Chatroom</h2><div>Handle: <input id="handleInput" type="text"/>Message: <input id="messageInput" type="text" size="64"/> <input id="sendButton" type="submit" value="Send"/><input id="closeButton" type="submit" value="Close"/></div><div id="output"></div></html> '! !!ZnWebSocketChatroomHandler methodsFor: 'protocol' stamp: 'CompatibleUserName 2/13/2024 13:57:00'!distributeMessage: message 	"Send message to all client WebSockets that we know."		lock critical: [		webSockets do: [ :each |			[ each sendMessage: message ]				on: NetworkError 				do: [ :exception |					"We can ignore this (instead of #unregister:-ing the offender), 					since the listener process (see #value:) will do the right thing" 					each logGeneric: exception printString, ' in ditributeMessage, ignoring' ] ] ]! !!ZnWebSocketChatroomHandler methodsFor: 'initialize-release' stamp: 'CompatibleUserName 2/13/2024 13:57:00'!initialize	webSockets := OrderedCollection new.	lock := Mutex new! !!ZnWebSocketChatroomHandler methodsFor: 'protocol' stamp: 'CompatibleUserName 2/13/2024 13:57:00'!register: clientWebSocket	lock critical: [		webSockets add: clientWebSocket ]! !!ZnWebSocketChatroomHandler methodsFor: 'protocol' stamp: 'CompatibleUserName 2/13/2024 13:57:00'!unregister: clientWebSocket	lock critical: [		webSockets remove: clientWebSocket ifAbsent: [ ] ]! !!ZnWebSocketChatroomHandler methodsFor: 'accessing' stamp: 'CompatibleUserName 2/13/2024 13:57:00'!value: webSocket	"I implement a simple chat room service as a server:	distributing incoming messages to all known clients"		[		self register: webSocket.		webSocket runWith: [ :message |			webSocket logGeneric: 'Received message: ', message printString.			self distributeMessage: message ] ] 		on: NetworkError 		do: [			webSocket logGeneric: 'Network error, cleaning up'.			self unregister: webSocket ]! !!ZnWebSocketDelegate class methodsFor: 'constants' stamp: 'CompatibleUserName 2/13/2024 13:57:00'!demoHtml	^ '<?xml version="1.0" encoding="UTF-8"?><!!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html><head><title>Zinc WebSocket Demo</title><style type="text/css">body {  color: black;  background: white;  width: 900px;  font-family: Verdana, Arial, Helvetica, sans-serif;  font-size: 13px;}p {  width: 600px;  padding: 0 20px 10px 20px;} ul,ol {  width: 600px;  padding: 0 5px 5px 30px;} #logo {  color: orange;  font-family: Helvetica, sans-serif;  font-weight: bold;  font-size: 100px;}li {  margin-bottom: 1em;}</style></head><body><div id="logo">Zn</div><h1>Zinc WebSocket Demo</h1><ul>  <li><a href="ws-echo-client">Echo</a> - websocket hello world: client connects, sends one message, server does an echo, client receives and shows message and disconnects</li>  <li><a href="ws-echo-client-remote">Echo Remote</a> - websocket hello world against ws://echo.websocket.org (<a href="http://websocket.org">http://websocket.org</a>) for reference</li>  <li><a href="ws-status-client">Status</a> - server side pushes continuous updates to client web page</li>  <li><a href="ws-chatroom-client">Chatroom</a> - very simple chatroom: pick a handle and talk to all connected browsers</li></ul><h4>May the Source be with you!!</h4></body></html>'! !!ZnWebSocketDelegate class methodsFor: 'instance creation' stamp: 'CompatibleUserName 2/13/2024 13:57:00'!handler: handler	"Create and return a new ZnWebSocketDelegate that maps / to handler"	^ self new		handler: handler;		yourself! !!ZnWebSocketDelegate class methodsFor: 'examples' stamp: 'CompatibleUserName 2/13/2024 13:57:00'!installExamplesInDefaultServer	"Install the WebSocket examples in ZnServer default, 	provided it has a ZnDefaultServerDelegate"		self installExamplesInServer: ZnServer default! !!ZnWebSocketDelegate class methodsFor: 'examples' stamp: 'CompatibleUserName 2/13/2024 13:57:00'!installExamplesInServer: znServer	"Install the WebSocket examples in znServer, provided it has a ZnDefaultServerDelegate"		znServer delegate	     map: 'ws-demo'		to: [ :request | ZnResponse ok: (ZnEntity html: self demoHtml) ];		map: 'ws-echo-client-remote' 		to: [ :request | ZnResponse ok: (ZnEntity html: ZnWebSocketEchoHandler clientHtmlRemote) ];		map: 'ws-echo-client' 		to: [ :request | ZnResponse ok: (ZnEntity html: ZnWebSocketEchoHandler clientHtml) ];		map: 'ws-echo'		to: (self map: 'ws-echo' to: ZnWebSocketEchoHandler new);		map: 'ws-chatroom-client' 		to: [ :request | ZnResponse ok: (ZnEntity html: ZnWebSocketChatroomHandler clientHtml) ];		map: 'ws-chatroom'		to: (self map: 'ws-chatroom' to: ZnWebSocketChatroomHandler new);		map: 'ws-status-client' 		to: [ :request | ZnResponse ok: (ZnEntity html: ZnWebSocketStatusHandler clientHtml) ];		map: 'ws-status'		to: (self map: 'ws-status' to: ZnWebSocketStatusHandler new)! !!ZnWebSocketDelegate class methodsFor: 'instance creation' stamp: 'CompatibleUserName 2/13/2024 13:57:00'!map: prefix to: handler	"Create and return a new ZnWebSocketDelegate that maps prefix string to handler"	^ self new		prefixFromString: prefix;		handler: handler;		yourself! !!ZnWebSocketDelegate methodsFor: 'protocol' stamp: 'CompatibleUserName 2/13/2024 13:57:00'!continuation	"Return a block that defines what happens after a successful connection upgrade.	We will receive a ready-to-use instanciated WebSocket.	We delegate processing to our handler."	^ [ :webSocket | self handler value: webSocket ]! !!ZnWebSocketDelegate methodsFor: 'public' stamp: 'CompatibleUserName 2/13/2024 13:57:00'!handleRequest: request	"Server delegate entry point"		(prefix isNil or: [ prefix = request uri pathSegments ])		ifFalse: [ ^ ZnResponse notFound: request uri ].	^ (self isValidWebSocketRequest: request)			ifTrue: [ self webSocketResponseForRequest: request ]			ifFalse: [ ZnResponse badRequest: request ]! !!ZnWebSocketDelegate methodsFor: 'accessing' stamp: 'CompatibleUserName 2/13/2024 13:57:00'!handler	"Return the block that will deal with the server side WebSocket,	once a new WebSocket connection is accepted.	The block will be evaluated with an instanciated ZnWebSocket instance as argument."	^ handler! !!ZnWebSocketDelegate methodsFor: 'initialize-release' stamp: 'CompatibleUserName 2/13/2024 13:57:00'!handler: block	"Set the block that will deal with the server side WebSocket"		handler := block! !!ZnWebSocketDelegate methodsFor: 'protocol' stamp: 'CompatibleUserName 2/13/2024 13:57:00'!isValidWebSocketRequest: request	"Return true when request can be considered a valid WebSocket setup request"		^ request method = #GET			and: [ (request headers at: 'Upgrade' ifAbsent: [ ^ false ]) asLowercase = 'websocket' 				and: [ (ZnWebSocketUtils containsConnectionUpgrade: request headers) 					and: [ (request headers at: 'Sec-WebSocket-Version' ifAbsent: [ ^ false ]) = '13'						and: [ request headers includesKey: 'Sec-WebSocket-Key' ] ] ] ]! !!ZnWebSocketDelegate methodsFor: 'accessing' stamp: 'CompatibleUserName 2/13/2024 13:57:00'!prefix	"Return my prefix, the path elements under which I should handle a request"		^ prefix! !!ZnWebSocketDelegate methodsFor: 'private' stamp: 'CompatibleUserName 2/13/2024 13:57:00'!prefix: orderedCollection	"Set my prefix to orderedCollection, interpreted as path elements.	I will only handle requests that match."		orderedCollection isEmpty		ifFalse: [ prefix := orderedCollection ]! !!ZnWebSocketDelegate methodsFor: 'initialize-release' stamp: 'CompatibleUserName 2/13/2024 13:57:00'!prefixFromString: string	"Set the path prefix under which I should be handling request to string,	interpreting each /-separated token as a path element"	self prefix: (string findTokens: '/')! !!ZnWebSocketDelegate methodsFor: 'private' stamp: 'CompatibleUserName 2/13/2024 13:57:00'!responseHeadersForKey: key	"Return the headers for a WebSocket setup response, given key"		^ ZnHeaders defaultResponseHeaders			at: 'Upgrade' put: 'websocket';			at: 'Connection' put: 'Upgrade';			at: 'Sec-WebSocket-Accept' put: key;			yourself! !!ZnWebSocketDelegate methodsFor: 'public' stamp: 'CompatibleUserName 2/13/2024 13:57:00'!value: request	"I implement the generic #value: message as equivalent to #handleRequest:"		^ self handleRequest: request! !!ZnWebSocketDelegate methodsFor: 'protocol' stamp: 'CompatibleUserName 2/13/2024 13:57:00'!webSocketResponseForRequest: request	"Given a valid WebSocket setup request, return the matching server response"		| acceptKey |	acceptKey := ZnWebSocketUtils handshake: (request headers at: 'Sec-WebSocket-Key').	^ ZnWebSocketResponse new		statusLine: (ZnStatusLine code: 101);		headers: (self responseHeadersForKey: acceptKey);		continuation: self continuation;		yourself		! !!ZnWebSocketEchoHandler class methodsFor: 'constants' stamp: 'CompatibleUserName 2/13/2024 13:57:00'!clientHtml	^ '<!!DOCTYPE html><meta charset="utf-8" /><title>WebSocket Test</title><script language="javascript" type="text/javascript">  var wsUri = "ws://" + location.host + "/ws-echo";  var output;  function init() {    output = document.getElementById("output");    testWebSocket();  }  function testWebSocket() {    writeToScreen(wsUri);    websocket = new WebSocket(wsUri);    websocket.onopen = function(evt) { onOpen(evt) };    websocket.onclose = function(evt) { onClose(evt) };    websocket.onmessage = function(evt) { onMessage(evt) };    websocket.onerror = function(evt) { onError(evt) };  }  function onOpen(evt) {    writeToScreen("CONNECTED");    doSend("WebSocket rocks");  }  function onClose(evt) {    writeToScreen("DISCONNECTED");  }  function onMessage(evt) {    writeToScreen("<span style=''color: blue;''>RESPONSE: " + evt.data+"</span>");    websocket.close();  }  function onError(evt) {    writeToScreen("<span style=''color: red''>ERROR:</span> " + evt.data);  }  function doSend(message) {    writeToScreen("SENT: " + message);     websocket.send(message);  }  function writeToScreen(message) {    var pre = document.createElement("p");    pre.style.wordWrap = "break-word";    pre.innerHTML = message;    output.appendChild(pre);  }  window.addEventListener("load", init, false);</script><h2>WebSocket Test</h2><div id="output"></div></html> '! !!ZnWebSocketEchoHandler class methodsFor: 'constants' stamp: 'CompatibleUserName 2/13/2024 13:57:00'!clientHtmlRemote	^ '<!!DOCTYPE html><meta charset="utf-8" /><title>WebSocket Test</title><script language="javascript" type="text/javascript">  var wsUri = "ws://echo.websocket.org";  var output;  function init() {    output = document.getElementById("output");    testWebSocket();  }  function testWebSocket() {    writeToScreen(wsUri);    websocket = new WebSocket(wsUri);    websocket.onopen = function(evt) { onOpen(evt) };    websocket.onclose = function(evt) { onClose(evt) };    websocket.onmessage = function(evt) { onMessage(evt) };    websocket.onerror = function(evt) { onError(evt) };  }  function onOpen(evt) {    writeToScreen("CONNECTED");    doSend("WebSocket rocks");  }  function onClose(evt) {    writeToScreen("DISCONNECTED");  }  function onMessage(evt) {    writeToScreen("<span style=''color: blue;''>RESPONSE: " + evt.data+"</span>");    websocket.close();  }  function onError(evt) {    writeToScreen("<span style=''color: red''>ERROR:</span> " + evt.data);  }  function doSend(message) {    writeToScreen("SENT: " + message);     websocket.send(message);  }  function writeToScreen(message) {    var pre = document.createElement("p");    pre.style.wordWrap = "break-word";    pre.innerHTML = message;    output.appendChild(pre);  }  window.addEventListener("load", init, false);</script><h2>WebSocket Test</h2><div id="output"></div></html> '! !!ZnWebSocketEchoHandler methodsFor: 'accessing' stamp: 'CompatibleUserName 2/13/2024 13:57:00'!value: webSocket	"I implement an echo service conversation as a server:	reading messages and echoing them back until ConnectionClosed"		[ 		webSocket runWith: [ :message |			webSocket logGeneric: 'Received message: ', message printString, ', echoing'.			webSocket sendMessage: message ] ] 		on: ConnectionClosed 		do: [ webSocket logGeneric: 'Ignoring connection close, done' ]! !!ZnWebSocketFrame class methodsFor: 'instance creation' stamp: 'CompatibleUserName 2/13/2024 13:57:00'!bytes: byteArray	^ self new		opcode: 2;		final: true;		body: byteArray;		yourself! !!ZnWebSocketFrame class methodsFor: 'instance creation' stamp: 'CompatibleUserName 2/13/2024 13:57:00'!close	^ self new		opcode: 8;		final: true;		yourself! !!ZnWebSocketFrame class methodsFor: 'instance creation' stamp: 'CompatibleUserName 2/13/2024 13:57:00'!ping: bytes	^ self new		opcode: 9;		final: true;		body: bytes;		yourself! !!ZnWebSocketFrame class methodsFor: 'instance creation' stamp: 'CompatibleUserName 2/13/2024 13:57:00'!pong: bytes	^ self new		opcode: 10;		final: true;		body: bytes;		yourself! !!ZnWebSocketFrame class methodsFor: 'instance creation' stamp: 'CompatibleUserName 2/13/2024 13:57:00'!readFrom: stream	^ self new		readFrom: stream;		yourself! !!ZnWebSocketFrame class methodsFor: 'instance creation' stamp: 'CompatibleUserName 2/13/2024 13:57:00'!text: string	^ self new		opcode: 1;		final: true;		text: string;		yourself! !!ZnWebSocketFrame methodsFor: 'accessing' stamp: 'CompatibleUserName 2/13/2024 13:57:00'!body	^ body! !!ZnWebSocketFrame methodsFor: 'accessing' stamp: 'CompatibleUserName 2/13/2024 13:57:00'!body: anObject	body := anObject! !!ZnWebSocketFrame methodsFor: 'accessing' stamp: 'CompatibleUserName 2/13/2024 13:57:00'!closeCode	self assert: self isClose.	self assert: self isEmpty not.	^ (body readStream next: 2) asInteger	! !!ZnWebSocketFrame methodsFor: 'accessing' stamp: 'CompatibleUserName 2/13/2024 13:57:00'!closeReason	self assert: self isClose.	self assert: self isEmpty not.	^ ZnUTF8Encoder new decodeBytes: (body allButFirst: 2)	! !!ZnWebSocketFrame methodsFor: 'accessing' stamp: 'CompatibleUserName 2/13/2024 13:57:00'!contents	self assert: self isControl not.	^ self isText		ifTrue: [ self text ]		ifFalse: [ body ]! !!ZnWebSocketFrame methodsFor: 'accessing' stamp: 'CompatibleUserName 2/13/2024 13:57:00'!final	^ final! !!ZnWebSocketFrame methodsFor: 'accessing' stamp: 'CompatibleUserName 2/13/2024 13:57:00'!final: anObject	final := anObject! !!ZnWebSocketFrame methodsFor: 'initialize-release' stamp: 'CompatibleUserName 2/13/2024 13:57:00'!initialize	super initialize.	final := true! !!ZnWebSocketFrame methodsFor: 'testing' stamp: 'CompatibleUserName 2/13/2024 13:57:00'!isBinary	^ opcode = 2! !!ZnWebSocketFrame methodsFor: 'testing' stamp: 'CompatibleUserName 2/13/2024 13:57:00'!isClose	^ opcode = 8! !!ZnWebSocketFrame methodsFor: 'testing' stamp: 'CompatibleUserName 2/13/2024 13:57:00'!isContinuation	^ opcode = 0! !!ZnWebSocketFrame methodsFor: 'testing' stamp: 'CompatibleUserName 2/13/2024 13:57:00'!isControl	^ opcode > 7! !!ZnWebSocketFrame methodsFor: 'testing' stamp: 'CompatibleUserName 2/13/2024 13:57:00'!isEmpty	^ self size = 0! !!ZnWebSocketFrame methodsFor: 'testing' stamp: 'CompatibleUserName 2/13/2024 13:57:00'!isFinal	^ final! !!ZnWebSocketFrame methodsFor: 'testing' stamp: 'CompatibleUserName 2/13/2024 13:57:00'!isMasked	^ masked! !!ZnWebSocketFrame methodsFor: 'testing' stamp: 'CompatibleUserName 2/13/2024 13:57:00'!isPing	^ opcode = 9! !!ZnWebSocketFrame methodsFor: 'testing' stamp: 'CompatibleUserName 2/13/2024 13:57:00'!isPong	^ opcode = 10! !!ZnWebSocketFrame methodsFor: 'testing' stamp: 'CompatibleUserName 2/13/2024 13:57:00'!isText	^ opcode = 1! !!ZnWebSocketFrame methodsFor: 'accessing' stamp: 'CompatibleUserName 2/13/2024 13:57:00'!masked	^ masked! !!ZnWebSocketFrame methodsFor: 'accessing' stamp: 'CompatibleUserName 2/13/2024 13:57:00'!masked: anObject	masked := anObject! !!ZnWebSocketFrame methodsFor: 'accessing' stamp: 'CompatibleUserName 2/13/2024 13:57:00'!opcode	^ opcode! !!ZnWebSocketFrame methodsFor: 'accessing' stamp: 'CompatibleUserName 2/13/2024 13:57:00'!opcode: anObject	opcode := anObject! !!ZnWebSocketFrame methodsFor: 'accessing' stamp: 'CompatibleUserName 2/13/2024 13:57:00'!opcodeName	| name |	self assert: (opcode between: 0 and: 15).	name := #(continuation text binary nil nil nil nil nil close ping pong nil nil nil nil nil) at: opcode + 1.	^ name ifNil: [ opcode asString ] ifNotNil: [ name ]! !!ZnWebSocketFrame methodsFor: 'printing' stamp: 'CompatibleUserName 2/13/2024 13:57:00'!printOn: stream	super printOn: stream.	stream 		nextPut: $(; 		print: self opcodeName;		space;		print: self size; nextPut: $B; 		space;		nextPutAll: (final ifTrue: [ 'final' ] ifFalse: [ 'non-final' ]);		nextPut: $)! !!ZnWebSocketFrame methodsFor: 'private' stamp: 'CompatibleUserName 2/13/2024 13:57:00'!readBodyOfSize: size from: stream	| mask |	masked 		ifTrue: [ 			mask := stream next: 4.			body := ByteArray new: size streamContents: [ :out |				1 to: size do: [ :index |					out nextPut: (stream next bitXor: (mask at: ((index - 1) \\ 4) + 1)) ] ] ]		ifFalse: [			body := stream next: size ]! !!ZnWebSocketFrame methodsFor: 'reading' stamp: 'CompatibleUserName 2/13/2024 13:57:00'!readFrom: stream	| byte size mask |	(byte := stream next) ifNil: [ ConnectionClosed signal ].	final := (byte bitAt: 8) = 1.	opcode := byte bitAnd: 127.	(byte := stream next) ifNil: [ ConnectionClosed signal ].	masked := (byte bitAt: 8) = 1.	size := byte bitAnd: 127.	size < 126		ifFalse: [			size = 126				ifTrue: [ size := (stream next: 2) asInteger ]				ifFalse: [ size := (stream next: 8) asInteger ].			size = 0 ifTrue: [ ConnectionClosed signal ] ].	self readBodyOfSize: size from: stream! !!ZnWebSocketFrame methodsFor: 'accessing' stamp: 'CompatibleUserName 2/13/2024 13:57:00'!size	"Return the body size in bytes"		^ body 		ifNil: [ 0 ] 		ifNotNil: [ body size ].! !!ZnWebSocketFrame methodsFor: 'accessing' stamp: 'CompatibleUserName 2/13/2024 13:57:00'!text	^ ZnUTF8Encoder new decodeBytes: body! !!ZnWebSocketFrame methodsFor: 'accessing' stamp: 'CompatibleUserName 2/13/2024 13:57:00'!text: string	self body: (ZnUTF8Encoder new encodeString: string)! !!ZnWebSocketFrame methodsFor: 'private' stamp: 'CompatibleUserName 2/13/2024 13:57:00'!writeBodyOfSize: size on: stream	| mask |	masked		ifTrue: [			mask := ZnWebSocketUtils newMask.			stream nextPutAll: mask ].	size = 0 ifTrue: [ ^ self ].	masked 		ifTrue: [			body doWithIndex: [ :each :index |				stream nextPut: (each bitXor: (mask at: ((index - 1) \\ 4) + 1)) ] ] 		ifFalse: [ self writeRawBodyOn: stream ]! !!ZnWebSocketFrame methodsFor: 'writing' stamp: 'CompatibleUserName 2/13/2024 13:57:00'!writeOn: stream	| byte size |	byte := (final ifTrue: [ 128 ] ifFalse: [ 0 ]) + opcode.	stream nextPut: byte.	byte := (masked ifTrue: [ 128 ] ifFalse: [ 0 ]).	(size := self size) < 126		ifTrue: [ stream nextPut: (byte + size) ]		ifFalse: [			size < 65536				ifTrue: [ stream nextPut: (byte + 126); nextPutAll: (size asByteArrayOfSize: 2) ]				ifFalse: [					self assert: size < (2 raisedTo: 31).					stream nextPut: (byte + 127); nextPutAll: (size asByteArrayOfSize: 8) ] ].	self writeBodyOfSize: size on: stream ! !!ZnWebSocketFrame methodsFor: 'private' stamp: 'CompatibleUserName 2/13/2024 13:57:00'!writeRawBodyOn: stream	self isEmpty		ifFalse: [ stream nextPutAll: body ]! !!ZnWebSocketStatusHandler class methodsFor: 'constants' stamp: 'CompatibleUserName 2/13/2024 13:57:00'!clientHtml	^ '<!!DOCTYPE html><meta charset="utf-8" /><title>WebSocket Smalltalk Image Status Stream</title><script language="javascript" type="text/javascript">  var wsUri = "ws://" + location.host + "/ws-status";  var output, statusElement;  function init() {    output = document.getElementById("output");    statusElement = document.getElementById("status");    testWebSocket();  }  function testWebSocket() {    writeToScreen(wsUri);    websocket = new WebSocket(wsUri);    websocket.onopen = function(evt) { onOpen(evt) };    websocket.onclose = function(evt) { onClose(evt) };    websocket.onmessage = function(evt) { onMessage(evt) };    websocket.onerror = function(evt) { onError(evt) };  }  function onOpen(evt) {    writeToScreen("CONNECTED");    setStatus("Waiting for status data...");   }  function onClose(evt) {    writeToScreen("DISCONNECTED");  }  function onMessage(evt) {    setStatus(evt.data);  }  function onError(evt) {    writeToScreen("<span style=''color: red''>ERROR:</span> " + evt.data);  }  function writeToScreen(message) {    var pre = document.createElement("p");    pre.style.wordWrap = "break-word";    pre.innerHTML = message;    output.appendChild(pre);  }  function setStatus(text) {    statusElement.innerHTML = text;  }  window.addEventListener("load", init, false);</script><h2>WebSocket Smalltalk Image Status Stream</h2><div><pre id="status"></pre></div><h3>Log</h3><div id="output"></div></html> '! !!ZnWebSocketStatusHandler methodsFor: 'accessing' stamp: 'CompatibleUserName 2/13/2024 13:57:00'!processes	| allProcesses |	allProcesses := (Process allSubInstances		reject: [ :each | each isTerminated or: [ each = Processor activeProcess ] ])			sorted: [ :a :b | a priority >= b priority ].	^ String streamContents: [ :out |		allProcesses doWithIndex: [ :each :index |			out 				print: index; nextPut: $.; space; 				nextPutAll: each name; space;				nextPut: $[; print: each priority; nextPut: $]; space;				print: each; cr ] ]! !!ZnWebSocketStatusHandler methodsFor: 'accessing' stamp: 'CompatibleUserName 2/13/2024 13:57:00'!status	^ String cr join: { 		DateAndTime now printString. 		self systemVersionInfo. 		self vmStats. 		self processes }! !!ZnWebSocketStatusHandler methodsFor: 'accessing' stamp: 'CompatibleUserName 2/13/2024 13:57:00'!systemVersionInfo	^ String streamContents: [ :stream |			stream 				print: SystemVersion current; 				nextPutAll: ' - '; 				nextPutAll: ZnConstants defaultServerString ]! !!ZnWebSocketStatusHandler methodsFor: 'accessing' stamp: 'CompatibleUserName 2/13/2024 13:57:00'!value: webSocket	"I stream status messages to a WebSocket client, once every second 	until ConnectionClosed or no longer isConnected"		[ 		webSocket logGeneric: 'Started status streaming'.		[ 			webSocket sendMessage: self status.			1 second asDelay wait.			webSocket isConnected ] whileTrue ] 		on: NetworkError  		do: [ webSocket logGeneric: 'Ignoring network error' ].	webSocket logGeneric: 'Stopping status streaming' ! !!ZnWebSocketStatusHandler methodsFor: 'accessing' stamp: 'CompatibleUserName 2/13/2024 13:57:00'!vmStats	^ SmalltalkImage current vm statisticsReport! !!ZnWebSocketUtils class methodsFor: 'accessing' stamp: 'CompatibleUserName 2/13/2024 13:57:00'!containsConnectionUpgrade: headers	^ (((headers at: 'Connection' ifAbsent: [ ^ false ]) 			findTokens: ',') 				collect: [ :each | each trimBoth asLowercase ]) 					includes: 'upgrade'! !!ZnWebSocketUtils class methodsFor: 'protocol' stamp: 'CompatibleUserName 2/13/2024 13:57:00'!handshake: clientKey	"Perform the WebSocket key handshake"		"self handshake: 'dGhlIHNhbXBsZSBub25jZQ=='"		| string hash |	string := clientKey, self serverGUID.	hash := SHA1 hashMessage: string.	^ ZnUtils encodeBase64: hash! !!ZnWebSocketUtils class methodsFor: 'protocol' stamp: 'CompatibleUserName 2/13/2024 13:57:00'!newClientKey	"Generate a new WebSocket client key"		| rawKey |	rawKey := self randomByteArrayOfSize: 16.	^ ZnUtils encodeBase64: rawKey! !!ZnWebSocketUtils class methodsFor: 'accessing' stamp: 'CompatibleUserName 2/13/2024 13:57:00'!newMask	^ self randomByteArrayOfSize: 4! !!ZnWebSocketUtils class methodsFor: 'accessing' stamp: 'CompatibleUserName 2/13/2024 13:57:00'!newPingPayload	^ self randomByteArrayOfSize: 4! !!ZnWebSocketUtils class methodsFor: 'accessing' stamp: 'CompatibleUserName 2/13/2024 13:57:00'!randomByteArrayOfSize: size	^ ByteArray new: size streamContents: [ :stream |		size timesRepeat: [ 			stream nextPut: 256 atRandom - 1 ] ].! !!ZnWebSocketUtils class methodsFor: 'constants' stamp: 'CompatibleUserName 2/13/2024 13:57:00'!serverGUID	"This is the special WebSocket server GUID"		^ '258EAFA5-E914-47DA-95CA-C5AB0DC85B11'! !"Zinc-WebSocket-Core"!!PjTClosedBlockClosure commentStamp: '' prior: 0!Trait for closed block closure handling!!PjTJavascriptGlobalsInitializer commentStamp: '' prior: 0!I am dedicated to shared dictionaries with JS globals that are defined outside PharoJS  i.e. subclasses of PjJavascriptGlobals of PharoJS users. I provide them with the class side initialize method to ensure the JS globals are initialized to JS proxies in Pharo.!!PjTStreamWriter commentStamp: '' prior: 0!I provide implementations for common and low-level stream writing methods for PjStringGenerator, PjSelectorGenerator, and PjTranspiler!!ManifestPharoJsBaseTranspiler commentStamp: '' prior: 0!I store metadata for this package. These meta data are used by other tools such as the SmalllintManifestChecker and the critics Browser!!PjJavascriptGlobals commentStamp: '' prior: 0!I am the master class for all Javascript global sharedpools.Subclasses may simply enumerate globals as class variables, or they may be polyfills that will emit some extra code to enable the appropriate global to be accessed.Each polyfil subclass should override one or more of the *Polyfill: methods to write the necessary header code to install the polyfill!!PjProcessPolyfill commentStamp: '' prior: 0!I am a polyfill to initialize some globals in a web browser.!!PjUniversalGlobals commentStamp: '' prior: 0!I contain globals for all Javascript engines!!PjNodeMinGlobals commentStamp: '' prior: 0!I contain the globals for the Node-based Javascript engines including Electron!!PjWebSocketPolyfill commentStamp: '' prior: 0!I am the polyfill for WebSocket for Node.This will force the appropriate package to be loaded when running on Node.!!PjDomGlobals commentStamp: '' prior: 0!I contain the globals for all DOM-based Javascript enginesUse PjUniversalGlobals too!!PjBrowserGlobals commentStamp: '' prior: 0!I contain globals for all browser Javascript engines.Use PjDomGlobals and PjUniversalGlobals too.!!PjNodeGlobals commentStamp: '' prior: 0!I contain the globals for the NodeJS Javascript engine.!!PjClosedFullBlockClosure commentStamp: '' prior: 0!I represent a closed full block closure!!PjJavascriptTranspilationError commentStamp: '' prior: 0!I am an error from the PharoJS Transpiler that you are doing something wrong:Possible reasons:1) you have an open block that you are converting but it has free variables2) You reference a class that is not in the set of classes that make up your application.!!PjAstConverter commentStamp: '' prior: 0!I translate Smalltalk ASTs into PjAST (javascript ASTs)!!PjBlockClosureAnalyser commentStamp: '' prior: 0!I am used to analyse BlockClosures.To close a block closure, i make copies of all free variables in the context of the original block.!!PjCore commentStamp: '' prior: 0!This class is always included upon converting any code to javascript. It provides core features to bootstrap PharoJs.It is called Smalltalk in Javascript and isn't a class proper, because it has to be in place for normal class setup. It only has "class side" methods.It is output specially by the Exporter.!!PjJavascriptAstNode commentStamp: '' prior: 0!I encode a Javascript AST ready to be output.Used also for test to see if the transpilation makes the right AST!!PjApplyNode commentStamp: '' prior: 0!I am part of the representation of a Javascript AST for visiting with a subclass of PjASTVisitor or PjASTEqual!!PjArrayNode commentStamp: '' prior: 0!I am part of the representation of a Javascript AST for visiting with a subclass of PjASTVisitor or PjASTEqual!!PjAssignNode commentStamp: '' prior: 0!I am part of the representation of a Javascript AST for visiting with a subclass of PjASTVisitor or PjASTEqual!!PjBinaryNode commentStamp: '' prior: 0!I am part of the representation of a Javascript AST for visiting with a subclass of PjASTVisitor or PjASTEqual!!PjFieldNode commentStamp: '' prior: 0!I am part of the representation of a Javascript AST for visiting with a subclass of PjASTVisitor or PjASTEqual!!PjFunctionNode commentStamp: '' prior: 0!I am part of the representation of a Javascript AST for visiting with a subclass of PjASTVisitor!!PjBlockNode commentStamp: '' prior: 0!I am part of the representation of a Javascript AST for visiting with a subclass of PjASTVisitor!!PjMethodNode commentStamp: '' prior: 0!I am part of the representation of a Javascript AST for visiting with a subclass of PjASTVisitor!!PjLiteralNode commentStamp: '' prior: 0!I am part of the representation of a Javascript AST for visiting with a subclass of PjASTVisitor!!PjLiteralValueNode commentStamp: '' prior: 0!I am part of the representation of a Javascript AST for visiting with a subclass of PjASTVisitor or PjASTEqual!!PjNilNode commentStamp: '' prior: 0!I am part of the representation of a Javascript AST for visiting with a subclass of PjASTVisitor!!PjMessageSelectorNode commentStamp: '' prior: 0!I am part of the representation of a Javascript AST for visiting with a subclass of PjASTVisitor!!PjObjectNode commentStamp: '' prior: 0!I produce a Javascript object with fields from my dictionary!!PjReturnNode commentStamp: '' prior: 0!I am part of the representation of a Javascript AST for visiting with a subclass of PjASTVisitor or PjASTEqual!!PjNonLocalReturnNode commentStamp: '' prior: 0!I am part of the representation of a Javascript AST for visiting with a subclass of PjASTVisitor or PjASTEqual!!PjSelfNode commentStamp: '' prior: 0!I am part of the representation of a Javascript AST for visiting with a subclass of PjASTVisitor or PjASTEqual!!PjSuperNode commentStamp: '' prior: 0!I am part of the representation of a Javascript AST for visiting with a subclass of PjASTVisitor!!PjSequenceNode commentStamp: '' prior: 0!I am part of the representation of a Javascript AST for visiting with a subclass of PjASTVisitor or PjASTEqual!!PjTryNode commentStamp: '' prior: 0!I am part of the representation of a Javascript AST for visiting with a subclass of PjASTVisitor or PjASTEqual!!PjUnaryNode commentStamp: '' prior: 0!I am part of the representation of a Javascript AST for visiting with a subclass of PjASTVisitor or PjASTEqual!!PjUnparsedStringNode commentStamp: '' prior: 0!I contain strings that ahould go literally into the output stream!!PjVariableNode commentStamp: '' prior: 0!I am part of the representation of a Javascript AST for visiting with a subclass of PjASTVisitor or PjASTEqual!!PjArgumentNode commentStamp: '' prior: 0!I am a parameter to a method or a block argument for visiting with a subclass of PjASTVisitor!!PjClassNode commentStamp: '' prior: 0!I am a class node (a global class) for visiting with a subclass of PjASTVisitor!!PjClassVariableNode commentStamp: '' prior: 0!I am a class variable for visiting with a subclass of PjASTVisitor!!PjPoolVariableNode commentStamp: '' prior: 0!I am a pool variable for visiting with a subclass of PjASTVisitor!!PjGlobalNode commentStamp: '' prior: 0!I am a globale variable for visiting with a subclass of PjASTVisitor!!PjInstanceVariableNode commentStamp: '' prior: 0!I am an instance variable for visiting with a subclass of PjASTVisitor!!PjTempVariableNode commentStamp: '' prior: 0!I am a temporary variable in a method for visiting with a subclass of PjASTVisitor!!PjMessageConverter commentStamp: '' prior: 0!I manage the message conversions so that for each selector they will be executed in order, with the first successful one adopted. See Chain-of-Responsibility pattern.!!PjSpecialMessageConversion commentStamp: '' prior: 0!I am an abstract class for PjAST optimizations!!PjJsAtConversion commentStamp: '' prior: 0!I optimize js_at: to Javascript object/array references.Required by bootstrap code!!PjJsAtPutConversion commentStamp: '' prior: 0!I optimize js_at:put: to Javascript object/array references.Required by bootstrap code!!PjJsThisConversion commentStamp: '' prior: 0!I am a weird conversion to provide a way for an event handle to reference the 'this' value which refers to the object to which the event handler was attached.'!!PjNotOptimization commentStamp: '' prior: 0!I am an optimizatino to the unary message not!!PjOptionalMessageConversion commentStamp: '' prior: 0!I am a structural placeholder for all conversions that are not loaded by default.!!PjStringGenerator commentStamp: '' prior: 0!I am a visitor to convert a Javascript AST into a string.Includes $asNil$ optimization for field references in cases such as self, literals and ifNotNil. Maybe this should be extracted to another object. One of the challenges is to produce minimal parentheses based on the crazy numer of operator presedense rules for Javascript:Precedence	Operator type	Associativity19	Grouping		(  )18	Member Access	left-to-right	. [] new17	Function Call 	left-to-right	 (  )16	Postfix Incr/decr		++	--15	Logical NOT	right-to-left	!! 	Bitwise NOT	right-to-left	~ 	Unary Plus	right-to-left	+ 	Unary Negation	right-to-left	- 	Prefix Incr/decr	right-to-left	++ 	-- 	typeof	right-to-left	typeof 	void		right-to-left	void 	delete	right-to-left	delete 14	Exponentiation	right-to-left	 ** 	Multiplication	left-to-right	 * 	Division	left-to-right	 / 	Remainder	left-to-right	 % 13	Addition	left-to-right	 + 	Subtraction	left-to-right	 - 12	Bitwise Left Shift	left-to-right	 << 	Bitwise Right Shift	left-to-right	 >> 	Bitwise Unsigned Right Shift	left-to-right	 >>> 11	Less Than	left-to-right	 < 	Less Than Or Equal	left-to-right	 <= 	Greater Than	left-to-right	 > 	Greater Than Or Equal	left-to-right	 >= 	in	left-to-right	 in 	instanceof	left-to-right	 instanceof 10	Equality	left-to-right	 == 	Inequality	left-to-right	 !!= 	Strict Equality	left-to-right	 === 	Strict Inequality	left-to-right	 !!== 9	Bitwise AND	left-to-right	 & 8	Bitwise XOR	left-to-right	 ^ 7	Bitwise OR	left-to-right	 | 6	Logical AND	left-to-right	 && 5	Logical OR	left-to-right	 || 4	Conditional	right-to-left	 ?  : 3	Assignment	right-to-left	 =  	Op assign	right-to-left	+=	-=	**= 							*=	/=	%=	<<=							>>=	>>>=	&=	^=	|=2	yield	right-to-left	yield 	yield*	right-to-left	yield* 1	Spread	n/a	... 0	Comma / Sequence	left-to-right	 , !!PjTranspiler commentStamp: '' prior: 0!I am a Transpiler from Smalltalk classes and objects to Javascript.I use the PjAstConerter to convert a Smalltalk method or block to a PjJavascriptAstNode and then PjAstTo StringGenerator to convert to Javascript code.To avoid collisions with existing JS code, we introduce a prefix for method selectors upon conversion to javascript. The prefix is defined in the class side selectorsPrefix. The default value can be changed on demand.!!PjClosedBlockClosure commentStamp: '' prior: 0!I represent a block closure without any free variable.!!PjValuedClosedBlockClosure commentStamp: '' prior: 0!I represent a closed block closure that is valued upon JS code loading. I am useful for bridge interactions.!!PjTClosedBlockClosure classTrait methodsFor: 'instance creation'!startpc: startpc numArgs: numArgs originalBlock: aBlock	^ (self		   outerContext: nil		   startpc: startpc		   numArgs: numArgs		   copiedValues: #())		  originalBlock: aBlock;		  yourself! !!PjTClosedBlockClosure methodsFor: 'visiting'!acceptVisitor: aPjAstConverter	^ aPjAstConverter convertClosedBlock: self! !!PjTClosedBlockClosure methodsFor: 'public'!asClosedBlock	^self! !!PjTClosedBlockClosure methodsFor: 'accessing'!basicOriginalBlock: aBlock	originalBlock := aBlock.	externalVariablesDict := self externalVariablesDictOf: originalBlock! !!PjTClosedBlockClosure methodsFor: 'converting'!convertToJsUsing: aPjTranspiler 	aPjTranspiler convertClosedBlock: self! !!PjTClosedBlockClosure methodsFor: 'accessing'!externalVariable: variable formContext: context	^variable valueStartAtContext: context! !!PjTClosedBlockClosure methodsFor: 'public'!externalVariable: name fromMethod: method	^ method instVarNamed: name! !!PjTClosedBlockClosure methodsFor: 'public'!externalVariablesDict	^ externalVariablesDict! !!PjTClosedBlockClosure methodsFor: 'testing'!isClosed	^true! !!PjTClosedBlockClosure methodsFor: 'accessing'!originalBlock	^ originalBlock! !!PjTClosedBlockClosure methodsFor: 'accessing'!originalBlock: aBlock	originalBlock := aBlock.	externalVariablesDict := self externalVariablesDictOf: originalBlock! !!PjTClosedBlockClosure methodsFor: 'accessing'!sourceNode	^ originalBlock sourceNode! !!PjTJavascriptGlobalsInitializer classTrait methodsFor: 'class initialization'!initialize	"self initialize"	| proxy |	self classVarNames do: [ : varName |		proxy := PjProxyForGlobal newProxyNamed: varName.		self classVarNamed: varName put: proxy.	]! !!PjTStreamWriter classTrait methodsFor: 'Javascript names'!jsNativePrefix	^ #js_! !!PjTStreamWriter methodsFor: 'writing low-level'!<< aString	self jsStream << aString! !!PjTStreamWriter methodsFor: 'writing low-level'!cr	self jsStream nextPut: self lineEnding! !!PjTStreamWriter methodsFor: 'writing low-level'!crtab	self jsStream crtab! !!PjTStreamWriter methodsFor: 'accessing'!jsNativePrefix	^ self class jsNativePrefix! !!PjTStreamWriter methodsFor: 'accessing'!jsStream	self explicitRequirement! !!PjTStreamWriter methodsFor: 'accessing'!lineEnding	self explicitRequirement! !!PjTStreamWriter methodsFor: 'writing low-level'!nextPut: char	self jsStream nextPut: char! !!PjTStreamWriter methodsFor: 'writing low-level'!nextPutAll: string	self jsStream nextPutAll: string! !!PjTStreamWriter methodsFor: 'writing low-level'!print: anObject	anObject printJsOn: self jsStream! !!PjTStreamWriter methodsFor: 'writing low-level'!space	self jsStream space! !!PjTStreamWriter methodsFor: 'writing'!writeJsSelector: aSelector	self writeJsSelector: aSelector onStream: self! !!PjTStreamWriter methodsFor: 'writing'!writeJsSelector: aSelector onStream: aStream	| isBinary |	(aSelector beginsWith: self jsNativePrefix) ifTrue: [ 			^ aStream nextPutAll: ((aSelector keywords first allButFirst: self jsNativePrefix size) copyWithout: $:) ].	isBinary := aSelector isBinary.	aStream nextPutAll: self pharoJsSelectorPrefix.	aSelector do:[ :each | 			self writeSelectorChar: each on: aStream isInBinarySelector: isBinary ]! !!PjTStreamWriter methodsFor: 'writing'!writeSelectorChar: character on: aStream isInBinarySelector: isInBinarySelector	isInBinarySelector ifTrue: [ 			character asciiValue printOn: aStream.			^aStream nextPut: $_ ].	character = $: ifTrue: [ 		^aStream nextPut: $_ ].	aStream nextPut: character! !!PjTStreamWriter methodsFor: 'writing'!writeVariable: aString escapingIfIn: aCollection	(aCollection includes: aString) ifTrue: [ self nextPut: $$ ].	self nextPutAll: aString! !!RBProgramNode methodsFor: '*PharoJs-Base-Transpiler'!isGlobalVariableNode	^false! !!RBProgramNode methodsFor: '*PharoJs-Base-Transpiler'!isLiteralNumberNode	^false! !!Class methodsFor: '*PharoJs-Base-Transpiler'!asJsAstUsing: astConverter	^ astConverter visitGlobalVariableNamed: self instanceSide name! !!Class methodsFor: '*PharoJs-Base-Transpiler'!classInitializeSelector	(self hasClassMethod: #javascriptInitialize) ifTrue: [ ^#javascriptInitialize ].	^#initialize! !!Class methodsFor: '*PharoJs-Base-Transpiler'!convertToJavascriptAstUsing: aPjAstConverter	^ aPjAstConverter visitGlobalVariableNamed: self name! !!Class methodsFor: '*PharoJs-Base-Transpiler'!convertToJsUsing: transpiler	transpiler convertClass: self.! !!Class methodsFor: '*PharoJs-Base-Transpiler'!hasJavascriptName	^self hasClassMethod: #javascriptName! !!Class methodsFor: '*PharoJs-Base-Transpiler'!isFreeJavascriptValue	^ true! !!Class methodsFor: '*PharoJs-Base-Transpiler'!isJsClassPlaceholder	self hasJavascriptPlaceholder ifTrue: [ 		^ self javascriptPlaceholder isJsClassPlaceholder ].	^self hasJavascriptName and: [self javascriptName ~= self name]! !!Class methodsFor: '*PharoJs-Base-Transpiler'!nameToUseForJsConversion	self hasJavascriptPlaceholder ifTrue: [ ^self javascriptPlaceholder nameToUseForJsConversion].	self hasJavascriptName ifFalse: [ ^self name].	^self javascriptName! !!Class methodsFor: '*PharoJs-Base-Transpiler'!needsClassDeclaration	^self isJsClassPlaceholder not! !!Class methodsFor: '*PharoJs-Base-Transpiler'!needsInitialization	^(self hasClassMethod: #initialize) or: [ self hasClassMethod: #javascriptInitialize ]! !!Class methodsFor: '*PharoJs-Base-Transpiler'!printJsOn: aStream	self error: 'Class doesn''t have a literal representation'! !!Context methodsFor: '*PharoJs-Base-Transpiler'!forScope: aScope 	self sourceNode scope == aScope ifTrue: [ ^self ].	^self outerContext forScope: aScope! !!ManifestPharoJsBaseTranspiler class methodsFor: 'code-critics'!ruleRBCollectionMessagesToExternalObjectRuleV1FalsePositive	^ #(#(#(#RGMethodDefinition #(#PjTranspiler #poolReference:for: #false)) #'2020-01-27T08:49:48.799166-05:00') )! !!PjJavascriptGlobals class methodsFor: 'polyfill'!browserPolyfill: aTranspiler	<pharoJsSkip>! !!PjJavascriptGlobals class methodsFor: 'polyfill'!domPolyfill: aTranspiler	<pharoJsSkip>! !!PjJavascriptGlobals class methodsFor: 'pharojs support'!isJavascriptGlobalsPool	<pharoJsSkip>	^ true! !!PjJavascriptGlobals class methodsFor: 'polyfill'!nodePackageName	<pharoJsSkip>" override this with the name of the package to be require'd "	^ nil! !!PjJavascriptGlobals class methodsFor: 'polyfill'!nodePolyfill: aTranspiler	<pharoJsSkip>	self nodePackageName ifNil: [ ^ self ].	self classVariables size = 1 ifFalse: [ PjJavascriptTranspilationError signal: 'node polyfills should only have 1 class variable' ].	aTranspiler		nextPutAll: 'var ';		nextPutAll: self classVarNames first;		nextPutAll: '=Smalltalk.require("';		nextPutAll: self nodePackageName;		nextPutAll: '");';cr! !!PjJavascriptGlobals class methodsFor: 'polyfill'!requiredPolyfills	^ #()! !!PjProcessPolyfill class methodsFor: 'polyfill'!browserPolyfill: aTranspiler	<pharoJsSkip>	super browserPolyfill: aTranspiler.	aTranspiler		nextPutAll: 'var process=process||{exit:function(){window.close()}};';cr! !!PjWebSocketPolyfill class methodsFor: 'pharojs globals'!nodePackageName	<pharoJsSkip>	^ 'ws'! !!SharedPool class methodsFor: '*PharoJs-Base-Transpiler'!isJavascriptGlobalsPool	^ false! !!LocalVariable methodsFor: '*PharoJs-Base-Transpiler'!valueStartAtContext: aContext	| variableContext  |	(aContext tempNames includes: self name) ifTrue: [ ^aContext tempNamed: self name].	variableContext := aContext forScope: self scope.	^ self readFromContext: variableContext scope: self scope! !!FullBlockClosure methodsFor: '*PharoJs-Base-Transpiler'!closedBlockClass	^ PjClosedFullBlockClosure! !!PjClosedFullBlockClosure methodsFor: 'accessing'!originalBlock: aBlock	receiver := aBlock receiver.	self basicOriginalBlock: aBlock.! !!Dictionary methodsFor: '*PharoJs-Base-Transpiler'!isFreeJavascriptValue	self keysAndValuesDo: [ : key : value |		key isString ifFalse: [ ^ false ] .		value isFreeJavascriptValue ifFalse: [ ^ false ] ].	^ true! !!Dictionary methodsFor: '*PharoJs-Base-Transpiler'!isLiteralJavascriptValue	self keysAndValuesDo: [ : key : value |		key isString ifFalse: [ ^ false ] .		value isLiteralJavascriptValue ifFalse: [ ^ false ] ].	^ true! !!Dictionary methodsFor: '*PharoJs-Base-Transpiler'!printJsOn: aStream	| first |	first := true.	aStream nextPut: ${.	self keysAndValuesDo:  [ : key : value |			first ifFalse: [ aStream nextPut: $, ].			key printJsOn: aStream.			aStream nextPut: $:.			value printJsOn: aStream.			first := false	].	aStream nextPut: $}! !!SystemNavigation class methodsFor: '*PharoJs-Base-Transpiler'!globalRefsForPharoJS: aClassOrLiteral	^ (self default respondsTo: #allGlobalRefsOn:) ifTrue: [			self default allGlobalRefsOn: aClassOrLiteral		] ifFalse: [			self default classRefsToClassName: aClassOrLiteral]! !!Behavior methodsFor: '*PharoJs-Base-Transpiler'!javascriptInheritsFrom: aClass 	"Answer whether the argument, aClass, is on the receiver's superclass 	chain."	| aSuperclass jsClass |	jsClass := aClass javascriptPlaceholderInheritance.	aSuperclass := self superclass.	[aSuperclass == nil]		whileFalse: 			[aSuperclass javascriptPlaceholderInheritance == jsClass ifTrue: [^true].			aSuperclass := aSuperclass superclass].	^false! !!SequenceableCollection methodsFor: '*PharoJs-Base-Transpiler'!includes: seq1 before: seq2	| firstIndex |	firstIndex := self indexOfSubCollection: seq1 startingAt: 1 ifAbsent: [^ false].	self indexOfSubCollection: seq2 startingAt: firstIndex ifAbsent: [ ^ false].	^ true! !!SequenceableCollection methodsFor: '*PharoJs-Base-Transpiler'!isFreeJavascriptValue	^ self allSatisfy: #isFreeJavascriptValue! !!SequenceableCollection methodsFor: '*PharoJs-Base-Transpiler'!isLiteralJavascriptValue	^ self allSatisfy: #isLiteralJavascriptValue! !!SequenceableCollection methodsFor: '*PharoJs-Base-Transpiler'!printJsOn: aStream	aStream nextPut: $[.	self		do: [ : each |			each printJsOn: aStream ]		separatedBy: [			aStream nextPut: $, ].	aStream nextPut: $].! !!ProtoObject class methodsFor: '*PharoJs-Base-Transpiler'!classToUseForJsConversion	self hasJavascriptPlaceholder ifFalse: [ ^self].	^self javascriptPlaceholder! !!ProtoObject class methodsFor: '*PharoJs-Base-Transpiler'!hasClassMethod: selector	^self classSide includesSelector: selector! !!ProtoObject class methodsFor: '*PharoJs-Base-Transpiler'!hasInstanceMethod: selector	^self instanceSide includesSelector: selector! !!ProtoObject class methodsFor: '*PharoJs-Base-Transpiler'!hasJavascriptPlaceholder	^self hasClassMethod: #javascriptPlaceholder! !!ProtoObject class methodsFor: '*PharoJs-Base-Transpiler'!javascriptPlaceholderInheritance	self hasJavascriptPlaceholder ifTrue: [ ^ self javascriptPlaceholder].	^ self! !!UndefinedObject methodsFor: '*PharoJs-Base-Transpiler'!asJSON	^ #null! !!UndefinedObject methodsFor: '*PharoJs-Base-Transpiler'!isLiteralJavascriptValue	^ true! !!UndefinedObject methodsFor: '*PharoJs-Base-Transpiler'!printJsOn: aStream	aStream nextPutAll: self asJSON! !!Integer methodsFor: '*PharoJs-Base-Transpiler'!isLiteralJavascriptValue	^ true! !!Collection methodsFor: '*PharoJs-Base-Transpiler'!asJsAstBody	^self asArray! !!Boolean methodsFor: '*PharoJs-Base-Transpiler'!isLiteralJavascriptValue	^ true! !!RBLiteralValueNode methodsFor: '*PharoJs-Base-Transpiler'!isLiteralNumberNode	^self value isNumber! !!Float methodsFor: '*PharoJs-Base-Transpiler'!isLiteralJavascriptValue	^ true! !!Message class methodsFor: '*PharoJs-Base-Transpiler'!javascriptInitialize	PjCore messageClass: self! !!Character methodsFor: '*PharoJs-Base-Transpiler'!asJSON	^ self asString asJSON! !!Character methodsFor: '*PharoJs-Base-Transpiler'!isLiteralJavascriptValue	^ true! !!Character methodsFor: '*PharoJs-Base-Transpiler'!printJsOn: jsStream	^self asString printJsOn: jsStream! !!Object methodsFor: '*PharoJs-Base-Transpiler'!asJSON	^ String streamContents: [:s | self printJsOn: s]! !!Object methodsFor: '*PharoJs-Base-Transpiler'!asJsAstUsing: astConverter	^PjUnparsedStringNode string: self asJSON! !!Object methodsFor: '*PharoJs-Base-Transpiler'!convertToJavascriptAstUsing: aPjAstConverter	^ PjLiteralValueNode value: self! !!Object methodsFor: '*PharoJs-Base-Transpiler'!convertToJsUsing: aPjTranspiler	self printJsOn: aPjTranspiler! !!Object methodsFor: '*PharoJs-Base-Transpiler'!isFreeJavascriptValue	^ self isLiteralJavascriptValue! !!Object methodsFor: '*PharoJs-Base-Transpiler'!isLiteralJavascriptValue	^ false! !!Object methodsFor: '*PharoJs-Base-Transpiler'!isPjJavascriptAstNode	^false! !!Object methodsFor: '*PharoJs-Base-Transpiler'!isSimilarTo: anObject	^self = anObject! !!Object methodsFor: '*PharoJs-Base-Transpiler'!printJsOn: aStream	self printOn: aStream! !!PjAstConverter class methodsFor: 'accessing'!jsCodeGeneratorPragmaKeyword	"The argument of the pragma is a selector for class side message that generates javascript code that is used as the body of the method.	The smalltalk code if any is simply ignored."	^#jsGenerator:! !!PjAstConverter class methodsFor: 'accessing'!jsCodePragmaKeyword	"The argument of the pragma provides javascript code that is used as the body of the method.	The smalltalk code if any is simply ignored."	^#javascript:! !!PjAstConverter class methodsFor: 'accessing'!jsLiteralGeneratorPragmaKeyword	"The argument of the pragma is a selector for class side message that generates javascript code that is used as the body of the method.	The smalltalk code if any is simply ignored."	^#jsLiteralGenerator! !!PjAstConverter methodsFor: 'conversions'!addAllConversions: aCollection	messageConverter addAllConversions: aCollection! !!PjAstConverter methodsFor: 'initialize-release'!addAllMessageConversions: conversions	self messageConverter addAllConversions: conversions! !!PjAstConverter methodsFor: 'accessing'!allowReturnsInBlocks	self isReturnLegalInBlocks: true! !!PjAstConverter methodsFor: 'visiting'!astForJsCode: jsCode	^ {(PjUnparsedStringNode		string:			(String lf				join:					((jsCode						regex:							'[^	]*'						matchesCollect: #yourself)						reject: [ :each | each isEmpty or: [ each beginsWith: '//' ] ])))}! !!PjAstConverter methodsFor: 'visiting'!checkFree: aRBVariableNode	^ blockClosureAnalyser ifNotNil: [		blockClosureAnalyser checkFree: aRBVariableNode]! !!PjAstConverter methodsFor: 'visiting'!checkSelfReturn: result	result canPropogateReturns ifFalse: [		blockNestingLevel = 0 ifTrue: [ needSelfReturn := true ]].	^ result! !!PjAstConverter methodsFor: 'accessing'!classForConversion	^ classForConversion! !!PjAstConverter methodsFor: 'accessing'!classForConversion: anObject	classForConversion := anObject! !!PjAstConverter methodsFor: 'visiting'!classForVariable: aRBVariableNode	| methodNode |	methodNode := aRBVariableNode methodNode.	methodNode ifNotNil: [ ^ methodNode methodClass ].	^ aRBVariableNode variable definingClass! !!PjAstConverter methodsFor: 'public'!convertAst: ast withPrimitive: anInteger	methodPrimitive := anInteger.	^self visit: ast! !!PjAstConverter methodsFor: 'public'!convertBlock: aBlockClosure	blockClosureAnalyser := PjBlockClosureAnalyser onBlock: aBlockClosure.	[^ self visit: blockClosureAnalyser sourceNode	] ensure: [blockClosureAnalyser := nil]! !!PjAstConverter methodsFor: 'public'!convertClosedBlock: block	| savedBlockClosureAnalyser |	savedBlockClosureAnalyser := blockClosureAnalyser.	blockClosureAnalyser := PjBlockClosureAnalyser onBlock: block.	[^ blockClosureAnalyser closeAst: (self visit: blockClosureAnalyser sourceNode) with: self	] ensure: [blockClosureAnalyser := savedBlockClosureAnalyser]! !!PjAstConverter methodsFor: 'public'!convertFirstStatementOfBlock: stAst	self reset.	^ self visit: stAst! !!PjAstConverter methodsFor: 'public'!convertValuedBlock: block	| closedBlockAst closedBlockAstArgs|	closedBlockAst := self convertClosedBlock: block.	closedBlockAstArgs := block arguments collect: [: each | each asJsAstUsing: self].	^PjApplyNode func: closedBlockAst args: closedBlockAstArgs! !!PjAstConverter methodsFor: 'visiting'!discoveredGlobalsPool: aClass	self transpiler ifNotNil: [ 	transpiler discoveredGlobalsPool: aClass]! !!PjAstConverter methodsFor: 'visiting'!discoveredMessage: selector		self transpiler ifNil: [ ^ self ].		transpiler discoveredMessage: selector! !!PjAstConverter methodsFor: 'visiting'!discoveredReferenceToClass: aClass	self transpiler ifNil: [ ^self ].	self transpiler discoveredReferenceToClass: aClass! !!PjAstConverter methodsFor: 'visiting'!handleJsCodeGeneratorPragmaInMethodNode: aRBMethodNode	| jsGeneratorPragma generatorSelector jsCode |	jsGeneratorPragma := aRBMethodNode		pragmaNamed: self jsCodeGeneratorPragmaKeyword.	generatorSelector := jsGeneratorPragma arguments first.	jsCode := classForConversion instanceSide		perform: generatorSelector value with: transpiler.	^ self astForJsCode: jsCode! !!PjAstConverter methodsFor: 'visiting'!handleJsCodePragmaInMethodNode: aRBMethodNode	| jsCodePragma jsCode |	jsCodePragma := aRBMethodNode pragmaNamed: self jsCodePragmaKeyword.	jsCode := jsCodePragma arguments first value.	^self astForJsCode: jsCode! !!PjAstConverter methodsFor: 'visiting'!handleJsLiteralGeneratorPragmaInMethodNode: aRBMethodNode 	| jsCode forClass selector result |	forClass := aRBMethodNode scope outerScope.	selector := aRBMethodNode selector.	jsCode := String streamContents: [: s |		s nextPutAll: 'return '.		result := forClass isMeta ifTrue: [				forClass instanceSide perform: selector			] ifFalse: [				forClass basicNew perform: selector			].		result isLiteralJavascriptValue ifFalse: [ PjJavascriptTranspilationError signal: forClass asString,'>>#',selector,' returns a value with no literal Javascript representation'].		result printJsOn: s.	].	^ self astForJsCode: jsCode! !!PjAstConverter methodsFor: 'visiting'!handlePragmaInMethodNode: aRBMethodNode	| body |	(aRBMethodNode hasPragmaNamed: self jsCodePragmaKeyword)		ifTrue: [ ^self handleJsCodePragmaInMethodNode: aRBMethodNode ].	(aRBMethodNode hasPragmaNamed: self jsCodeGeneratorPragmaKeyword)		ifTrue: [ ^self handleJsCodeGeneratorPragmaInMethodNode: aRBMethodNode ].	(aRBMethodNode hasPragmaNamed: self jsLiteralGeneratorPragmaKeyword)		ifTrue: [ 			^self handleJsLiteralGeneratorPragmaInMethodNode: aRBMethodNode ].	pushingReturnClass := nil.	"PjReturnNode"	needSelfReturn := false.	(methodPrimitive ~= 0		and: [ methodPrimitive ~= 256 and: [ aRBMethodNode statements isEmpty ] ])		ifTrue: [ PjJavascriptTranspilationError				signal: 'primitive method with no fallback code: ', aRBMethodNode selector ].	body := self visitAllNodes: aRBMethodNode statements.	(needSelfReturn		and: [ body isEmpty or: [ body expressions last isReturnOrThrow not ] ])		ifTrue: [ body addLast: (PjReturnNode expression: PjSelfNode new) ].	self hasNonLocalReturns		ifTrue: [ body := PjTryNode body: body ].	^ body! !!PjAstConverter methodsFor: 'visiting'!handleReturn: aBlock	| savePushingReturnClass result |	savePushingReturnClass := pushingReturnClass.	pushingReturnClass := nil.	[		result := aBlock value	] ensure: [		pushingReturnClass := savePushingReturnClass.	].	self checkSelfReturn: PjSelfNode new. " flag to add a return, because the block didn't "	^ result! !!PjAstConverter methodsFor: 'accessing'!hasInBlockSelfReferences	^hasInBlockSelfReferences! !!PjAstConverter methodsFor: 'accessing'!hasInBlockSelfReferences: aBoolean	hasInBlockSelfReferences := aBoolean! !!PjAstConverter methodsFor: 'accessing'!hasNonLocalReturns	^ hasNonLocalReturns! !!PjAstConverter methodsFor: 'accessing'!hasNonLocalReturns: anObject	hasNonLocalReturns := anObject! !!PjAstConverter methodsFor: 'accessing'!inExpressionDo: aBlock	| savePushing saveNeedSelfReturn |	^ [		expressionNestingLevel := expressionNestingLevel + 1.		savePushing := pushingReturnClass.		saveNeedSelfReturn := needSelfReturn.		pushingReturnClass := nil.		aBlock value	] ensure: [		needSelfReturn := saveNeedSelfReturn.		pushingReturnClass := savePushing.		expressionNestingLevel := expressionNestingLevel - 1	]! !!PjAstConverter methodsFor: 'initialize-release'!initialize	super initialize.	self messageConverter: self messageConverterClass new.	blockNestingLevel := 0.	loopNestingLevel := 0.	expressionNestingLevel := 0.	self resetExtraTempVariablesToDeclare.	self allowReturnsInBlocks.	extraBindings := Dictionary new.	self reset.! !!PjAstConverter methodsFor: 'testing'!isInBlock	^blockNestingLevel > 0! !!PjAstConverter methodsFor: 'testing'!isInExpression	^ expressionNestingLevel > 0! !!PjAstConverter methodsFor: 'accessing'!isReturnLegalInBlocks	^isReturnLegalInBlocks! !!PjAstConverter methodsFor: 'accessing'!isReturnLegalInBlocks: aBoolean	isReturnLegalInBlocks := aBoolean! !!PjAstConverter methodsFor: 'accessing'!jsCodeGeneratorPragmaKeyword	^self class jsCodeGeneratorPragmaKeyword! !!PjAstConverter methodsFor: 'accessing'!jsCodePragmaKeyword	^self class jsCodePragmaKeyword! !!PjAstConverter methodsFor: 'visiting'!jsLiteralGeneratorPragmaKeyword	^ self class jsLiteralGeneratorPragmaKeyword! !!PjAstConverter methodsFor: 'accessing'!messageConverter	^ messageConverter! !!PjAstConverter methodsFor: 'accessing'!messageConverter: anObject	messageConverter := anObject.	messageConverter astConverter: self.! !!PjAstConverter methodsFor: 'initialize-release'!messageConverterClass	^PjMessageConverter! !!PjAstConverter methodsFor: 'accessing'!needsAllPaths	^ self isInExpression or: [ pushingReturnClass notNil]! !!PjAstConverter methodsFor: 'temp vars'!newTemp	| tempName |	tempName := self tempName.	extraTempVariablesToDeclare add: tempName.	^tempName! !!PjAstConverter methodsFor: 'temp vars'!newTemp: tempName	extraTempVariablesToDeclare add: tempName.	^ tempName! !!PjAstConverter methodsFor: 'non-nil handling'!nonNilIdentifiers	^ nonNilIdentifiers ifNil: [ nonNilIdentifiers := Stack new ]! !!PjAstConverter methodsFor: 'public'!preventNonLocalReturns	self isReturnLegalInBlocks: false! !!PjAstConverter methodsFor: 'conversions'!removeAllConversions: aCollection	messageConverter removeAllConversions: aCollection! !!PjAstConverter methodsFor: 'initialize-release'!removeAllMessageConversions: conversions	self messageConverter removeAllConversions: conversions! !!PjAstConverter methodsFor: 'public'!reset	self hasInBlockSelfReferences: false.	self hasNonLocalReturns: false.	pushingReturnClass := nil.	tempNumber := 0.	tempMaxNumber := 0! !!PjAstConverter methodsFor: 'initialize-release'!resetExtraTempVariablesToDeclare	extraTempVariablesToDeclare := Set new.! !!PjAstConverter methodsFor: 'visiting'!returnNodeWith: someNode	| result |	result := someNode acceptVisitor: self.	pushingReturnClass ifNil: [ ^ self checkSelfReturn: result ].	result canPropogateReturns ifTrue: [ ^ result ].	^ pushingReturnClass expression: result! !!PjAstConverter methodsFor: 'public'!setExtraBindings: aDictionary	extraBindings := aDictionary! !!PjAstConverter methodsFor: 'visiting'!signal: varType ifClosedBlockReferences: id	blockClosureAnalyser		ifNotNil: [ PjJavascriptTranspilationError				signal: 'reference to ', varType, ' in block: ' , id ].! !!PjAstConverter methodsFor: 'accessing'!tempMaxNumber	^ tempMaxNumber! !!PjAstConverter methodsFor: 'accessing'!tempMaxNumber: anObject	tempMaxNumber := anObject! !!PjAstConverter methodsFor: 'temp vars'!tempName	tempNumber := tempNumber + 1.	tempNumber > self tempMaxNumber ifTrue: [ self tempMaxNumber: tempNumber ].	^ PjStringGenerator tempNamePrefix, tempNumber asString! !!PjAstConverter methodsFor: 'temp vars'!tempNameFree: temp	temp ifNil: [ ^ self ].	PjStringGenerator tempNamePrefix, tempNumber asString = temp ifFalse: [^ self].	tempNumber := tempNumber - 1! !!PjAstConverter methodsFor: 'error handling'!transpilationError: aString 	^ PjJavascriptTranspilationError signal: aString,(currentConvertingMethod ifNil: [			''		] ifNotNil: [			' - found in ',currentConvertingMethod methodReference asString		])! !!PjAstConverter methodsFor: 'accessing'!transpiler	^ transpiler! !!PjAstConverter methodsFor: 'accessing'!transpiler: aPjTranspiler	transpiler := aPjTranspiler! !!PjAstConverter methodsFor: 'visiting'!visit: aRBAstNode 	^aRBAstNode acceptVisitor: self! !!PjAstConverter methodsFor: 'visiting'!visitAllNodes: someRBNodes	| expressions lastExpression savedPushing |	someRBNodes ifEmpty: [ ^ self checkSelfReturn: (PjSequenceNode expressions: OrderedCollection new)].	expressions := [			savedPushing := pushingReturnClass.			pushingReturnClass := nil.			someRBNodes allButLast collect: [ :each |				self visit: each ]		] ensure: [			pushingReturnClass := savedPushing		].	lastExpression := self returnNodeWith: someRBNodes last.	expressions addLast: lastExpression.	^ PjSequenceNode expressions: expressions! !!PjAstConverter methodsFor: 'visiting'!visitArgumentVariableNode: aRBVariableNode 	(self checkFree: aRBVariableNode) ifNotNil: [ : result | ^ result].	^PjArgumentNode identifier: aRBVariableNode name! !!PjAstConverter methodsFor: 'visiting'!visitArrayNode: aRBArrayNode	^ self inExpressionDo: [PjArrayNode expressions: (aRBArrayNode statements collect: [: each | self visit: each ])]! !!PjAstConverter methodsFor: 'visiting'!visitAssignmentNode: aRBAssignmentNode 	^PjAssignNode 		target:  (aRBAssignmentNode variable acceptVisitor: self) 		expression: (self inExpressionDo: [aRBAssignmentNode value acceptVisitor: self]).! !!PjAstConverter methodsFor: 'visiting'!visitBlockNode: aRBBlockNode	| expressions savedExpressionNestingLevel savePushing savedExtraTempVariablesToDeclare extaTempVars |	[		savedExtraTempVariablesToDeclare := extraTempVariablesToDeclare.		self resetExtraTempVariablesToDeclare.		blockNestingLevel := blockNestingLevel + 1.		savedExpressionNestingLevel := expressionNestingLevel.		expressionNestingLevel := 0.		savePushing := pushingReturnClass.		pushingReturnClass := PjReturnNode.		expressions := self visitAllNodes: (aRBBlockNode statements ifEmpty: [ OrderedCollection with: RBLiteralValueNode new ])	] ensure: [		extaTempVars := extraTempVariablesToDeclare.		extraTempVariablesToDeclare := savedExtraTempVariablesToDeclare.		pushingReturnClass := savePushing.		expressionNestingLevel := savedExpressionNestingLevel.		blockNestingLevel := blockNestingLevel - 1	].	^ PjBlockNode		parameters: aRBBlockNode argumentNames		locals: aRBBlockNode temporaryNames, extaTempVars asArray		body: expressions! !!PjAstConverter methodsFor: 'visiting'!visitCascadeNode: aRBCascadeNode	| expressions receiver messageNode |	receiver := aRBCascadeNode receiver.	(receiver isSelfVariable or: [ receiver isSuperVariable ]) ifFalse: [ 		receiver := PjTemporaryNode named: self newTemp ].	expressions := aRBCascadeNode messages collect: [ :each | 		               messageNode := RBMessageNode			                              receiver: receiver			                              selector: each selector			                              arguments: each arguments.		               messageNode parent: aRBCascadeNode parent.		               self visitMessageNode: messageNode isNonNil: true ].	receiver = aRBCascadeNode receiver ifFalse: [ 		expressions addFirst:			(PjAssignNode				 target: (self visit: receiver)				 expression: (PjApplyNode						  func: (PjFieldNode								   target: (self visit: aRBCascadeNode receiver)								   selectorNode: nil								   isNonNil: false)						  args: nil)) ].	^ PjSequenceNode expressions: expressions! !!PjAstConverter methodsFor: 'visiting'!visitClassOrPoolVariable: aRBVariableNode id: id	| variableClass |	variableClass := self classForVariable: aRBVariableNode.	(variableClass instanceSide allClassVarNames includes: id)		ifTrue: [ self signal: 'class variable' ifClosedBlockReferences: id.			[ variableClass isNil				or: [ variableClass classVarNames includes: id ] ]				whileFalse: [ variableClass := variableClass superclass ].			^ (PjClassVariableNode identifier: id)						poolReference: variableClass;						myClass: self classForConversion;						yourself				 ].	(variableClass instanceSide sharedPoolOfVarNamedRecursive: id)		ifNotNil: [ :pool | 			pool isJavascriptGlobalsPool				ifTrue: [ self discoveredGlobalsPool: pool.					^ PjGlobalNode identifier: id ].			self signal: 'pool' ifClosedBlockReferences: id.			^ (PjPoolVariableNode identifier: id)					poolReference: pool;					myClass: self classForConversion;					yourself ].	PjJavascriptTranspilationError signal: 'pool or class variable isn''t: ' , id! !!PjAstConverter methodsFor: 'visiting'!visitClassVariableNode: aRBVariableNode 	^self visitGlobalNode: aRBVariableNode! !!PjAstConverter methodsFor: 'visiting'!visitGlobalNode: aRBGlobalNode	| global id |	id := aRBGlobalNode name.	global := Smalltalk		at: id		ifAbsent: [ ^ self visitClassOrPoolVariable: aRBGlobalNode id: id ].	global isClass		ifFalse: [ self signal: 'global' ifClosedBlockReferences: id.			^ PjGlobalNode identifier: id ].	self discoveredReferenceToClass: global.	^ PjClassNode identifier: global nameToUseForJsConversion! !!PjAstConverter methodsFor: 'visiting'!visitGlobalVariableNamed: name	| globalVariable globalVariableNode |	globalVariable := GlobalVariable		                  key: name		                  value: nil.	globalVariableNode := RBVariableNode named: globalVariable key.	globalVariableNode variable: globalVariableNode.	^ self visitGlobalNode: globalVariableNode! !!PjAstConverter methodsFor: 'visiting'!visitGlobalVariableNode: aRBVariableNode 	^self visitGlobalNode: aRBVariableNode.! !!PjAstConverter methodsFor: 'visiting'!visitInlineBlock: aRBProgramNode	| statements  |	aRBProgramNode isBlock ifFalse: [		^ self returnNodeWith: aRBProgramNode ].	statements := (aRBProgramNode statements ifEmpty: [RBLiteralValueNode new]			) copy asOrderedCollection.	aRBProgramNode temporaries do: [ : variable |		extraTempVariablesToDeclare add: variable name.		loopNestingLevel >0 ifTrue: [			statements addFirst: (RBAssignmentNode variable: variable value: RBLiteralValueNode new).	]].	^ (self visitAllNodes: statements) asSimpleNode.! !!PjAstConverter methodsFor: 'visiting'!visitInlineLoopBlock: aRBProgramNode	loopNestingLevel := loopNestingLevel + 1.	[		^ self visitInlineBlock: aRBProgramNode	] ensure: [ loopNestingLevel := loopNestingLevel - 1 ]! !!PjAstConverter methodsFor: 'visiting'!visitInstanceVariableNode: aRBInstanceVariableNode	(self checkFree: aRBInstanceVariableNode) ifNotNil: [ : result | ^ result].	^PjFieldNode target: (self visitSelfNode: nil) selectorNode: (PjInstanceVariableNode identifier: aRBInstanceVariableNode name) isNonNil: true! !!PjAstConverter methodsFor: 'visiting'!visitLiteralArrayNode: aRBLiteralArrayNode 	^ PjArrayNode expressions: (aRBLiteralArrayNode contents collect: [: each | each acceptVisitor: self])! !!PjAstConverter methodsFor: 'visiting'!visitLiteralNode: aRBLiteralValueNode 	^ aRBLiteralValueNode value ifNil: [			PjNilNode new		] ifNotNil: [ : nonNil |			PjLiteralValueNode value: nonNil		]! !!PjAstConverter methodsFor: 'visiting'!visitLiteralValueNode: aRBLiteralValueNode 	^ aRBLiteralValueNode value ifNil: [			PjNilNode new		] ifNotNil: [ : nonNil |			PjLiteralValueNode value: nonNil		]! !!PjAstConverter methodsFor: 'visiting'!visitMessageNode: aRBMessageNode 	^ self visitMessageNode: aRBMessageNode isNonNil: false! !!PjAstConverter methodsFor: 'visiting'!visitMessageNode: aRBMessageNode isNonNil: isNonNil	| target savedPushingReturnClass |	(self messageConverter		convert: aRBMessageNode selector		receiver: aRBMessageNode receiver		args: aRBMessageNode arguments) ifNotNil: [ : ast | ^ast ].	self discoveredMessage: aRBMessageNode selector.	[		savedPushingReturnClass := pushingReturnClass.		pushingReturnClass := nil.		target := self visit: aRBMessageNode receiver.		^PjApplyNode			func: (PjFieldNode				target: target				selectorNode: (PjMessageSelectorNode identifier: aRBMessageNode selector)				isNonNil: (isNonNil or: [target isNonNilNode or: [aRBMessageNode selector beginsWith: PjTranspiler jsNativePrefix]]))			args:  (aRBMessageNode arguments collect: [ : each | self inExpressionDo: [each acceptVisitor: self] ])	] ensure: [		pushingReturnClass := savedPushingReturnClass ]! !!PjAstConverter methodsFor: 'visiting'!visitMethodNode: aRBMethodNode	| body extraTempVars |	[		currentConvertingMethod := aRBMethodNode compiledMethod.		self resetExtraTempVariablesToDeclare.		self reset.		body := self handlePragmaInMethodNode: aRBMethodNode.	] ensure:[		extraTempVars := extraTempVariablesToDeclare.		self resetExtraTempVariablesToDeclare.		currentConvertingMethod := nil.	].	^ (PjMethodNode		parameters: aRBMethodNode argumentNames		locals: aRBMethodNode temporaryNames, extraTempVars asArray		body: body		methodName: aRBMethodNode selector		needsSelf: self hasInBlockSelfReferences		isClassMethod:		(classForConversion				ifNil: [ false ]				ifNotNil: [ classForConversion isClassSide ]))		myClass: classForConversion;		yourself! !!PjAstConverter methodsFor: 'visiting'!visitReturnNode: aRBReturnNode 	| savedPushing |	savedPushing := pushingReturnClass.	(self isInBlock or: [self isInExpression]) ifTrue: [		self isReturnLegalInBlocks ifFalse: [			self error: 'Returns in closed blocks are illegal.' ].		pushingReturnClass := PjNonLocalReturnNode.		self hasNonLocalReturns: true	] ifFalse: [		pushingReturnClass := PjReturnNode].	[^self returnNodeWith: aRBReturnNode value	] ensure: [		pushingReturnClass := savedPushing]! !!PjAstConverter methodsFor: 'visiting'!visitSelfNode: aRBSelfNode 	| inBlock |	blockClosureAnalyser ifNotNil: [		PjJavascriptTranspilationError signal: 'reference to self in block'	].	inBlock := self isInBlock.	inBlock ifTrue: [ self hasInBlockSelfReferences: true ].	^(PjSelfNode inBlock: inBlock) myClass: self classForConversion! !!PjAstConverter methodsFor: 'visiting'!visitSuperNode: aRBSuperNode	| inBlock |	blockClosureAnalyser ifNotNil: [		PjJavascriptTranspilationError signal: 'reference to super in block'	].	inBlock := self isInBlock.	inBlock ifTrue: [ self hasInBlockSelfReferences: true ].	^(PjSuperNode inBlock: inBlock) myClass: self classForConversion! !!PjAstConverter methodsFor: 'visiting'!visitTemporaryNode: aRBTemporaryNode	^self visitTemporaryVariableNode: aRBTemporaryNode! !!PjAstConverter methodsFor: 'visiting'!visitTemporaryVariableNode: aRBTemporaryNode	(self checkFree: aRBTemporaryNode) ifNotNil: [ : result | ^ result].	^PjTempVariableNode identifier: aRBTemporaryNode name! !!PjAstConverter methodsFor: 'visiting'!visitThisContextNode: aRBThisContextNode	^ self transpilationError: 'thisContext not supported'! !!PjAstConverter methodsFor: 'visiting'!visitVariableNode: aRBVariableNode	| id |	id := aRBVariableNode name.	extraBindings at: id ifPresent: [: value |		(value isKindOf: PjProxy) ifTrue: [ ^ PjGlobalNode identifier: id ]].	self transpilationError: 'undefined variable "' , aRBVariableNode name , '"'.! !!PjAstConverter methodsFor: 'non-nil handling'!withNonNil: aPjJavascriptAstNode do: aBlockClosure 	| result |	self nonNilIdentifiers push: aPjJavascriptAstNode.	result := aBlockClosure value.	self nonNilIdentifiers pop.	^ result! !!PjBlockClosureAnalyser class methodsFor: 'instance creation'!onBlock: aBlockClosure	^self new blockForAnalysis: aBlockClosure! !!PjBlockClosureAnalyser methodsFor: 'accessing'!blockForAnalysis	^ blockForAnalysis! !!PjBlockClosureAnalyser methodsFor: 'accessing'!blockForAnalysis: anObject	blockForAnalysis := anObject! !!PjBlockClosureAnalyser methodsFor: 'visiting'!checkFree: aRBVariableNode	| name |	name := aRBVariableNode name.	self externalVariablesDict at: name ifPresent: [ : value |		(value isKindOf: Error) ifTrue: [ value signal ].		value isFreeJavascriptValue ifFalse: [ PjJavascriptTranspilationError signal: 'reference to non-literal value in variable: ', name ].		self register: name with: value.		^ PjTempVariableNode identifier: name	].	^ nil! !!PjBlockClosureAnalyser methodsFor: 'visiting'!closeAst: aPjJavascriptAstNode with: aPjAstConverter	freeVariables isEmpty		ifTrue: [ ^ aPjJavascriptAstNode ].	^ PjApplyNode		func:			(PjFunctionNode				parameters: freeVariables keys				locals: #()				body: {(PjReturnNode expression: aPjJavascriptAstNode)})		args:			(freeVariables values				collect:					[ :each | each convertToJavascriptAstUsing: aPjAstConverter ])! !!PjBlockClosureAnalyser methodsFor: 'public'!externalVariablesDict	^ externalVariables ifNil: [ externalVariables := blockForAnalysis externalVariablesDict ]! !!PjBlockClosureAnalyser methodsFor: 'initialize-release'!initialize	freeVariables := OrderedDictionary new! !!PjBlockClosureAnalyser methodsFor: 'accessing'!isClosed	^self blockForAnalysis isClosed! !!PjBlockClosureAnalyser methodsFor: 'initialize-release'!register: aString with: anObject	freeVariables at: aString put: anObject! !!PjBlockClosureAnalyser methodsFor: 'accessing'!sourceNode	^self blockForAnalysis sourceNode.! !!PjCore class methodsFor: 'initalize'!emptyJavascriptObject	"Object.create(null) creates an even emptier JS object, but it isn't an Object (i.e. has no methods)."	<javascript: '		return {}	'>! !!PjCore class methodsFor: 'doesNotUnderstand support'!handleDNU: aMessage for: anObject	" this could be a smalltalk object or a native JS object "	| selector |	selector := (aMessage selector js_split: ':') js_at: 0.	^ self		installDnuArgs: aMessage arguments		selector: selector		js: (self makePharoJsSelector: aMessage selector)		for: anObject		else: [ self				error:					'Message not understood: ' , anObject className , '>>#'						, aMessage selector ]! !!PjCore class methodsFor: 'reflection support'!initInheritanceAndInstantiationLinks	Object js_setPrototypeOf: Object to: (theClassClass js_at: #prototype).	Object js_setPrototypeOf: theClassClass to: PjFunction! !!PjCore class methodsFor: 'nil support'!initNilInJs	" specifically install in the global space, rather than in the Smalltalk global space "	global js_at: self nilTestFunctionName put: (self nilIfUndefined)! !!PjCore class methodsFor: 'throw support'!initThrowInJs	" specifically install in the global space, rather than in the Smalltalk global space "	global js_at: self throwFunctionName put: (self throwFunction)! !!PjCore class methodsFor: 'initalize'!initializeCore	selectorCache := self emptyJavascriptObject.	self initNilInJs.	self initThrowInJs.	self initInheritanceAndInstantiationLinks.	self messageClass: self.	self metaclassClass: self.! !!PjCore class methodsFor: 'doesNotUnderstand support'!installDnuArgs: args selector: selector js: jsSelector for: anObject else: aBlock	" this could be a smalltalk object or a native JS object "	| type func functionName |	(type := anObject js_at: selector) ifNotNil: [		(self isFunction: type) ifTrue: [			functionName := type js_at: #name.			'' = functionName ifTrue: [				type := 2			] ifFalse: [				functionName asCharacter = functionName asCharacter capitalized "We rely on the JS convention that constructors are capiltalized"					ifTrue: [type := 0 " this is a constructor "]					ifFalse: [ type := 2 ]			]		] ifFalse: [			type := args js_at: #length	]].	2 > type ifTrue: [		0 = type ifTrue: [			func := self makeGetter: selector		] ifFalse: [			func := self makeSetter: selector.		].		(Object js_defineProperty: (anObject js_at:'__proto__')				field: jsSelector				properties: (self propertySet: func)).		^ func js_apply: anObject args: args 	] ifFalse: [		type := anObject.		[ nil = type ] whileFalse: [			((type js_hasOwnProperty: selector) and: [				'function'  = (type js_at: selector) typeof ]) ifTrue: [				func := type js_at: selector.				(Object js_defineProperty: type						field: jsSelector						properties: (self propertySet: func)).				^ func js_apply: anObject args: args 			].			type := type instVarNamed:'__proto__'	]].	^ aBlock value! !!PjCore class methodsFor: 'nil support'!isBrowserPlatform	^ (self at: #navigator) isNotNil! !!PjCore class methodsFor: 'nil support'!isDomPlatform	^ (self at: #document) isNotNil! !!PjCore class methodsFor: 'doesNotUnderstand support'!isFunction: type	<javascript: 'return "function" == typeof type'>! !!PjCore class methodsFor: 'nil support'!isNodePlatform	^ (self at: #navigator) isNil! !!PjCore class methodsFor: 'accessing'!isPharoJsSelector: aSelector	"Answer true if the argument has been generated by PharoJS"	| prefixSize |	prefixSize := self pharoJsSelectorPrefix size.	aSelector size <= prefixSize ifTrue: [ ^false ].	^ (aSelector js_substring: 0 to: prefixSize) = self pharoJsSelectorPrefix! !!PjCore class methodsFor: 'accessing'!javascriptName	<pharoJsSkip>	^ #Smalltalk! !!PjCore class methodsFor: 'reflection support'!keys: anObject	<jsGenerator: #keys_jsGenerator:>! !!PjCore class methodsFor: 'reflection support'!keys_jsGenerator: transpiler	<pharoJsSkip>	^'	var result={};	for (var i in anObject) { if(typeof anObject[i]!!="function" && anObject[i]!!=null && anObject[i].', transpiler pharoJsSelectorPrefix, 'proxyResponse) result[i]=anObject[i].', transpiler pharoJsSelectorPrefix, 'proxyResponse()}	return {', transpiler pharoJsSelectorPrefix, 'proxyResponse:function(){return {keys:result}}}	'! !!PjCore class methodsFor: 'logging'!log: message	console js_log: message! !!PjCore class methodsFor: 'doesNotUnderstand support'!makeDNU: aSelector	<jsGenerator: #makeDNU_jsGenerator:>! !!PjCore class methodsFor: 'doesNotUnderstand support'!makeDNU_jsGenerator: transpiler	<pharoJsSkip>	|prefix|	prefix := transpiler pharoJsSelectorPrefix.	^'var pjCore=this,ss=this.', prefix, 'makeSmalltalkSelector_(aSelector);	switch (ss.split(":").length) {		case 1: return function __DNU(){			return this.', prefix, 'doesNotUnderstand_(pjCore.', prefix, 'selector_arguments_(ss,[]))};		case 2: return function __DNU(arg1) {			return this.', prefix, 'doesNotUnderstand_(pjCore.', prefix, 'selector_arguments_(ss,[arg1]))};		case 3: return function __DNU(arg1,arg2) {			return this.', prefix, 'doesNotUnderstand_(pjCore.', prefix, 'selector_arguments_(ss,[arg1,arg2]))};		default: return function __DNU() {			var args=new Array(arguments.length);			for(var i=0;i<arguments.length;++i) args[i]=arguments[i]			return this.', prefix, 'doesNotUnderstand_(pjCore.', prefix, 'selector_arguments_(ss,args))};	}'! !!PjCore class methodsFor: 'doesNotUnderstand support'!makeGetter: selector	<javascript:	'return function Getter(){return this[selector]}'>! !!PjCore class methodsFor: 'accessing'!makePharoJsSelector: aSelector	| result |	(self isPharoJsSelector: aSelector)		ifTrue: [ ^ aSelector ].	(selectorCache js_hasOwnProperty: aSelector)		ifTrue: [ ^ selectorCache js_at: aSelector ].	aSelector		ifNotNil: [ :sel | 			(sel isLetter or: [ (aSelector js_at: 0) = '$' ])				ifTrue: [ result := sel js_split: ':' ]				ifFalse: [ result := #().					1 to: sel size do:						[ :idx | result js_push: (sel js_charCodeAt: idx - 1) js_toString ].					result js_push: nil ].			result := self pharoJsSelectorPrefix , (result js_join: '_') ].	(selectorCache js_at: result)		ifNil: [ selectorCache js_at: result put: aSelector ].	(selectorCache js_at: aSelector)		ifNil: [ selectorCache js_at: aSelector put: result ].	^ result! !!PjCore class methodsFor: 'doesNotUnderstand support'!makeSetter: selector	<javascript:	'return function Setter(value){return this[selector]=value}'>! !!PjCore class methodsFor: 'accessing'!makeSmalltalkSelector: aSelector	| result |	(self isPharoJsSelector: aSelector) ifFalse: [ ^ aSelector ].	(selectorCache js_hasOwnProperty: aSelector) ifTrue: [		^ selectorCache js_at: aSelector ].	result := aSelector js_split: '_'.	result js_shift.	((result js_at: 0) js_at: 0) > '9' ifTrue: [ ^ result js_join: ':' ].	result js_pop.	0 to: (result js_at: #length)-1 do: [ :index |		result js_at: index put: (Character value: (result js_at: index)) ].	result := result js_join: ''.	(selectorCache js_at: result) ifNil: [ selectorCache js_at: result put: aSelector ].	(selectorCache js_at: aSelector) ifNil: [ selectorCache js_at: aSelector put: result ].	^ result! !!PjCore class methodsFor: 'doesNotUnderstand support'!messageClass: anObject	messageClass := anObject! !!PjCore class methodsFor: 'reflection support'!metaclassClass: anObject	metaclassClass := anObject! !!PjCore class methodsFor: 'reflection support'!metaclassOf: aClass	<jsGenerator: #metaclassOf_jsGenerator:>! !!PjCore class methodsFor: 'reflection support'!metaclassOf_jsGenerator: transpiler	<pharoJsSkip>	^'if(this.metaclassClass!!==this) return this.metaclassClass.', transpiler pharoJsSelectorPrefix, 'metaclassOf_(aClass);	var theMetaClass={ prototype: aClass.__proto__,__proto__:this.theClassClass.prototype,		', transpiler pharoJsSelectorPrefix, 'name: function(){return aClass.', transpiler pharoJsSelectorPrefix, 'name()+" class"},		', transpiler pharoJsSelectorPrefix, 'theNonMetaClass: function(){return aClass},		', transpiler pharoJsSelectorPrefix, 'theMetaClass: function(){return theMetaClass},		};	return theMetaClass	'! !!PjCore class methodsFor: 'nil support'!nilIfUndefined	"In case PjUndefinedObject is not created yet, use a placeholder object, just for declaring."	<javascript: 'global.PjUndefinedObject |= {};	return function(arg){if(arg == undefined){		return PjUndefinedObject.uniqueInstance;	}	return arg}'>	! !!PjCore class methodsFor: 'nil support'!nilTestFunctionName	^ '$asNil$'! !!PjCore class methodsFor: 'accessing'!pharoJsSelectorPrefix	<jsGenerator: #pharoJsSelectorPrefix_jsGenerator:>	^ self error: 'Only for Javascript side'! !!PjCore class methodsFor: 'accessing'!pharoJsSelectorPrefix_jsGenerator: transpiler	<pharoJsSkip>	^ 'return ',transpiler pharoJsSelectorPrefix asJSON! !!PjCore class methodsFor: 'doesNotUnderstand support'!propertySet: func	<javascript: 'return {		enumerable: false,		configurable: true,		writable: true,		value: func}'>	! !!PjCore class methodsFor: 'doesNotUnderstand support'!registerDnu: aSelector	| selector props |	selector := self makePharoJsSelector: aSelector.	((Object js_at: #prototype) js_hasOwnProperty: selector) ifFalse: [		props := self makeDNU: aSelector.		Object			js_defineProperty: (Object js_at:#prototype)			field: selector			properties: (self propertySet: props)	].	^ selector! !!PjCore class methodsFor: 'doesNotUnderstand support'!registerDnuForAll: anArray	anArray js_forEach: [ : each | self registerDnu: each ]! !!PjCore class methodsFor: 'importing'!require: moduleName	<jsAlias: #require>	<javascript: 'return require(moduleName);'>	^ global require: moduleName! !!PjCore class methodsFor: 'doesNotUnderstand support'!selector: selector arguments: args	<jsGenerator: #selector_arguments_jsGenerator:>! !!PjCore class methodsFor: 'doesNotUnderstand support'!selector_arguments_jsGenerator: transpiler	<pharoJsSkip>	^'if(this.messageClass!!==this)		return this.messageClass.', transpiler pharoJsSelectorPrefix, 'selector_arguments_(selector,arguments);	return {			selector: selector,			', transpiler pharoJsSelectorPrefix, 'selector: function(){return this.selector},			arguments: args,			', transpiler pharoJsSelectorPrefix, 'arguments: function(){return this.arguments}		}'! !!PjCore class methodsFor: 'throw support'!throwFunction	<javascript: 'return function(arg){throw arg}'>! !!PjCore class methodsFor: 'throw support'!throwFunctionName	^ '$throw$'! !!PjApplyNode class methodsFor: 'creating'!func: func args: args	^ self new func: func; args: args; yourself! !!PjApplyNode class methodsFor: 'creating'!receiver: receiverNode selector: aSymbol args: args	^self 		func: (PjFieldNode target: receiverNode selectorNode: (PjMessageSelectorNode identifier: aSymbol asSymbol) isNonNil: receiverNode isNonNilNode)		args: args! !!PjApplyNode methodsFor: 'visiting'!acceptVisitor: aPjASTVisitor	^ aPjASTVisitor visitApplyNode: self! !!PjApplyNode methodsFor: 'accessing'!args	^ args! !!PjApplyNode methodsFor: 'accessing'!args: anObject	args := anObject! !!PjApplyNode methodsFor: 'accessing'!func	^ func! !!PjApplyNode methodsFor: 'accessing'!func: anObject	func := anObject! !!PjApplyNode methodsFor: 'comparing'!valuesToCompareForSimilarity	^{self func}, self args! !!PjArrayNode class methodsFor: 'creating'!expressions: sequence	^ self new expressions: sequence asArray; yourself! !!PjArrayNode methodsFor: 'visiting'!acceptVisitor: aPjASTVisitor	^ aPjASTVisitor visitArrayNode: self! !!PjArrayNode methodsFor: 'accessing'!expressions	^ expressions! !!PjArrayNode methodsFor: 'accessing'!expressions: anObject	expressions := anObject! !!PjArrayNode methodsFor: 'testing'!isNonNilNode	^ true! !!PjArrayNode methodsFor: 'accessing'!valuesToCompareForSimilarity	^self expressions! !!PjAssignNode class methodsFor: 'creating'!target: target expression: expression	^ self new target: target; expression: expression; yourself! !!PjAssignNode methodsFor: 'visiting'!acceptVisitor: aPjASTVisitor	^ aPjASTVisitor visitAssignNode: self! !!PjAssignNode methodsFor: 'accessing'!expression	^ expression! !!PjAssignNode methodsFor: 'accessing'!expression: anObject	expression := anObject! !!PjAssignNode methodsFor: 'accessing'!target	^ target! !!PjAssignNode methodsFor: 'accessing'!target: anObject	target := anObject! !!PjBinaryNode class methodsFor: 'creating'!operator: operator left: left right: right	^ self new operator: operator; left: left; right: right; yourself! !!PjBinaryNode methodsFor: 'visiting'!acceptVisitor: aPjASTVisitor	^ aPjASTVisitor visitBinaryNode: self! !!PjBinaryNode methodsFor: 'rewriting'!copyWith: newOperator	^ self class operator: newOperator left: left right: right! !!PjBinaryNode methodsFor: 'testing'!isComparison	^ #(== !!= === !!== <= >= < > ) includes: operator! !!PjBinaryNode methodsFor: 'accessing'!left	^ left! !!PjBinaryNode methodsFor: 'accessing'!left: anObject	left := anObject! !!PjBinaryNode methodsFor: 'rewriting'!not	operator = #== ifTrue: [  ^ self copyWith: #!!= ].	operator = #!!= ifTrue: [  ^ self copyWith: #== ].	operator = #=== ifTrue: [  ^ self copyWith: #!!== ].	operator = #!!== ifTrue: [  ^ self copyWith: #=== ].	(#( <= >= < > ) includes: operator) ifTrue: [ ^ self class operator: operator left: right right: left].	^ super not! !!PjBinaryNode methodsFor: 'accessing'!operator	^ operator! !!PjBinaryNode methodsFor: 'accessing'!operator: anObject	operator := anObject! !!PjBinaryNode methodsFor: 'accessing'!right	^ right! !!PjBinaryNode methodsFor: 'accessing'!right: anObject	right := anObject! !!PjBinaryNode methodsFor: 'comparing'!valuesToCompareForEquality	^{self operator. self left. self right}! !!PjFieldNode class methodsFor: 'creating'!target: target selectorNode: selectorNode isNonNil: isNonNil	^ self new target: target; selectorNode: selectorNode; isNonNil: isNonNil; yourself! !!PjFieldNode methodsFor: 'visiting'!acceptVisitor: aPjASTVisitor	^ aPjASTVisitor visitFieldNode: self! !!PjFieldNode methodsFor: 'accessing'!isNonNil	^ isNonNil! !!PjFieldNode methodsFor: 'accessing'!isNonNil: anObject	isNonNil := anObject! !!PjFieldNode methodsFor: 'testing'!isNonlocalClassOrPoolVariableReference: aClass	^ selectorNode isNonlocalClassOrPoolVariableReference: aClass! !!PjFieldNode methodsFor: 'testing'!isSuperSend	^ target isSuperSend! !!PjFieldNode methodsFor: 'accessing'!selectorNode	^ selectorNode! !!PjFieldNode methodsFor: 'accessing'!selectorNode: anObject	selectorNode := anObject! !!PjFieldNode methodsFor: 'accessing'!target	^ target! !!PjFieldNode methodsFor: 'accessing'!target: anObject	target := anObject! !!PjBlockNode methodsFor: 'visiting'!acceptVisitor: aPjASTVisitor	^ aPjASTVisitor visitBlockNode: self! !!PjFunctionNode class methodsFor: 'creating'!parameters: parameters locals: locals body: body	^ self new parameters: parameters asArray; locals: locals asArray; body: body asJsAstBody; yourself! !!PjFunctionNode methodsFor: 'visiting'!acceptVisitor: aPjASTVisitor	^ aPjASTVisitor visitFunctionNode: self! !!PjFunctionNode methodsFor: 'accessing'!addLocal: anObject	locals := locals asOrderedCollection.	^ locals add: anObject! !!PjFunctionNode methodsFor: 'accessing'!body	^ body! !!PjFunctionNode methodsFor: 'accessing'!body: anObject	body := anObject! !!PjFunctionNode methodsFor: 'testing'!isNonNilNode	^ true! !!PjFunctionNode methodsFor: 'accessing'!locals	^ locals! !!PjFunctionNode methodsFor: 'accessing'!locals: anObject	locals := anObject! !!PjFunctionNode methodsFor: 'testing'!needsSelf	^ false! !!PjFunctionNode methodsFor: 'accessing'!parameters	^ parameters! !!PjFunctionNode methodsFor: 'accessing'!parameters: anObject	parameters := anObject! !!PjMethodNode class methodsFor: 'creating'!methodName: methodName body: body	^ self parameters: #() locals: #() body: body methodName: methodName needsSelf: false isClassMethod: false! !!PjMethodNode class methodsFor: 'creating'!parameters: parameters locals: locals body: body methodName: methodName needsSelf: needsSelf isClassMethod: isClassMethod	^ (self parameters: parameters locals: locals body: body) needsSelf: needsSelf; methodName: methodName; isClassMethod: isClassMethod; yourself! !!PjMethodNode methodsFor: 'visiting'!acceptVisitor: aPjASTVisitor	^ aPjASTVisitor visitMethodNode: self! !!PjMethodNode methodsFor: 'accessing'!isClassMethod	^ isClassMethod! !!PjMethodNode methodsFor: 'accessing'!isClassMethod: anObject	isClassMethod := anObject! !!PjMethodNode methodsFor: 'accessing'!methodName	^ methodName! !!PjMethodNode methodsFor: 'accessing'!methodName: anObject	methodName := anObject! !!PjMethodNode methodsFor: 'accessing'!needsSelf	^ needsSelf! !!PjMethodNode methodsFor: 'accessing'!needsSelf: anObject	needsSelf := anObject! !!PjJavascriptAstNode class methodsFor: 'creating'!myClass: anInteger	^ self new myClass: anInteger;yourself! !!PjJavascriptAstNode methodsFor: 'visiting'!acceptVisitor: aPjASTVisitor	self subclassResponsibility! !!PjJavascriptAstNode methodsFor: 'converting'!asJsAstBody	^{self}! !!PjJavascriptAstNode methodsFor: 'accessing'!asSimpleNode	^ self! !!PjJavascriptAstNode methodsFor: 'testing'!canPropogateReturns	^ false! !!PjJavascriptAstNode methodsFor: 'accessing'!expressions	^ { self }! !!PjJavascriptAstNode methodsFor: 'testing'!isComparison	^ false! !!PjJavascriptAstNode methodsFor: 'testing'!isLiteralNode	^ false! !!PjJavascriptAstNode methodsFor: 'testing'!isLiteralSelector	^ false! !!PjJavascriptAstNode methodsFor: 'testing'!isNonNil	^ self isNonNilNode! !!PjJavascriptAstNode methodsFor: 'testing'!isNonNilNode	^ false! !!PjJavascriptAstNode methodsFor: 'testing'!isNonlocalClassOrPoolVariableReference: aClass	^ false! !!PjJavascriptAstNode methodsFor: 'testing'!isNot	^ false! !!PjJavascriptAstNode methodsFor: 'testing'!isPjJavascriptAstNode	^true! !!PjJavascriptAstNode methodsFor: 'testing'!isReturnOrThrow	^false! !!PjJavascriptAstNode methodsFor: 'testing'!isSelfNode	^ false! !!PjJavascriptAstNode methodsFor: 'comparing'!isSimilarTo: anObject 	| myValues otherValues |	self species = anObject species ifFalse: [^false].	myValues := self valuesToCompareForSimilarity.	otherValues := anObject valuesToCompareForSimilarity.	myValues size = otherValues size ifFalse: [ ^false ].	myValues		with: otherValues		do: [ : myValue : otherValue | 			(myValue isSimilarTo: otherValue) ifFalse: [^false]].	^true.! !!PjJavascriptAstNode methodsFor: 'testing'!isSuperSend	^ false! !!PjJavascriptAstNode methodsFor: 'accessing'!myClass	^ myClass! !!PjJavascriptAstNode methodsFor: 'accessing'!myClass: anObject	myClass := anObject! !!PjJavascriptAstNode methodsFor: 'converting'!not	^ PjUnaryNode operator: #!! expression: self! !!PjJavascriptAstNode methodsFor: 'printing'!printOn: aStream	| instVars needParens |	instVars := self class allInstVarNames copyWithoutAll: #(myClass inBlock).	needParens := instVars size > 0 and: [ aStream size >0 ].	aStream		nextPutAll: (needParens ifTrue: [ '(' ] ifFalse: [ '' ]);		nextPutAll: self className.	instVars ifEmpty: [ aStream nextPutAll: ' new' ].	instVars do: [: name | | value |		aStream space;nextPutAll: name;nextPut: $:.		value := self instVarNamed: name.		(value isCollection and: [value isString not]) ifTrue: [			aStream nextPut: ${.			value do: [: each |					aStream nextPutAll: each asString				] separatedBy: [ aStream nextPut: $. ].			aStream nextPut: $}.		] ifFalse: [			value printOn: aStream]	].	aStream		nextPutAll: (needParens ifTrue: [ ')' ] ifFalse: [ '' ])! !!PjJavascriptAstNode methodsFor: 'comparing'!valuesToCompareForSimilarity	^ self valuesToCompareForEquality select: [ : each | each isPjJavascriptAstNode ]! !!PjLiteralNode methodsFor: 'visiting'!acceptVisitor: aPjASTVisitor	^ aPjASTVisitor visitLiteralNode: self! !!PjLiteralNode methodsFor: 'testing'!isLiteralNode	^ true! !!PjLiteralNode methodsFor: 'testing'!isNonArray	^ true! !!PjLiteralNode methodsFor: 'testing'!isNonNilNode	^ true! !!PjLiteralValueNode class methodsFor: 'creating'!value: value	^ self new value: value; yourself! !!PjLiteralValueNode methodsFor: 'visiting'!acceptVisitor: aPjASTVisitor	^ aPjASTVisitor visitLiteralValueNode: self! !!PjLiteralValueNode methodsFor: 'testing'!isNonArray	(myClass inheritsFrom: String) ifTrue: [ ^ true ].	^ (myClass inheritsFrom: Collection) not! !!PjLiteralValueNode methodsFor: 'accessing'!value	^ value! !!PjLiteralValueNode methodsFor: 'accessing'!value: anObject	value := anObject.	myClass := anObject class! !!PjNilNode methodsFor: 'visiting'!acceptVisitor: aPjASTVisitor	^ aPjASTVisitor visitNilNode: self! !!PjNilNode methodsFor: 'testing'!isNonNilNode	^ false! !!PjMessageSelectorNode class methodsFor: 'creating'!identifier: identifier	^ self new identifier: identifier; yourself! !!PjMessageSelectorNode methodsFor: 'visiting'!acceptVisitor: aPjASTVisitor	^ aPjASTVisitor visitMessageSelectorNode: self! !!PjMessageSelectorNode methodsFor: 'accessing'!identifier	^ identifier! !!PjMessageSelectorNode methodsFor: 'accessing'!identifier: anObject	identifier := anObject! !!PjMessageSelectorNode methodsFor: 'testing'!isLiteralSelector	^ true! !!PjMessageSelectorNode methodsFor: 'testing'!valuesToCompareForSimilarity	^self identifier! !!PjObjectNode class methodsFor: 'creating'!dictionary: dictionary	^ self new dictionary: dictionary; yourself! !!PjObjectNode methodsFor: 'visiting'!acceptVisitor: aPjASTVisitor	^ aPjASTVisitor visitObjectNode: self! !!PjObjectNode methodsFor: 'accessing'!dictionary	^ dictionary! !!PjObjectNode methodsFor: 'accessing'!dictionary: anObject	dictionary := anObject! !!PjObjectNode methodsFor: 'testing'!isNonArray	^ true! !!PjObjectNode methodsFor: 'testing'!isNonNilNode	^ true! !!PjNonLocalReturnNode methodsFor: 'visiting'!acceptVisitor: aPjASTVisitor	^ aPjASTVisitor visitNonLocalReturnNode: self! !!PjReturnNode class methodsFor: 'creating'!expression: expression	^ self new expression: expression; yourself! !!PjReturnNode methodsFor: 'visiting'!acceptVisitor: aPjASTVisitor	^ aPjASTVisitor visitReturnNode: self! !!PjReturnNode methodsFor: 'testing'!canPropogateReturns	^ true! !!PjReturnNode methodsFor: 'accessing'!expression	^ expression! !!PjReturnNode methodsFor: 'accessing'!expression: anObject	expression := anObject! !!PjReturnNode methodsFor: 'testing'!isReturnOrThrow	^true! !!PjSelfNode class methodsFor: 'creating'!inBlock: inBlock	^ self new inBlock: inBlock; yourself! !!PjSelfNode methodsFor: 'visiting'!acceptVisitor: aPjASTVisitor	^ aPjASTVisitor visitSelfNode: self! !!PjSelfNode methodsFor: 'accessing'!inBlock	^ inBlock! !!PjSelfNode methodsFor: 'accessing'!inBlock: anObject	inBlock := anObject! !!PjSelfNode methodsFor: 'initializing'!initialize	inBlock := false! !!PjSelfNode methodsFor: 'testing'!isNonArray	(myClass inheritsFrom: String) ifTrue: [ ^ true ].	^ (myClass inheritsFrom: Collection) not! !!PjSelfNode methodsFor: 'testing'!isNonNilNode	^ true! !!PjSelfNode methodsFor: 'testing'!isSelfNode	^ true! !!PjSuperNode methodsFor: 'visiting'!acceptVisitor: aPjASTVisitor	^ aPjASTVisitor visitSuperNode: self! !!PjSuperNode methodsFor: 'testing'!isSuperSend	^ true! !!PjSequenceNode class methodsFor: 'creating'!expressions: expressions	^ self new expressions: expressions asArray; yourself! !!PjSequenceNode methodsFor: 'visiting'!acceptVisitor: aPjASTVisitor	^ aPjASTVisitor visitSequenceNode: self! !!PjSequenceNode methodsFor: 'adding'!addLast: astNode	expressions := expressions, {astNode}! !!PjSequenceNode methodsFor: 'converting'!asJsAstBody	^ self expressions asArray! !!PjSequenceNode methodsFor: 'accessing'!asSimpleNode	expressions size = 1 ifTrue: [ ^ expressions first asSimpleNode ].	^ self! !!PjSequenceNode methodsFor: 'testing'!canPropogateReturns	^ expressions notEmpty and: [ expressions last canPropogateReturns ]! !!PjSequenceNode methodsFor: 'accessing'!expressions	^ expressions! !!PjSequenceNode methodsFor: 'accessing'!expressions: anObject	expressions := anObject! !!PjSequenceNode methodsFor: 'testing'!isEmpty	^ self expressions isEmptyOrNil! !!PjSequenceNode methodsFor: 'testing'!isNot	^ expressions notEmpty and: [ expressions last isNot ]! !!PjSequenceNode methodsFor: 'converting'!not	^ self class expressions: self expressions allButLast, {self expressions last not}! !!PjTryNode class methodsFor: 'creating'!body: body	^ self new body: body; yourself! !!PjTryNode methodsFor: 'visiting'!acceptVisitor: aPjASTVisitor	^ aPjASTVisitor visitTryNode: self! !!PjTryNode methodsFor: 'accessing'!body	^ body! !!PjTryNode methodsFor: 'accessing'!body: anObject	body := anObject asJsAstBody! !!PjUnaryNode class methodsFor: 'creating'!operator: operator expression: expression	^ self new operator: operator; expression: expression; yourself! !!PjUnaryNode methodsFor: 'visiting'!acceptVisitor: aPjASTVisitor	^ aPjASTVisitor visitUnaryNode: self! !!PjUnaryNode methodsFor: 'accessing'!expression	^ expression! !!PjUnaryNode methodsFor: 'accessing'!expression: anObject	expression := anObject! !!PjUnaryNode methodsFor: 'testing'!isNot	^ operator = #!!! !!PjUnaryNode methodsFor: 'rewriting'!not	operator = #!! ifTrue: [  ^ expression ].	^ super not! !!PjUnaryNode methodsFor: 'accessing'!operator	^ operator! !!PjUnaryNode methodsFor: 'accessing'!operator: anObject	operator := anObject! !!PjUnparsedStringNode class methodsFor: 'creating'!string: string	^ self new string: string; yourself! !!PjUnparsedStringNode methodsFor: 'visiting'!acceptVisitor: aPjASTVisitor	^ aPjASTVisitor visitUnparsedStringNode: self! !!PjUnparsedStringNode methodsFor: 'converting'!asJsAstUsing: astConverter	^ self! !!PjUnparsedStringNode methodsFor: 'accessing'!string	^ string! !!PjUnparsedStringNode methodsFor: 'accessing'!string: anObject	string := anObject! !!PjArgumentNode methodsFor: 'visiting'!acceptVisitor: aPjASTVisitor	^ aPjASTVisitor visitArgumentNode: self! !!PjClassNode methodsFor: 'visiting'!acceptVisitor: aPjASTVisitor	^ aPjASTVisitor visitClassNode: self! !!PjClassNode methodsFor: 'testing'!isNonArray	^ true! !!PjClassNode methodsFor: 'testing'!isNonNilNode	^ true! !!PjClassVariableNode methodsFor: 'visiting'!acceptVisitor: aPjASTVisitor	^ aPjASTVisitor visitClassVariableNode: self! !!PjClassVariableNode methodsFor: 'testing'!isLiteralSelector	^ true! !!PjClassVariableNode methodsFor: 'testing'!isNonlocalClassOrPoolVariableReference: aClass	myClass ifNil: [ ^ true ].	^ aClass ~= myClass classSide! !!PjClassVariableNode methodsFor: 'accessing'!poolReference	^ poolReference! !!PjClassVariableNode methodsFor: 'accessing'!poolReference: aClass 	poolReference := aClass instanceSide! !!PjClassVariableNode methodsFor: 'converting'!poolReferenceWith: aPjTranspiler 	^ aPjTranspiler poolReference: poolReference for: myClass! !!PjPoolVariableNode methodsFor: 'visiting'!acceptVisitor: aPjASTVisitor	^ aPjASTVisitor visitPoolVariableNode: self! !!PjPoolVariableNode methodsFor: 'testing'!isNonlocalClassOrPoolVariableReference: aClass	^ true! !!PjGlobalNode methodsFor: 'visiting'!acceptVisitor: aPjASTVisitor	^ aPjASTVisitor visitGlobalNode: self! !!PjInstanceVariableNode methodsFor: 'visiting'!acceptVisitor: aPjASTVisitor	^ aPjASTVisitor visitInstanceVariableNode: self! !!PjInstanceVariableNode methodsFor: 'testing'!isLiteralSelector	^ true! !!PjTempVariableNode methodsFor: 'visiting'!acceptVisitor: aPjASTVisitor	^ aPjASTVisitor visitTempVariableNode: self! !!PjVariableNode class methodsFor: 'creating'!identifier: identifier	^ self new identifier: identifier; yourself! !!PjVariableNode methodsFor: 'visiting'!acceptVisitor: aPjASTVisitor	^ aPjASTVisitor visitVariableNode: self! !!PjVariableNode methodsFor: 'accessing'!identifier	^ identifier! !!PjVariableNode methodsFor: 'accessing'!identifier: anObject	identifier := anObject! !!PjVariableNode methodsFor: 'testing'!valuesToCompareForSimilarity	^self identifier! !!PjMessageConverter methodsFor: 'add/remove'!addAllConversions: aCollection	aCollection do: [ : aPjOptimization |		self addConversion: aPjOptimization	]! !!PjMessageConverter methodsFor: 'add/remove'!addConversion: aConversion	aConversion isClass		ifTrue: [ ^ self addConversion: aConversion new ].	(self conversionsAt: aConversion selector) add: aConversion.	aConversion messageConverter: self.! !!PjMessageConverter methodsFor: 'accessing'!astConverter	^ astConverter! !!PjMessageConverter methodsFor: 'accessing'!astConverter: anObject	astConverter := anObject! !!PjMessageConverter methodsFor: 'add/remove'!conversionsAt: selector	^ conversions		at: selector		ifAbsentPut: [ SortedCollection sortBlock: [ :l :r | l order <= r order ] ]! !!PjMessageConverter methodsFor: 'converting'!convert: selector receiver: receiverAstNode args: args	receiverAstNode isSuperVariable ifTrue: [ ^ nil ].	conversions at: selector ifPresent: [ :collection | 		collection do: [ :conversion | 			(conversion convertReceiver: receiverAstNode args: args) ifNotNil: [ 				:ast | ^ ast ] ] ].	^ nil! !!PjMessageConverter methodsFor: 'initialization'!initialize	conversions := Dictionary new! !!PjMessageConverter methodsFor: 'add/remove'!removeAllConversions: aCollection	aCollection do: [ : aConversion |		self removeConversion: aConversion	]! !!PjMessageConverter methodsFor: 'add/remove'!removeConversion: aConversion	aConversion isClass		ifTrue: [ ^ self removeConversion: aConversion new ].	(conversions at: aConversion selector		ifAbsent: [^ self])			remove: aConversion ifAbsent: []! !!PjJsAtConversion methodsFor: 'converting'!convertReceiver: receiver args: args	^PjFieldNode target: (self visit: receiver) selectorNode: (self visit: args first) isNonNil: true! !!PjJsAtConversion methodsFor: 'accessing'!selector	^ #js_at:! !!PjJsAtPutConversion methodsFor: 'converting'!convertReceiver: receiver args: args	| reference |	reference :=  super convertReceiver: receiver args: args.	^ PjAssignNode target: reference expression: (self visit: args second)! !!PjJsAtPutConversion methodsFor: 'accessing'!selector	^ #js_at:put:! !!PjJsThisConversion methodsFor: 'converting'!convertReceiver: receiver args: args	^ PjGlobalNode identifier: #this! !!PjJsThisConversion methodsFor: 'accessing'!selector	^#js_this! !!PjNotOptimization methodsFor: 'converting'!convertReceiver: receiver args: args	^ (self visit: receiver) not! !!PjNotOptimization methodsFor: 'accessing'!selector	^#not! !!PjSpecialMessageConversion methodsFor: 'accessing'!astConverter	^self messageConverter astConverter! !!PjSpecialMessageConversion methodsFor: 'converting'!convertReceiver: receiver args: args	" return a replacement AST or nil if there's no matching optimization "	self subclassResponsibility! !!PjSpecialMessageConversion methodsFor: 'accessing'!defaultOrder	" provide a numereic order for multiple optimizations for a given selector - lowest first "	^ 1! !!PjSpecialMessageConversion methodsFor: 'options'!handleReturn: aBlock	^ self astConverter handleReturn: aBlock! !!PjSpecialMessageConversion methodsFor: 'visiting'!inExpressionDo: aBlock	^ self astConverter inExpressionDo: aBlock! !!PjSpecialMessageConversion methodsFor: 'initialize-release'!initialize	super initialize.	self order: self defaultOrder.! !!PjSpecialMessageConversion methodsFor: 'accessing'!messageConverter	^ messageConverter! !!PjSpecialMessageConversion methodsFor: 'accessing'!messageConverter: anObject	messageConverter := anObject! !!PjSpecialMessageConversion methodsFor: 'testing'!needsAllPaths	^self astConverter needsAllPaths! !!PjSpecialMessageConversion methodsFor: 'accessing'!newTemp	^self astConverter newTemp! !!PjSpecialMessageConversion methodsFor: 'accessing'!order	^ order! !!PjSpecialMessageConversion methodsFor: 'accessing'!order: aNumber	order := aNumber! !!PjSpecialMessageConversion methodsFor: 'accessing'!selector	self subclassResponsibility! !!PjSpecialMessageConversion methodsFor: 'options'!tempName	^ self astConverter newTemp! !!PjSpecialMessageConversion methodsFor: 'options'!tempNameFree: tempName	^ self astConverter tempNameFree: tempName! !!PjSpecialMessageConversion methodsFor: 'comparing'!valuesToCompareForEquality	^{self order. self selector}! !!PjSpecialMessageConversion methodsFor: 'visiting'!visit: astNode 	^ astNode acceptVisitor: self astConverter! !!PjSpecialMessageConversion methodsFor: 'visiting'!visitAllNodes: aRBBlockNode	^ self astConverter visitAllNodes: aRBBlockNode! !!PjSpecialMessageConversion methodsFor: 'visiting'!visitInlineBlock: aRBBlockNode 	^ self astConverter visitInlineBlock: aRBBlockNode! !!PjSpecialMessageConversion methodsFor: 'visiting'!visitInlineLoopBlock: aRBBlockNode	^ self astConverter visitInlineLoopBlock: aRBBlockNode! !!PjSpecialMessageConversion methodsFor: 'non-nil handling'!withNonNil: aPjJavascriptAstNode do: aBlockClosure	^ self astConverter withNonNil: aPjJavascriptAstNode do: aBlockClosure! !!PjSpecialMessageConversion methodsFor: 'options'!withTemp: aBlockClosure	| tempName ast |	tempName := self tempName.	ast := aBlockClosure value: tempName.	self tempNameFree: tempName.	^ ast! !!PjStringGenerator class methodsFor: 'accessing'!JsReservedWordsForInstanceVariables	^ JsReservedWordsForInstanceVariables! !!PjStringGenerator class methodsFor: 'Javascript names'!classVariablesHolderName	^ 'prototype'! !!PjStringGenerator class methodsFor: 'class initialization'!initialize	FunctionDefnPrecedence := 3.	StatementPrecedence := -1.	ExpressionPrecedence := 0.	AssignmentPrecedence := 3.	ConditionalPrecedence := 4.	EqualityPrecedence := 10.	FunctionCallPrecedence := 17.	MemberAccessPrecedence := 18.	GroupingPrecedence := 19.	OperatorPrecedencesDict := {		#!! -> 15.		#negate -> 15.		#typeof -> 15.		#* -> 14.		#/ -> 14.		#% -> 14.		#- -> 13.		#+ -> 13.		#< -> 11.		#<= -> 11.		#>= -> 11.		#> -> 11.		#== -> EqualityPrecedence.		#!!= -> EqualityPrecedence.		#=== -> EqualityPrecedence.		#!!== -> EqualityPrecedence.		#& -> 9.		#'^' -> 8.		#| -> 7.		#&& -> 6.		#|| -> 5.		#? -> ConditionalPrecedence.		#= -> AssignmentPrecedence.	} as: IdentityDictionary.	JsReservedWordsForVariables := Set newFrom:		#(abstract arguments boolean break byte case catch char class const continue debugger default delete do double else enum eval export extends false final finally float for function goto if implements import in instanceof int interface let long native new null package private protected public return short static super switch synchronized this throw throws transient true try typeof var void volatile while with yield).	JsReservedWordsForInstanceVariables := Set newFrom: #(constructor prototype)! !!PjStringGenerator class methodsFor: 'accessing'!memberAccessPrecedence	^MemberAccessPrecedence! !!PjStringGenerator class methodsFor: 'Javascript names'!nilInJavascript	^ nil asJSON! !!PjStringGenerator class methodsFor: 'Javascript names'!nilTestFunctionName	^ self transpilerClass coreClass nilTestFunctionName! !!PjStringGenerator class methodsFor: 'Javascript names'!nonLocalReturnVariableName	^ '$_err_$'! !!PjStringGenerator class methodsFor: 'Javascript names'!selfName	^ '$_self_$'! !!PjStringGenerator class methodsFor: 'Javascript names'!tempNamePrefix	^ '$'! !!PjStringGenerator class methodsFor: 'Javascript names'!transpilerClass	^ PjTranspiler! !!PjStringGenerator methodsFor: 'public'!asString: aPjAST		^ String streamContents: [ :aStream | self asString: aPjAST on: aStream ]! !!PjStringGenerator methodsFor: 'public'!asString: aPjAST on: aStream	jsStream := aStream.	currentPrecedenceLevel := -1.	currentlyDoingAssignment := false.	aPjAST acceptVisitor: self.! !!PjStringGenerator methodsFor: 'precedence'!atPrecedence: precedence do: aBlock	| savedPrecedence |	currentPrecedenceLevel > precedence ifTrue: [ self writeNonBrace: $( ].	savedPrecedence := currentPrecedenceLevel.	currentPrecedenceLevel := precedence.	[		aBlock value	] ensure: [		currentPrecedenceLevel := savedPrecedence.		currentPrecedenceLevel > precedence ifTrue: [ self writeNonBrace: $) ]	]! !!PjStringGenerator methodsFor: 'accessing'!currentClass	^ currentClass! !!PjStringGenerator methodsFor: 'accessing'!currentClass: anObject	currentClass := anObject! !!PjStringGenerator methodsFor: 'precedence'!isAtStatementPrecedence	^ currentPrecedenceLevel = StatementPrecedence! !!PjStringGenerator methodsFor: 'accessing'!jsStream	^jsStream! !!PjStringGenerator methodsFor: 'writing'!maybeWriteSemicolon	wroteCloseBrace ifFalse: [ ^ self writeNonBrace: $; ]! !!PjStringGenerator methodsFor: 'accessing'!nilTestFunctionName	^self class nilTestFunctionName! !!PjStringGenerator methodsFor: 'precedence'!nonLocalReturnVariableName	^ self class nonLocalReturnVariableName! !!PjStringGenerator methodsFor: 'accessing'!pharoJsSelectorPrefix	^ pharoJsSelectorPrefix ifNil: [pharoJsSelectorPrefix := transpiler pharoJsSelectorPrefix]! !!PjStringGenerator methodsFor: 'accessing'!selectorsPrefix	^ transpiler pharoJsSelectorPrefix! !!PjStringGenerator methodsFor: 'accessing'!transpiler: aPjTranspiler 	transpiler := aPjTranspiler! !!PjStringGenerator methodsFor: 'visiting'!visit: jsAstNode 	^jsAstNode acceptVisitor: self! !!PjStringGenerator methodsFor: 'visiting'!visitApplyNode: aPjApplyNode 	| args func |	args := aPjApplyNode args.	func := aPjApplyNode func.	self atPrecedence: FunctionCallPrecedence do: [		self visit: func.		args ifNotNil: [			self atPrecedence: ExpressionPrecedence  do: [				args do: [: arg |					arg acceptVisitor: self				] separatedBy: [ self nextPut: $,			]].	]]! !!PjStringGenerator methodsFor: 'visiting'!visitArgumentNode: aPjTempVariableNode 	self writeVariable: aPjTempVariableNode identifier escapingIfIn: JsReservedWordsForVariables! !!PjStringGenerator methodsFor: 'visiting'!visitArrayNode: aPjArrayNode 	self writeNonBrace: $[.	aPjArrayNode expressions do: [: expr |		expr acceptVisitor: self	] separatedBy: [		self nextPut: $,	].	self writeNonBrace: $]! !!PjStringGenerator methodsFor: 'visiting'!visitAssignNode: aPjAssignNode	| saveDoingAssignment |"	(aPjAssignNode target isNonlocalClassOrPoolVariableReference: self currentClass) ifTrue: [		^ 	self atPrecedence: FunctionCallPrecedence do: [				saveDoingAssignment := currentlyDoingAssignment.				currentlyDoingAssignment := true.				self visit: aPjAssignNode target.				currentlyDoingAssignment := saveDoingAssignment.				self					nextPut: $_;					nextPut: $(;					visit: aPjAssignNode expression;					writeNonBrace: $)		]	]."	self atPrecedence: AssignmentPrecedence do: [		self			visit: aPjAssignNode target;			nextPut: $=;			visit: aPjAssignNode expression.			wroteCloseBrace := false	]! !!PjStringGenerator methodsFor: 'visiting'!visitBinaryNode: aPjABinaryNode	self atPrecedence: (OperatorPrecedencesDict at: aPjABinaryNode operator) do: [		self			visit: aPjABinaryNode left;			nextPutAll: aPjABinaryNode operator;			visit: aPjABinaryNode right	]! !!PjStringGenerator methodsFor: 'visiting'!visitBlockNode: aPjMethodNode	currentPrecedenceLevel = StatementPrecedence ifFalse: [		self visitFunctionNode: aPjMethodNode.		wroteCloseBrace := false.		^ self].	self atPrecedence: FunctionDefnPrecedence + 1 do: [ 		self visitFunctionNode: aPjMethodNode.		wroteCloseBrace := false]! !!PjStringGenerator methodsFor: 'visiting'!visitClassNode: aPjClassNode	self nextPutAll: aPjClassNode identifier! !!PjStringGenerator methodsFor: 'visiting'!visitClassVariableNode: aPjClassVariableNode	self		writeNonBrace: (aPjClassVariableNode poolReferenceWith: transpiler);		nextPut: $.;		writeVariable: aPjClassVariableNode identifier escapingIfIn: JsReservedWordsForInstanceVariables.! !!PjStringGenerator methodsFor: 'visiting'!visitFieldNode: aPjFieldNode	| target isLiteral isNonNil |	target := aPjFieldNode target.	isLiteral := target isLiteralNode and: [ target value isInteger ].	isNonNil := isLiteral or: [ aPjFieldNode isNonNil ].	self		atPrecedence: MemberAccessPrecedence do: [			isNonNil ifTrue: [				isLiteral ifTrue: [					self						nextPut: $(;						visit: aPjFieldNode target;						writeNonBrace: $)				] ifFalse: [					self visit: aPjFieldNode target			]] ifFalse: [				self					nextPutAll: self nilTestFunctionName;					atPrecedence: FunctionCallPrecedence do: [						self visit: aPjFieldNode target			]].			aPjFieldNode selectorNode ifNotNil: [self visitFieldNodeWithId: aPjFieldNode selectorNode]		]! !!PjStringGenerator methodsFor: 'visiting'!visitFieldNodeWithId: fieldId	fieldId isLiteralSelector ifTrue: [ ^ self visit: fieldId ].	(fieldId isLiteralNode		and: [ fieldId value isString			and: [ fieldId value				allSatisfy: [ :c | c isAlphaNumeric or: [ c = $$ | (c = $_) ] ] ] ])		ifTrue: [			^ self				writeNonBrace: $.;				nextPutAll: fieldId value].	self		nextPut: $[;		visit: fieldId;		writeNonBrace: $]! !!PjStringGenerator methodsFor: 'visiting'!visitFunctionNode: aPjFunctionNode	self atPrecedence: FunctionDefnPrecedence do: [ 		self writeFunctionHeader: aPjFunctionNode.		self writeFunctionBody: aPjFunctionNode ]! !!PjStringGenerator methodsFor: 'visiting'!visitGlobalNode: aPjGlobalNode	self nextPutAll: aPjGlobalNode identifier! !!PjStringGenerator methodsFor: 'visiting'!visitInstanceVariableNode: aPjTempVariableNode	self		writeNonBrace: $.;		writeVariable: aPjTempVariableNode identifier escapingIfIn: JsReservedWordsForInstanceVariables! !!PjStringGenerator methodsFor: 'visiting'!visitLiteralValueNode: aPjALiteral	self print: aPjALiteral value! !!PjStringGenerator methodsFor: 'visiting'!visitMessageSelectorNode: aPjMessageSelectorNode	self writeNonBrace: $..	self writeJsSelector: aPjMessageSelectorNode identifier onStream: self jsStream! !!PjStringGenerator methodsFor: 'visiting'!visitMethodNode: aPjMethodNode	| savedClass |	savedClass := currentClass.	[ 	currentClass := aPjMethodNode myClass.	self writeJsSelector: aPjMethodNode methodName.	self		nextPut: $(;		writeSafeNames: aPjMethodNode parameters;		nextPut: $).	self writeFunctionBody: aPjMethodNode ] ensure: [ 		currentClass := savedClass ]! !!PjStringGenerator methodsFor: 'visiting'!visitNilNode: aPjIfNilIfNotNilNode 	self nextPutAll: self class nilInJavascript! !!PjStringGenerator methodsFor: 'visiting'!visitNonLocalReturnNode: aPjNonLocalReturnNode	self isAtStatementPrecedence ifTrue: [		self nextPutAll: 'throw '	] ifFalse: [		self nextPutAll: PjCore throwFunctionName; nextPut: $( ].	self		nextPutAll: self class nonLocalReturnVariableName;		writeNonBrace: $=;		visit: aPjNonLocalReturnNode expression.	self isAtStatementPrecedence ifFalse: [ self nextPut: $)]! !!PjStringGenerator methodsFor: 'visiting'!visitObjectNode: aPjObjectNode	| dictionary |	dictionary := aPjObjectNode dictionary.	self nextPut: ${.	dictionary keys asSortedCollection do: [: key |		(key allSatisfy: [: each | each isAlphaNumeric]) ifTrue: [			self nextPutAll: key		] ifFalse: [			self nextPut: $";nextPutAll: key;nextPut: $"		].		self nextPut: $:.		(dictionary at: key) acceptVisitor: self	] separatedBy: [		self nextPut: $,	].	self writeNonBrace: $} " even though this is a brace, it isn't an end-of-statement brace "! !!PjStringGenerator methodsFor: 'visiting'!visitPoolVariableNode: aPjClassVariableNode	self visitClassVariableNode: aPjClassVariableNode! !!PjStringGenerator methodsFor: 'visiting'!visitReturnNode: aPjAReturn	self isAtStatementPrecedence ifFalse: [		self error: 'PjAReturn not at statement level'	].	self		nextPutAll: 'return ';		atPrecedence: ExpressionPrecedence  do: [self visit: aPjAReturn expression].	wroteCloseBrace := false! !!PjStringGenerator methodsFor: 'visiting'!visitSelfNode: aPjASelf	aPjASelf inBlock ifTrue: [ ^ self nextPutAll: self class selfName ].	self nextPutAll: 'this'! !!PjStringGenerator methodsFor: 'visiting'!visitSequenceNode: aPjSequenceNode	self isAtStatementPrecedence ifFalse: [self writeNonBrace:  $(].	aPjSequenceNode expressions do: [: expr |		wroteCloseBrace := false.		expr acceptVisitor: self	] separatedBy: [		self isAtStatementPrecedence ifTrue: [			self maybeWriteSemicolon		] ifFalse: [			self nextPut: $,	]].	self isAtStatementPrecedence		ifFalse: [ self writeNonBrace: $)]! !!PjStringGenerator methodsFor: 'visiting'!visitSuperNode: aPjSuperNode	self nextPutAll: 'super'! !!PjStringGenerator methodsFor: 'visiting'!visitTempVariableNode: aPjTempVariableNode 	self writeVariable: aPjTempVariableNode identifier escapingIfIn: JsReservedWordsForVariables! !!PjStringGenerator methodsFor: 'visiting'!visitTryNode: aPjATry 	self atPrecedence: StatementPrecedence do:  [		self nextPutAll: 'var ';			nextPutAll: self nonLocalReturnVariableName;			nextPutAll: '={};try{'.		self			writeBodyStatements: aPjATry;			nextPutAll: '}catch(e){if(e===';			nextPutAll: self nonLocalReturnVariableName;			nextPutAll: ')return e;throw e';			writeCloseBrace	]! !!PjStringGenerator methodsFor: 'visiting'!visitUnaryNode: aPjUnaryNode 	self atPrecedence: (OperatorPrecedencesDict at: aPjUnaryNode operator) do: [		self			nextPutAll: aPjUnaryNode operator;			visit: aPjUnaryNode expression	]! !!PjStringGenerator methodsFor: 'visiting'!visitUnparsedStringNode: aPjUnparsedStringNode	self nextPutAll: aPjUnparsedStringNode string! !!PjStringGenerator methodsFor: 'visiting'!visitVariableNode: aPjVariableNode	self nextPutAll: aPjVariableNode identifier! !!PjStringGenerator methodsFor: 'writing'!writeBodyStatements: aBodyContainingNode	currentPrecedenceLevel := StatementPrecedence.	wroteCloseBrace := false.	aBodyContainingNode body		do: [ :each | self visit: each ]		separatedBy: [ self maybeWriteSemicolon ]! !!PjStringGenerator methodsFor: 'writing'!writeCloseBrace	self nextPut: $}.	wroteCloseBrace := true! !!PjStringGenerator methodsFor: 'writing'!writeFunctionBody: aPjFunctionNode	self		nextPut: ${;		writeFunctionLocals: aPjFunctionNode;		writeBodyStatements: aPjFunctionNode;		writeCloseBrace! !!PjStringGenerator methodsFor: 'writing'!writeFunctionHeader: aPjFunctionNode	self		nextPut: $(;		writeSafeNames: aPjFunctionNode parameters;		nextPut: $); nextPutAll: '=>'! !!PjStringGenerator methodsFor: 'writing'!writeFunctionLocals: aPjFunctionNode		aPjFunctionNode locals isEmpty ifTrue: [			aPjFunctionNode needsSelf ifFalse: [^self]].		self			nextPutAll: 'var ';			writeSafeNames: 	aPjFunctionNode locals.		aPjFunctionNode needsSelf ifTrue: [				aPjFunctionNode locals isEmpty ifFalse: [ self nextPut: $, ].			self				nextPutAll: self class selfName;				nextPutAll: '=this'		].		self nextPut: $;! !!PjStringGenerator methodsFor: 'writing'!writeNonBrace: aCharacterOrString	aCharacterOrString isString ifTrue: [		self nextPutAll: aCharacterOrString	] ifFalse:  [		self nextPut: aCharacterOrString	].	wroteCloseBrace := false.! !!PjStringGenerator methodsFor: 'writing'!writeSafeNames: aCollection	aCollection do: [ : each | 		self writeVariable: each escapingIfIn: JsReservedWordsForVariables ]	separatedBy: [ self nextPut: $, ]! !!PjTranspiler class methodsFor: 'accessing'!classVariablesHolderName	^ PjStringGenerator classVariablesHolderName! !!PjTranspiler class methodsFor: 'transpiling'!classVarsPoolName	^'cp$'! !!PjTranspiler class methodsFor: 'transpiling'!convertToJs: anObject	^self new convertToJs: anObject! !!PjTranspiler class methodsFor: 'accessing'!coreClass	^ PjCore! !!PjTranspiler class methodsFor: 'transpiling'!installAllAliasesSelector	^ #installAllAliases! !!PjTranspiler class methodsFor: 'transpiling classes'!installClassSelector	^#installClass! !!PjTranspiler class methodsFor: 'transpiling classes'!installJsClassPlaceholderSelector	^ #installJsClassPlaceholder! !!PjTranspiler class methodsFor: 'accessing'!lineEnding	^Character cr! !!PjTranspiler class methodsFor: 'accessing'!skipMethodPragmaKeyword	"Methods with this pragma are skipped upon conversion to javascript."	^#pharoJsSkip! !!PjTranspiler methodsFor: 'transpiling aliases'!addAliasesForClassMethod: aRBMethodNode	self		aliasesDict: classMethodsAliasesDict		addForMethod: aRBMethodNode! !!PjTranspiler methodsFor: 'transpiling aliases'!addAliasesForInstanceMethod: aRBMethodNode	self		aliasesDict: instanceMethodsAliasesDict		addForMethod: aRBMethodNode! !!PjTranspiler methodsFor: 'conversions'!addAllConversions: aCollection 	converter addAllConversions: aCollection! !!PjTranspiler methodsFor: 'conversions'!addAllOptionalConversions	| aCollection |	aCollection := PjOptionalMessageConversion allSubclasses select: [: class | class includesSelector: #selector ].	self addAllConversions: aCollection! !!PjTranspiler methodsFor: 'conversions'!addAllOptionalConversionsExcept: low to: high	| aCollection discard |	aCollection := PjOptionalMessageConversion allSubclasses select: [: class | class includesSelector: #selector ].	aCollection := aCollection sorted: [: l : r | l name < r name].	discard := aCollection copyFrom: (low*aCollection size) asInteger+1 to: (high*aCollection size) asInteger.	self addAllConversions: (aCollection reject: [: each | discard includes: each ]).	discard inspect.! !!PjTranspiler methodsFor: 'transpiling aliases'!aliasesDict: aDict addForMethod: aRBMethodNode	aRBMethodNode pragmas		select: [ :pragma | pragma selector beginsWith: #jsAlias: ]		thenDo: [ :pragma | 		self aliasesDict: aDict at: aRBMethodNode selector addAll: pragma arguments ]! !!PjTranspiler methodsFor: 'transpiling aliases'!aliasesDict: aliasesDict at: methodSelector addAll: newAliases	| aliases |	aliases := aliasesDict		           at: methodSelector		           ifAbsentPut: [ Set new ].	aliases addAll: newAliases! !!PjTranspiler methodsFor: 'accessing'!beforeCodeOutputHook: aBlockClosure 	beforeCodeOutputHook := aBlockClosure! !!PjTranspiler methodsFor: 'accessing'!classVariablesHolderName	^ self class classVariablesHolderName! !!PjTranspiler methodsFor: 'transpiling'!classVarsPoolName	^self class classVarsPoolName! !!PjTranspiler methodsFor: 'transpiling classes'!convertAllClasses: classes	| actualClassesToConvert classesInWriteOrder |	beforeCodeOutputHook ifNotNil: [ beforeCodeOutputHook value ].	actualClassesToConvert := classes asIdentitySet collect:		                          #classToUseForJsConversion.	classesInWriteOrder := self orderForWriting: actualClassesToConvert.	classesInWriteOrder do: [ :aClass | 		self writeClassDefinitionOf: aClass. ].	self writeDnuList.	self writeClassInitializeOfAll: classesInWriteOrder! !!PjTranspiler methodsFor: 'transpiling classes'!convertAllClasses: classes writeDnu: aBoolean	self 		enableWriteDnu: aBoolean		during: [self convertAllClasses: classes].! !!PjTranspiler methodsFor: 'transpiling'!convertAndWriteClosedBlock: valuedBlock 	self convertAndWriteClosedBlock: valuedBlock with: [ ]! !!PjTranspiler methodsFor: 'transpiling'!convertAndWriteClosedBlock: valuedBlock with: aBlock	| jsAst |	jsAst := converter convertValuedBlock: valuedBlock.	aBlock value.	generator asString: jsAst on: self jsStream.	jsStream		nextPut: $;;		cr! !!PjTranspiler methodsFor: 'transpiling'!convertBlock: aBlock 	| jsAst |	jsAst := converter convertBlock: aBlock.	^self generateCodeStringFrom: jsAst.! !!PjTranspiler methodsFor: 'transpiling classes'!convertClass: aClass	| actualClassToConvert |	actualClassToConvert := aClass classToUseForJsConversion.	self writeClassDefinitionOf: actualClassToConvert.	self writeClassInitializeOf: actualClassToConvert! !!PjTranspiler methodsFor: 'transpiling'!convertClosedBlock: closedBlock 	| jsAst |	jsAst := converter convertClosedBlock: closedBlock.	^self generateCodeStringFrom: jsAst.! !!PjTranspiler methodsFor: 'transpiling'!convertSmalltalkString: aString	self transpileMethod: (nil class compiler source: (ReadStream on: 'transpile ^',aString); receiver: nil class ; compile)! !!PjTranspiler methodsFor: 'transpiling'!convertToJs: anObject	^ self onTempStreamDo: [anObject convertToJsUsing: self]! !!PjTranspiler methodsFor: 'transpiling'!convertValuedBlock: valuedBlock 	| jsAst |	jsAst := converter convertValuedBlock: valuedBlock.	^self generateCodeStringFrom: jsAst.! !!PjTranspiler methodsFor: 'accessing'!coreClass	^ self class coreClass! !!PjTranspiler methodsFor: 'initialization'!defaultConverterClass	^PjAstConverter! !!PjTranspiler methodsFor: 'initialization'!defaultGeneratorClass	^PjStringGenerator! !!PjTranspiler methodsFor: 'initialization'!defaultMessageConversions	^ { PjJsThisConversion. PjJsAtConversion. PjJsAtPutConversion }! !!PjTranspiler methodsFor: 'transpiling'!disableWriteDnuDuring: aBlockClosure 	^self enableWriteDnu: false during: aBlockClosure! !!PjTranspiler methodsFor: 'loading'!discoveredGlobalsPool: aClass	"To be used for loading polyfills"	^self! !!PjTranspiler methodsFor: 'loading'!discoveredMessage: aSymbol	neededDNUs add: aSymbol! !!PjTranspiler methodsFor: 'loading'!discoveredReferenceToClass: aClass	"To be used for dynamic class and method loading"	^self! !!PjTranspiler methodsFor: 'transpiling'!dnuJsString	^ self enableWriteDnuDuring: [self onTempStreamDo: [self writeDnuList]]! !!PjTranspiler methodsFor: 'ordering'!does: last reference: first	| classesReferencingFirst |	classesReferencingFirst := classesReferencingCache		at: first		ifAbsentPut: [ | methodsReferencingFirst |			methodsReferencingFirst := SystemNavigation				globalRefsForPharoJS: first classToUseForJsConversion name.			methodsReferencingFirst asSet				collect: [ :each | each methodClass instanceSide ] ].	(classesReferencingFirst includes: last)		ifTrue: [ ^ true ].	classesReferencingFirst		detect: [ :each | last inheritsFrom: each ]		ifFound: [ ^ true ].	(last sharedPools includes: first)		ifTrue: [ ^ true ].	^ false! !!PjTranspiler methodsFor: 'transpiling'!enableWriteDnu: aBoolean during: aBlockClosure 	| initialShouldWriteDnu |	initialShouldWriteDnu := self shouldWriteDnu.	self shouldWriteDnu: aBoolean.	^aBlockClosure ensure: [ self shouldWriteDnu: initialShouldWriteDnu ]! !!PjTranspiler methodsFor: 'transpiling'!enableWriteDnuDuring: aBlockClosure 	^self enableWriteDnu: true during: aBlockClosure! !!PjTranspiler methodsFor: 'loading'!findClassesFor: aClass	^ { aClass }, aClass allSuperclasses! !!PjTranspiler methodsFor: 'transpiling'!generateCodeStringFrom: jsAst	generator asString: jsAst on: self jsStream! !!PjTranspiler methodsFor: 'initialization'!initialize	super initialize.	generatedMethods := Dictionary new.	converter := self defaultConverterClass new.	converter transpiler: self.	converter addAllMessageConversions: self defaultMessageConversions.	generator := self defaultGeneratorClass new transpiler: self.	self shouldWriteDnu: true.	neededDNUs := Set new.	writtenDNUs := Set new.	poolsUsed := IdentityDictionary new.	classesReferencingCache := IdentityDictionary new.	self pharoJsSelectorPrefix: '_'.! !!PjTranspiler methodsFor: 'transpiling aliases'!installAllAliasesSelector	^self class installAllAliasesSelector! !!PjTranspiler methodsFor: 'transpiling classes'!installClassSelector	^ self class installClassSelector! !!PjTranspiler methodsFor: 'transpiling classes'!installJsClassPlaceholderSelector	^ self class installJsClassPlaceholderSelector! !!PjTranspiler methodsFor: 'transpiling classes'!installSelectorFor: aClass	^ aClass isJsClassPlaceholder		  ifTrue: [ self installJsClassPlaceholderSelector ]		  ifFalse: [ self installClassSelector ]! !!PjTranspiler methodsFor: 'accessing'!jsCode	^ self jsStream contents trim! !!PjTranspiler methodsFor: 'accessing'!jsStream	^jsStream ifNil: [ jsStream := '' writeStream ]! !!PjTranspiler methodsFor: 'accessing'!lineEnding	^self class lineEnding! !!PjTranspiler methodsFor: 'ordering'!moveHighestPriorityClassesIn: initialClasses to: orderedClasses with: doesReferenceBlock	| nextClasses |	nextClasses  := initialClasses select: [: aClass | 			initialClasses noneSatisfy: [: bClass | 				self should: bClass occurBefore: aClass with: doesReferenceBlock]].	nextClasses isEmpty ifTrue: [ ^ converter transpilationError: 'circular class dependency' ].	(nextClasses includes: PjObject) ifTrue: [ nextClasses size > 1 ifTrue: [self halt] ].	initialClasses removeAll: nextClasses.	orderedClasses addAll: nextClasses.! !!PjTranspiler methodsFor: 'transpiling classes'!needMetaclassFixFor: aClass	^ aClass isJsClassPlaceholder! !!PjTranspiler methodsFor: 'outputing'!newlyGeneratedAstsDo: aBlock	generatedMethods keysAndValuesDo: [ : method : ast |		ast = #done ifFalse: [			aBlock cull: method cull: ast.			generatedMethods at: method put: #done	]]! !!PjTranspiler methodsFor: 'statistics'!numberOfClasses	^ nil! !!PjTranspiler methodsFor: 'statistics'!numberOfMethods	^ nil! !!PjTranspiler methodsFor: 'transpiling'!onStream: aStream	jsStream := aStream! !!PjTranspiler methodsFor: 'writing low-level'!onTempStreamDo: aBlock	| saveStream |	saveStream := jsStream.	jsStream := '' writeStream.	^ [		aBlock value.		jsStream contents	] ensure: [ jsStream := saveStream ]! !!PjTranspiler methodsFor: 'ordering'!order: classes with: doesReferenceBlock	"Arrange the classes in the collection, classes, in initialization order.	Based on Class class>>#superclassOrder:"	| orderedClasses initialClasses cache |	initialClasses := classes copy asOrderedCollection.	cache := Dictionary new.	orderedClasses := OrderedCollection new: initialClasses size.	[initialClasses size > 0] whileTrue: [		self			moveHighestPriorityClassesIn: initialClasses			to: orderedClasses			with: doesReferenceBlock ].	^ orderedClasses! !!PjTranspiler methodsFor: 'ordering'!orderForInitialization: classes	^ self order: classes with: [ : first : last |		self does: last reference: first ]! !!PjTranspiler methodsFor: 'ordering'!orderForWriting: classes 	^ self order: classes with: [ : first : last |		last allSharedPoolsRecursive includes: first]! !!PjTranspiler methodsFor: 'transpiling'!pharoJsSelectorPrefix	^ pharoJsSelectorPrefix! !!PjTranspiler methodsFor: 'transpiling'!pharoJsSelectorPrefix: newSelectorsPrefix	pharoJsSelectorPrefix := newSelectorsPrefix.! !!PjTranspiler methodsFor: 'transpiling'!poolFor: myClass	^ poolsUsed at: myClass instanceSide ifAbsentPut: [OrderedCollection with: myClass instanceSide ]! !!PjTranspiler methodsFor: 'transpiling'!poolReference: aClass for: myClass	^ aClass nameToUseForJsConversion, '.',  self classVarsPoolName! !!PjTranspiler methodsFor: 'conversions'!removeAllConversions: aCollection 	converter removeAllConversions: aCollection! !!PjTranspiler methodsFor: 'transpiling aliases'!resetMethodAliasesDictionaries	instanceMethodsAliasesDict := Dictionary new.	classMethodsAliasesDict := Dictionary new.! !!PjTranspiler methodsFor: 'accessing'!selectorsPrefix	^ self pharoJsSelectorPrefix! !!PjTranspiler methodsFor: 'conversions'!setExtraBindings: aDictionary 	converter setExtraBindings: aDictionary! !!PjTranspiler methodsFor: 'ordering'!should: first occurBefore: last with: doesReferenceBlock	first=last ifTrue: [ ^false ].	(last javascriptInheritsFrom: first) ifTrue: [ ^true ].	(first javascriptInheritsFrom: last) ifTrue: [ ^false ].	^ doesReferenceBlock value: first value: last! !!PjTranspiler methodsFor: 'transpiling methods'!shouldSkipMethodNode: aRBMethodNode	^aRBMethodNode hasPragmaNamed: self skipMethodPragmaKeyword! !!PjTranspiler methodsFor: 'accessing'!shouldWriteDnu	^ shouldWriteDnu! !!PjTranspiler methodsFor: 'accessing'!shouldWriteDnu: anObject	shouldWriteDnu := anObject! !!PjTranspiler methodsFor: 'accessing'!skipMethodPragmaKeyword	^self class skipMethodPragmaKeyword! !!PjTranspiler methodsFor: 'transpiling methods'!transpileMethod: aMethod	| jsAst |	jsAst := converter		convertAst: aMethod ast		withPrimitive: aMethod primitive.	generator asString: jsAst on: self jsStream! !!PjTranspiler methodsFor: 'transpiling methods'!transpileMethodToString: aMethod	^ self onTempStreamDo: [ self transpileMethod: aMethod ]! !!PjTranspiler methodsFor: 'transpiling methods'!withMethodsNoSkipOf: aClass do: aBlock	self withMethodsOf: aClass do: [ :method | 		(self shouldSkipMethodNode: method) ifFalse: [aBlock value: method] ]! !!PjTranspiler methodsFor: 'transpiling methods'!withMethodsOf: aClass do: aBlock	aClass selectorsWithExplicitOrigin do: [ : selector |		 aBlock value: (aClass compiledMethodAt: selector) ]! !!PjTranspiler methodsFor: 'transpiling aliases'!writeAssociationKey: selector values: aliasesself				<< $";				writeJsSelector: selector;				<< '":['.			aliases				do: [ :each | self print: each ]				separatedBy: [ self << $, ].			self << $] ! !!PjTranspiler methodsFor: 'transpiling classes'!writeClassDeclarationOf: aClassaClass isJsClassPlaceholder ifTrue: [ ^self writeClassExtensionDeclarationOf: aClass ].	self << 'class';			space;			writeNameForClass: aClass; 		space;		<< 'extends';		space; 		writeNameForClass: aClass superclass ! !!PjTranspiler methodsFor: 'transpiling classes'!writeClassDefinitionOf: aClass	self resetMethodAliasesDictionaries.	self		writeNameForClass: PjCore;		<< '.';		<< (self installSelectorFor: aClass);		<< $(;		writeClassDeclarationOf: aClass;		<< ${;		cr;		writeMethodsOf: aClass;		writeClassVariableDeclarationsOf: aClass;		<< '},'.	aClass isJsClassPlaceholder ifTrue: [ 		self			writeNameForClass: aClass;			<< $, ].	self		writeInstanceMethodsAliasesDict;		<< $,;		writeClassMethodsAliasesDict;		<< ');'! !!PjTranspiler methodsFor: 'transpiling classes'!writeClassExtensionDeclarationOf: aClass	self		<< 'class';		space;		<< 'extends';		space;		<< '(';		writeNameForClass: aClass;		<< '.__proto__.prototype == null  ? Object :';		writeNameForClass: aClass;		<< '.__proto__)'! !!PjTranspiler methodsFor: 'transpiling'!writeClassInitializeOf: aClass	aClass needsInitialization ifFalse: [^self].  	self 		writeNameForClass: aClass;		nextPutAll: '.', self pharoJsSelectorPrefix, aClass classInitializeSelector, '();';		cr! !!PjTranspiler methodsFor: 'transpiling'!writeClassInitializeOfAll: classesInWriteOrder	| sortedClassesToInit classesToInit |	classesToInit := classesInWriteOrder select: #needsInitialization.	sortedClassesToInit := self orderForInitialization: classesToInit.	^ sortedClassesToInit		do: [ :aClass | self writeClassInitializeOf: aClass ]! !!PjTranspiler methodsFor: 'transpiling aliases'!writeClassMethodsAliasesDict	self writeMethodAliasesDict: classMethodsAliasesDict! !!PjTranspiler methodsFor: 'transpiling methods'!writeClassMethodsOf: aClass	self withMethodsNoSkipOf: aClass class do: [ :aRBMethodNode | 		self			<< 'static ';			transpileMethod: aRBMethodNode;			addAliasesForClassMethod:aRBMethodNode ;			cr ]! !!PjTranspiler methodsFor: 'transpiling'!writeClassVarNamesOf: aClass	aClass classPool keys		do: [ :classVarName | 			self				nextPut: $";				nextPutAll: classVarName;				nextPut: $";				nextPutAll: ':null' ]		separatedBy: [ self nextPut: $, ]! !!PjTranspiler methodsFor: 'transpiling'!writeClassVariableDeclarationsOf: aClass	self		nextPutAll: 'static';		space;		writeClassVarsPoolName;		nextPutAll: '={';		writeClassVarNamesOf: aClass;		nextPut: $}. ! !!PjTranspiler methodsFor: 'transpiling'!writeClassVarsPoolName	self nextPutAll: self classVarsPoolName! !!PjTranspiler methodsFor: 'transpiling'!writeDnuList	| selectors |	self shouldWriteDnu ifFalse: [^self].	selectors := neededDNUs asSortedCollection reject: [ : selector | writtenDNUs includes: selector ].	selectors ifEmpty: [ ^ self ].	self 		writeNameForClass: self coreClass;		nextPut: $.;		nextPutAll: self pharoJsSelectorPrefix;		nextPutAll: 'registerDnuForAll_(['.	selectors do: [		: selector |			writtenDNUs add: selector.			selector printJsOn: self	] separatedBy: [ self nextPut: $, ].	self 		nextPutAll: ']);';		cr.	neededDNUs := Set new.! !!PjTranspiler methodsFor: 'transpiling aliases'!writeInstallMethodAliasesOf: aClass	(instanceMethodsAliasesDict isEmpty and: [ 		 classMethodsAliasesDict isEmpty ]) ifTrue: [ ^ self ].	self		writeNameForClass: PjCore;		<< $.;		<< self installAllAliasesSelector;		<< $(;		writeInstanceMethodsAliasesDict;		<< $,;		writeClassMethodsAliasesDict;		<< $,;		writeNameForClass: aClass;		<< $,;		writeNameForClass: aClass;		<< ');';		cr! !!PjTranspiler methodsFor: 'transpiling aliases'!writeInstanceMethodsAliasesDict	self writeMethodAliasesDict: instanceMethodsAliasesDict ! !!PjTranspiler methodsFor: 'transpiling methods'!writeInstanceMethodsOf: aClass	self withMethodsNoSkipOf: aClass do: [ :aRBMethodNode | 		self			transpileMethod: aRBMethodNode;			addAliasesForInstanceMethod: aRBMethodNode;			cr ]! !!PjTranspiler methodsFor: 'transpiling'!writeInstanceVariable: cvName	self writeVariable: cvName escapingIfIn: PjStringGenerator JsReservedWordsForInstanceVariables! !!PjTranspiler methodsFor: 'writing'!writeList: aCollection withPrefix: aString 	aCollection do: [: each |		self jsStream nextPutAll: aString;nextPutAll: each	]! !!PjTranspiler methodsFor: 'transpiling aliases'!writeMethodAliasesDict: aliasesDict	self << ${.	aliasesDict keys		do: [ :selector | 			self				writeAssociationKey: selector				values: (aliasesDict at: selector) ]		separatedBy: [ self << $, ].	self << $}! !!PjTranspiler methodsFor: 'transpiling methods'!writeMethodsOf: aClass	converter classForConversion: aClass.	self		writeInstanceMethodsOf: aClass;		writeClassMethodsOf: aClass! !!PjTranspiler methodsFor: 'transpiling classes'!writeNameForClass: aClass	self nextPutAll: aClass instanceSide nameToUseForJsConversion! !!Metaclass methodsFor: '*PharoJs-Base-Transpiler'!classToUseForJsConversion	^ self instanceSide classToUseForJsConversion classSide! !!BlockClosure class methodsFor: '*PharoJs-Base-Transpiler'!outerContext: aContext startpc: startPcOrOuterCode numArgs: anInteger copiedValues: copiedValues 	| newBlock |	newBlock := self new: copiedValues size.	newBlock		outerContext: aContext;		compiledBlock: startPcOrOuterCode;		numArgs: anInteger.	1 to: newBlock numCopiedValues do:		[:i|		newBlock at: i put: (copiedValues at: i)].	^newBlock 			! !!BlockClosure methodsFor: '*PharoJs-Base-Transpiler'!arguments	^#()! !!BlockClosure methodsFor: '*PharoJs-Base-Transpiler'!asClosedBlock	^ self closedBlockClass		  startpc: self basicStartpc		  numArgs: self numArgs		  originalBlock: self! !!BlockClosure methodsFor: '*PharoJs-Base-Transpiler'!asJsAstUsing: aConverter	^aConverter convertBlock: self! !!BlockClosure methodsFor: '*PharoJs-Base-Transpiler'!asValuedBlock	^PjValuedClosedBlockClosure newFrom: self! !!BlockClosure methodsFor: '*PharoJs-Base-Transpiler'!asValuedBlockWithArgs: args	^PjValuedClosedBlockClosure newFrom: self withArgs: args! !!BlockClosure methodsFor: '*PharoJs-Base-Transpiler'!basicStartpc	^startpc! !!BlockClosure methodsFor: '*PharoJs-Base-Transpiler'!closedBlockClass	^PjClosedBlockClosure! !!BlockClosure methodsFor: '*PharoJs-Base-Transpiler'!convertToJavascriptAstUsing: aPjAstConverter	^ aPjAstConverter visit: self! !!BlockClosure methodsFor: '*PharoJs-Base-Transpiler'!convertToJsUsing: aPjTranspiler 	aPjTranspiler convertBlock: self! !!BlockClosure methodsFor: '*PharoJs-Base-Transpiler'!copiedValues	^(1 to: self numCopiedValues) collect: [: index | 		self copiedValueAt: index].! !!BlockClosure methodsFor: '*PharoJs-Base-Transpiler'!copiedValuesForClosedBlock	^self copiedValues collect: [ : each | each copy ]! !!BlockClosure methodsFor: '*PharoJs-Base-Transpiler'!externalVariable: variable formContext: context	^ PjJavascriptTranspilationError new messageText: 'free temp variable: ', variable name! !!BlockClosure methodsFor: '*PharoJs-Base-Transpiler'!externalVariable: name fromContext: context andScope: scope	^ PjJavascriptTranspilationError new messageText: 'free temp variable: ',name! !!BlockClosure methodsFor: '*PharoJs-Base-Transpiler'!externalVariable: name fromMethod: method	^ PjJavascriptTranspilationError new messageText: 'free instance variable: ',name! !!BlockClosure methodsFor: '*PharoJs-Base-Transpiler'!externalVariablesDict	^ self externalVariablesDictOf: self! !!BlockClosure methodsFor: '*PharoJs-Base-Transpiler'!externalVariablesDictOf: aBlock	| context method variablesDict tempValue scope |	variablesDict := Dictionary new.	context := aBlock asContext.	scope := aBlock outerContext sourceNode scope.	scope allTemps do: [ :variable | 				tempValue := self externalVariable: variable formContext: context.		variablesDict at: variable name put: tempValue ].	method := aBlock home receiver.	method class allInstVarNames do: [ :name | 		variablesDict			at: name			put: (self externalVariable: name fromMethod: method) ].	^ variablesDict! !!BlockClosure methodsFor: '*PharoJs-Base-Transpiler'!firstAstNode	^self sourceNode statements first! !!BlockClosure methodsFor: '*PharoJs-Base-Transpiler'!isClosed	^ false! !!BlockClosure methodsFor: '*PharoJs-Base-Transpiler'!isFreeJavascriptValue	^ self isClosed! !!BlockClosure methodsFor: '*PharoJs-Base-Transpiler'!originalBlock	^ self! !!PjValuedClosedBlockClosure class methodsFor: 'instance creation'!newFrom: aBlock	^self newFrom: aBlock withArgs: #()! !!PjValuedClosedBlockClosure class methodsFor: 'instance creation'!newFrom: aBlock withArgs: args	| newInstance |	aBlock isClosed ifTrue: [ 		PjJavascriptTranspilationError signal:			'Cannot build a valued block from a closed one' ].	newInstance := self		               startpc: aBlock startpc		               numArgs: aBlock numArgs		               originalBlock: aBlock.	^ newInstance		  arguments: args;		  yourself! !!PjValuedClosedBlockClosure methodsFor: 'accessing'!arguments	^ arguments! !!PjValuedClosedBlockClosure methodsFor: 'accessing'!arguments: anObject	arguments := anObject! !!PjValuedClosedBlockClosure methodsFor: 'converting'!convertToJsUsing: aPjTranspiler 	aPjTranspiler convertValuedBlock: self! !!String methodsFor: '*PharoJs-Base-Transpiler'!isLiteralJavascriptValue	^ true! !!String methodsFor: '*PharoJs-Base-Transpiler'!printJsOn: aStream	aStream nextPut: $".	self do: [ : each |		self printOneJsCharacter: each asInteger onStream: aStream ].	aStream nextPut: $".! !!String methodsFor: '*PharoJs-Base-Transpiler'!printOneJsCharacter: each onStream: aStream	each < 32 ifTrue: [		aStream nextPut: $\.		each = 10			ifTrue: [ aStream nextPut: $n ]			ifFalse: [ each = 13					ifTrue: [ aStream nextPut: $r ]					ifFalse: [						aStream nextPut: $x.						aStream nextPutAll: (each printStringBase: 16 nDigits: 2) ] ] 	] ifFalse: [		each < 128 ifTrue: [			each = 34 ifTrue: [ aStream nextPut: $\ ].			each = 92 ifTrue: [ aStream nextPut: $\ ].			aStream nextPut: (Character value: each).		] ifFalse: [			aStream nextPut: $\.			aStream nextPut: $u.			aStream nextPutAll: (each printStringBase: 16 nDigits: 4).	]]! !!Trait method!basicOriginalBlock: aBlock	originalBlock := aBlock.	externalVariablesDict := self externalVariablesDictOf: originalBlock! !"PharoJs-Base-Transpiler"!!PjTJavascriptCodeAnalyser commentStamp: '' prior: 0!I have code to support various tests that need to extract values from generated Javascript code.!!PjAbstractAstTest commentStamp: '' prior: 0!I define a set of instance variables used in a variety of tests!!PjAstConverterTest commentStamp: '' prior: 0!I'm an abstract test class!!PjBasicConverterTest commentStamp: '' prior: 0!I have tests for basic ast conversions!!PjSpecialMessagesConversionTest commentStamp: '' prior: 0!I have tests for ast conversions that use the optimizer.!!PjTranspilationTest commentStamp: '' prior: 0!I contain utility methods for transpilation tests!!PjGeneratedClassTranspilationTest commentStamp: '' prior: 0!Provides a class factory and a default class to use in tests.Both are provided by a resource to avoid creating the default class upon each test run, which is too slow in Pharo 5 (was faster in Pharo 4).!!PjTranspilationClassCompilationTest commentStamp: '' prior: 0!I have utility methods for testing transpiled code!!PjReplacedClassTranspilationTest commentStamp: '' prior: 0!I have tests relating to classes that have implementations of some methods in another class!!PjNullMessageConversionForTest commentStamp: '' prior: 0!I am a dummy PjOptimization to test the manager!!PjClassForAstConversionTest commentStamp: '' prior: 0!I contain methods to use as sources for various tests in PjTranspilationTests!!PjReplacedClassForTest commentStamp: '' prior: 0!I contain methods to use as sources for various tests in PjTranspilationTests!!PjSuperClassForTranspilationTest commentStamp: '' prior: 0!I am a superclass with a pool dictionary to be validated with PjTranspilerTest!!PjClassForTranspilationTest commentStamp: '' prior: 0!I am a class to be validated with PjTranspilerTest!!PjTJavascriptCodeAnalyser methodsFor: 'asserting'!assert: actualString includes: expectedSubString	self assert: (self does: actualString includes: expectedSubString)! !!PjTJavascriptCodeAnalyser methodsFor: 'asserting'!assert: firstString precedes: secondString	| first second |	first := self jsCode findString: firstString.	second := self jsCode findString: secondString.	self assert: first<second! !!PjTJavascriptCodeAnalyser methodsFor: 'asserting'!assertClassMethod: method equals: aString	self assert: (self classMethod: method) equals: aString! !!PjTJavascriptCodeAnalyser methodsFor: 'asserting'!assertHasClassMethod: selector	self deny: (self classMethod: selector ) isNil! !!PjTJavascriptCodeAnalyser methodsFor: 'asserting'!assertHasInstanceMethod: selector	self deny: (self instanceMethod: selector ) isNil! !!PjTJavascriptCodeAnalyser methodsFor: 'asserting'!assertInstanceMethod: method equals: aString	self assert: (self instanceMethod: method) equals: aString! !!PjTJavascriptCodeAnalyser methodsFor: 'test support'!classMethod: aSymbol	^ self method: aSymbol prefix: 'static '! !!PjTJavascriptCodeAnalyser methodsFor: 'accessing'!classToTranspile	self explicitRequirement! !!PjTJavascriptCodeAnalyser methodsFor: 'asserting'!deny: actualString includes: expectedSubString	self deny: (self does: actualString includes: expectedSubString)! !!PjTJavascriptCodeAnalyser methodsFor: 'asserting'!does: actualString includes: expectedSubString	^actualString withSeparatorsCompacted trim includesSubstring: expectedSubString withSeparatorsCompacted trim! !!PjTJavascriptCodeAnalyser methodsFor: 'test support'!instanceMethod: aSymbol	^ self method: aSymbol prefix: ''! !!PjTJavascriptCodeAnalyser methodsFor: 'accessing'!jsCode	self explicitRequirement! !!PjTJavascriptCodeAnalyser methodsFor: 'test support'!method: aSymbol prefix: prefixString	| start aString end |	aString := String streamContents: [ :aStream | 		           aStream			           << self lineEnding;			           << prefixString.		           self writeJsSelector: aSymbol onStream: aStream.		           aStream << $( ].	start := self jsCode findString: aString.	start = 0 ifTrue: [ ^ nil ].	end := self jsCode		       findString: (String with: self lineEnding)		       startingAt: start + 1.	end = 0 ifTrue: [ end := self jsCode size + 1 ].	^ self jsCode copyFrom: start + aString size -1 to: end - 1! !!PjAbstractAstTest class methodsFor: 'testing'!isAbstract 	^ self = PjAbstractAstTest! !!PjAbstractAstTest methodsFor: 'checking'!apply: aPjJavascriptAstNode selector: aSelector	^ self apply: aPjJavascriptAstNode selector: aSelector nonNil: aPjJavascriptAstNode isNonNil! !!PjAbstractAstTest methodsFor: 'checking'!apply: aPjJavascriptAstNode selector: aSelector nonNil: nonNil	^ PjApplyNode func: (PjFieldNode target: aPjJavascriptAstNode selectorNode: (PjMessageSelectorNode identifier: aSelector asSymbol) isNonNil: nonNil)		args: #()! !!PjAbstractAstTest methodsFor: 'accessing'!pharoJsSelectorPrefix	^ '_'! !!PjAbstractAstTest methodsFor: 'running'!setUp	super setUp.	minusTwo := PjLiteralValueNode value: -2.	minusOne := PjLiteralValueNode value: -1.	one := PjLiteralValueNode value: 1.	two := PjLiteralValueNode value: 2.	three := PjLiteralValueNode value: 3.	pi := PjLiteralValueNode value: 3.1415926.	helloString := PjLiteralValueNode value: 'hello'.	nilNode := PjNilNode new.	trueNode := PjLiteralValueNode value: true.	falseNode := PjLiteralValueNode value: false.	selfNode := PjSelfNode new.	selfNodeInBlock := PjSelfNode new inBlock: true;yourself.	returnOne := PjReturnNode expression: one.	returnTwo := PjReturnNode expression: two.	returnThree := PjReturnNode expression: three.	returnNil := PjReturnNode expression: nilNode.	returnTrue := PjReturnNode expression: trueNode.	returnFalse := PjReturnNode expression: falseNode.	returnSelf := PjReturnNode expression: selfNode.	throwOne := PjNonLocalReturnNode expression: one.	throwTwo := PjNonLocalReturnNode expression: two.	throwThree := PjNonLocalReturnNode expression: three.	throwNil := PjNonLocalReturnNode expression: nilNode.	throwSelf := PjNonLocalReturnNode expression: selfNode.	foo := PjLiteralValueNode value: 'foo'.	ClassVarForTest := PjClassVariableNode identifier: 'ClassVarForTest'.	iv1ForTest := PjInstanceVariableNode identifier: #iv1ForTest.	iv2ForTest := PjInstanceVariableNode identifier: #iv2ForTest.! !!PjAbstractAstTest methodsFor: 'checking'!simpleBlock: objectOrCollection locals: anArray	^ PjBlockNode 		parameters: #()		locals: anArray		body: objectOrCollection! !!PjAstConverterTest class methodsFor: 'testing'!isAbstract 	^ self = PjAstConverterTest! !!PjAstConverterTest methodsFor: 'checking'!assertContentsOf: aBlock convertsTo: expectedJsAst	| actualJsAst |	actualJsAst := self convertFirstStatementOfBlock: aBlock.	self assert: actualJsAst equals: expectedJsAst.! !!PjAstConverterTest methodsFor: 'checking'!assertMethod: methodSymbol convertsTo: expectedJsAst	| actualJsAst |	actualJsAst := converter convertFirstStatementOfBlock: (PjClassForAstConversionTest>>methodSymbol) ast.	self assert: actualJsAst equals: expectedJsAst.! !!PjAstConverterTest methodsFor: 'checking'!convertFirstStatementOfBlock: aBlock	^ converter convertFirstStatementOfBlock: aBlock firstAstNode! !!PjAstConverterTest methodsFor: 'test mock'!discoveredMessage: aString	" just here so tests don't fail "! !!PjAstConverterTest methodsFor: 'accessing'!discoveredReferenceToClass: aClass! !!PjAstConverterTest methodsFor: 'checking'!failConverting: aBlock	self should: [ self convertFirstStatementOfBlock: aBlock ] raise: Exception! !!PjAstConverterTest methodsFor: 'running'!setUp	super setUp.	converter := PjAstConverter new transpiler: self;yourself.! !!PjBasicConverterTest methodsFor: 'test mock'!addPoolReference: aClass 	^ 'mock$'! !!PjBasicConverterTest methodsFor: 'tests'!testArray	| x |	x := PjTempVariableNode identifier: #x.	self assertContentsOf: [ {1. 2. x foo} ] convertsTo: (PjArrayNode expressions: { one. two. self apply: x selector: #foo }).	self assertContentsOf: [ #(1 2 x) ] convertsTo: (PjArrayNode expressions: { one. two. PjLiteralValueNode value: #x })! !!PjBasicConverterTest methodsFor: 'tests'!testBlockBasics	| expectedAst xVariable assignment returnAssignment blockReturningOne |	self assertContentsOf: [ nil ] convertsTo: nilNode.	expectedAst := self simpleBlock: returnNil locals: #().	self assertContentsOf: [ [  ] ] convertsTo: expectedAst.	expectedAst := PjBlockNode		parameters: #(a1 a2)		locals: #(t1 t2 t3)		body: {returnNil}.	self		assertContentsOf: [ [ :a1 :a2 | 			| t1 t2 t3 |			 ] ]		convertsTo: expectedAst.	expectedAst := self simpleBlock: returnOne locals: #().	self assertContentsOf: [ [ 1 ] ] convertsTo: expectedAst.	xVariable := PjTempVariableNode identifier: #x.	assignment := PjAssignNode target: xVariable expression: two.	returnAssignment := PjReturnNode expression: assignment.	expectedAst := PjBlockNode		parameters: #()		locals: #(x)		body: {returnAssignment}.	self		assertContentsOf: [ [ | x |			x := 2 ] ]		convertsTo: expectedAst.	blockReturningOne := PjBlockNode		parameters: #()		locals: #()		body:			{one.			returnOne}.	expectedAst := PjBlockNode		parameters: #()		locals: #()		body:			{blockReturningOne.			returnOne}.	self		assertContentsOf: [ [ [ 1.			1 ].			1 ] ]		convertsTo: expectedAst! !!PjBasicConverterTest methodsFor: 'tests'!testBlockNonLocalReturns	| expectedAst innerBlockAst |	expectedAst := self simpleBlock: {throwOne} locals: #().	self assertContentsOf: [ [ ^ 1 ] ] convertsTo: expectedAst.	innerBlockAst := self simpleBlock: {throwTwo} locals: #().	expectedAst := self		simpleBlock:			{innerBlockAst.			throwOne}		locals: #().	self		assertContentsOf: [ [ [ ^ 2 ].			^ 1 ] ]		convertsTo: expectedAst.	converter preventNonLocalReturns.	self failConverting: [ [ ^ 1 ] ].	self failConverting: [ [ [ ^ 2 ] ] ].	self		failConverting: [ [ [  ].			[ ^ 2 ] ] ]! !!PjBasicConverterTest methodsFor: 'tests'!testBlockRelatedFlags	self deny: converter isInBlock.	self deny: converter hasInBlockSelfReferences.	self deny: converter hasNonLocalReturns.	self convertFirstStatementOfBlock: [ [self ] ].	self assert: converter hasInBlockSelfReferences.	self deny: converter isInBlock.	self deny: converter hasNonLocalReturns.		self convertFirstStatementOfBlock: [ [^1 ] ].	self deny: converter hasInBlockSelfReferences.	self deny: converter isInBlock.	self assert: converter hasNonLocalReturns.	self convertFirstStatementOfBlock: [ [1 ] ].	self deny: converter hasInBlockSelfReferences.	self deny: converter isInBlock.	self deny: converter hasNonLocalReturns.! !!PjBasicConverterTest methodsFor: 'tests'!testBlockReturns	| expectedAst innerBlockAst |	expectedAst := self		simpleBlock:			{three.			two.			returnOne}		locals: #().	self		assertContentsOf: [ [ 3.			2.			1 ] ]		convertsTo: expectedAst.	innerBlockAst := self simpleBlock: {returnOne} locals: #().	expectedAst := self		simpleBlock:			{three.			two.			(PjReturnNode expression: innerBlockAst)}		locals: #().	self		assertContentsOf: [ [ 3.			2.			[ 1 ] ] ]		convertsTo: expectedAst.	innerBlockAst := self simpleBlock: throwOne locals: #().	expectedAst := self		simpleBlock:			{three.			two.			(PjReturnNode expression: innerBlockAst)}		locals: #().	self		assertContentsOf: [ [ 3.			2.			[ ^ 1 ] ] ]		convertsTo: expectedAst! !!PjBasicConverterTest methodsFor: 'tests'!testExpressionNonLocalReturns	| expectedAst  |	expectedAst := PjArrayNode expressions: {throwOne}.	self assertContentsOf: [ { ^1 } ] convertsTo: expectedAst.	converter preventNonLocalReturns.	self failConverting: [ { ^1 } ].! !!PjBasicConverterTest methodsFor: 'tests'!testInteger	self assertContentsOf: [ 1 ] convertsTo: one! !!PjBasicConverterTest methodsFor: 'tests'!testLiteralArrayOfIntegers	| literalNodes |	literalNodes := #(3 5 21) collect: [ : each | PjLiteralValueNode value: each ].	self assertContentsOf: [ #(3 5 21) ] convertsTo: (PjArrayNode expressions: literalNodes)! !!PjBasicConverterTest methodsFor: 'tests'!testMessageWithoutOptimizationManager	| expectedAst |	expectedAst := self apply: three selector: #foo.	self assertContentsOf: [ 3 foo ] convertsTo: expectedAst.! !!PjBasicConverterTest methodsFor: 'tests'!testMethodBasic1	| expectedAst |	expectedAst := PjMethodNode		methodName: #basic1		body:			{one.			returnSelf}.	self assertMethod: #basic1 convertsTo: expectedAst! !!PjBasicConverterTest methodsFor: 'tests'!testMethodBasic2	| expectedAst |	expectedAst := PjMethodNode		methodName: #basic2		body: {returnOne}.	self assertMethod: #basic2 convertsTo: expectedAst! !!PjBasicConverterTest methodsFor: 'tests'!testMethodBasic3	| expectedBody expectedAst |	expectedBody := {(PjUnparsedStringNode string: 'return 3')}.	expectedAst := PjMethodNode		methodName: #basic3		body: expectedBody.	self assertMethod: #basic3 convertsTo: expectedAst! !!PjBasicConverterTest methodsFor: 'tests'!testMethodBasic4	| expectedBody expectedAst |	expectedBody := {three.	(self		simpleBlock:			{two.			returnOne}		locals: #()).	returnSelf}.	expectedAst := PjMethodNode methodName: #basic4 body: expectedBody.	self assertMethod: #basic4 convertsTo: expectedAst! !!PjBasicConverterTest methodsFor: 'tests'!testMethodBasic5	| expectedBody expectedAst |	expectedBody := {three.	(PjReturnNode		expression:			(self				simpleBlock:					{two.					returnOne}				locals: #()))}.	expectedAst := PjMethodNode methodName: #basic5 body: expectedBody.	self assertMethod: #basic5 convertsTo: expectedAst! !!PjBasicConverterTest methodsFor: 'tests'!testMethodBasic6	| expectedBody expectedAst |	expectedBody := {(self		simpleBlock:			{two.			returnOne}		locals: #()).	three.	returnSelf}.	expectedAst := PjMethodNode methodName: #basic6 body: expectedBody.	self assertMethod: #basic6 convertsTo: expectedAst! !!PjBasicConverterTest methodsFor: 'tests'!testReadWriteClassVariables	| astAssignment classVar |	converter classForConversion: PjAbstractAstTest.	classVar := (PjClassVariableNode identifier: #ClassVarForTest) poolReference: PjAbstractAstTest;myClass: PjAbstractAstTest.	self assertContentsOf: [ ClassVarForTest ] convertsTo: classVar.	astAssignment := PjAssignNode 		target:  classVar		expression: classVar.	self assertContentsOf: [ ClassVarForTest := ClassVarForTest ] convertsTo: astAssignment.! !!PjBasicConverterTest methodsFor: 'tests'!testReadWriteInstanceVariables	| astAssignment |	self assertContentsOf: [ iv1ForTest ] convertsTo: (PjFieldNode target: selfNode selectorNode: iv1ForTest isNonNil: true).	astAssignment := PjAssignNode 		target:  (PjFieldNode target: selfNode selectorNode: iv1ForTest isNonNil: true) 		expression: (PjFieldNode target: selfNode selectorNode: iv2ForTest isNonNil: true).	self assertContentsOf: [ iv1ForTest := iv2ForTest ] convertsTo: astAssignment.! !!PjBasicConverterTest methodsFor: 'tests'!testReadWriteVariable	| astAssignment |	self assertContentsOf: [ |x| x ] convertsTo: (PjTempVariableNode identifier: #x).	astAssignment := PjAssignNode 		target:  (PjTempVariableNode identifier: #x) 		expression: (PjTempVariableNode identifier: #y).	self assertContentsOf: [ |x y| x := y ] convertsTo: astAssignment.! !!PjBasicConverterTest methodsFor: 'tests'!testSelf	self assertContentsOf: [ self ] convertsTo: selfNode! !!PjBasicConverterTest methodsFor: 'tests'!testSpecialVariables	| expectedAst |	expectedAst := self apply: (PjClassNode identifier: #Number) selector: #one.	self assertContentsOf: [ Number one ] convertsTo: expectedAst.	expectedAst := self apply: PjSuperNode new selector: #value.	self assertContentsOf: [ super value ] convertsTo: expectedAst.	self failConverting: [ thisContext  ]! !!PjSpecialMessagesConversionTest methodsFor: 'running'!setUp	super setUp.	messageConverter := converter messageConverter.! !!PjSpecialMessagesConversionTest methodsFor: 'tests'!testCascade	| temp assignment |	messageConverter addAllConversions: { PjJsAtConversion. PjJsAtPutConversion}.	temp := PjTempVariableNode identifier: '$1'.	assignment := PjAssignNode		target: temp		expression: (PjApplyNode				func: (PjFieldNode						target: (PjApplyNode receiver: selfNode selector: #testCascade args: #())						selectorNode: nil						isNonNil: false)				args: nil).	self		assertContentsOf: [ self testCascade js_at:  1; js_at:  3 put: 1; js_at:  2 ]		convertsTo: (PjSequenceNode expressions: {				assignment.				PjFieldNode target:  temp selectorNode: one isNonNil: true.				PjAssignNode target: (PjFieldNode target:  temp selectorNode: three isNonNil: true) expression: one.				PjFieldNode target:  temp selectorNode: two isNonNil: true.			})! !!PjSpecialMessagesConversionTest methodsFor: 'tests'!testJsAt	messageConverter addConversion: PjJsAtConversion.	self assertContentsOf: [ self js_at:  3 ] convertsTo: (PjFieldNode target: selfNode selectorNode: three isNonNil: true)! !!PjSpecialMessagesConversionTest methodsFor: 'tests'!testJsAtPut	messageConverter addConversion: PjJsAtPutConversion.	self assertContentsOf: [ self js_at:  3 put: 2] convertsTo: (PjAssignNode target: (PjFieldNode target: selfNode selectorNode: three isNonNil: true) expression: two)! !!PjSpecialMessagesConversionTest methodsFor: 'tests'!testJsThis	messageConverter addConversion: PjJsThisConversion.	self assertContentsOf: [ self js_this ] convertsTo: (PjGlobalNode identifier: #this)! !!PjSpecialMessagesConversionTest methodsFor: 'tests'!testMessageConversionPerformed	messageConverter addAllConversions: (#(2 6 4) collect: [ : i | PjNullMessageConversionForTest new order: i selector: #foo]).	self assertContentsOf: [ 3 foo ] convertsTo: 4.! !!PjAstTest methodsFor: 'tests'!testAstArraySimilarility	| astArray1 astArray2 astArray3 astArray4 astArray5 |	astArray1 := PjArrayNode expressions: { one. two. three }.	astArray2 := PjArrayNode expressions: { three. two. one }.	astArray3 := PjArrayNode expressions: { three. one }.	astArray4 := PjArrayNode expressions: astArray1 expressions, { selfNode }.	astArray5 := PjArrayNode expressions: { selfNode }, astArray2 expressions.	{astArray1. astArray2. astArray3} do: [ : astArray |		self assert: (astArray isSimilarTo: astArray)].	self assert: (astArray1 isSimilarTo: astArray2).	self deny: (astArray1 isSimilarTo: astArray3).	self deny: (astArray2 isSimilarTo: astArray3).	self deny:  (astArray4 isSimilarTo: astArray5).! !!PjAstTest methodsFor: 'tests'!testAstMessageSimilarility		| astArray1 astArray2 astArray3 astCall1 astCall2 astCall3 astCall4 astCall5 |	astArray1 := PjArrayNode expressions: { one. two. three }.	astArray2 := PjArrayNode expressions: { three. two. one }.	astArray3 := PjArrayNode expressions: { three. one }.		astCall1 := PjApplyNode receiver: selfNode selector: #selector1: args: astArray1 expressions.	astCall2 := PjApplyNode receiver: selfNode selector: #selector1: args: astArray2 expressions.	astCall3 := PjApplyNode receiver: selfNode selector: #selector2: args: astArray1 expressions.	astCall4 := PjApplyNode receiver: one selector: #selector1: args: astArray1 expressions.	astCall5 := PjApplyNode receiver: selfNode selector: #selector1: args: astArray3 expressions.	{astCall1. astCall2. astCall3. astCall4. astCall5} do: [ :  astCall |		self assert: (astCall isSimilarTo: astCall)].	self assert: (astCall1 isSimilarTo: astCall2).	self deny: (astCall1 isSimilarTo: astCall3).	self deny: (astCall2 isSimilarTo: astCall3).	self deny:  (astCall1 isSimilarTo: astCall4).	self deny:  (astCall1 isSimilarTo: astCall5).	self deny:  (astCall3 isSimilarTo: astCall4).	self deny:  (astCall3 isSimilarTo: astCall5).	self deny:  (astCall4 isSimilarTo: astCall5).! !!PjAstTest methodsFor: 'tests'!testAstSelfSimilarility	self assert: (selfNode isSimilarTo: PjSelfNode new). "keep the creation"	self deny: (selfNode isSimilarTo: two).	self deny: (two isSimilarTo: selfNode).! !!PjStringGenerationTest class methodsFor: 'accessing'!classVariablesHolderName	^ PjStringGenerator classVariablesHolderName! !!PjStringGenerationTest methodsFor: 'asserting'!assert: aPjJavascriptAstNode asStringEquals: aString	self		assert: (self generator asString: aPjJavascriptAstNode)		equals: aString! !!PjStringGenerationTest methodsFor: 'accessing'!classVariablesHolderName	^ self class classVariablesHolderName! !!PjStringGenerationTest methodsFor: 'asserting'!generator	^ PjStringGenerator new transpiler: self! !!PjStringGenerationTest methodsFor: 'accessing'!nilTestFunctionName	^PjStringGenerator nilTestFunctionName! !!PjStringGenerationTest methodsFor: 'test mock'!poolReference: anUndefinedObject for: anUndefinedObject2	^ PjTranspiler classVarsPoolName! !!PjStringGenerationTest methodsFor: 'accessing'!selectorsPrefix	^ '_'! !!PjStringGenerationTest methodsFor: 'tests'!testArray	| x |	x := PjTempVariableNode identifier: #x.	self		assert: (PjArrayNode expressions: { one. two. self apply: x selector: #foo })		asStringEquals: '[1,2,$asNil$(x)._foo()]'.! !!PjStringGenerationTest methodsFor: 'tests'!testBlock	self		assert: (PjBlockNode parameters: #(a for) locals: #(d in) body: {				PjAssignNode					target: (PjTempVariableNode identifier: #in)					expression: (PjArgumentNode identifier: #for).				PjReturnNode expression: (PjArgumentNode identifier: #a)			})		asStringEquals: '((a,$for)=>{var d,$in;$in=$for;return a})'.! !!PjStringGenerationTest methodsFor: 'tests'!testClassCall	self		assert: (self apply: (PjClassNode identifier: #Number) selector: #one)		asStringEquals: 'Number._one()'! !!PjStringGenerationTest methodsFor: 'tests'!testClassVariables	| astAssignment classVar |	classVar := PjClassVariableNode identifier: #ClassVarForTest.	astAssignment := PjAssignNode target: classVar expression: classVar.	self		assert: astAssignment		asStringEquals: 'cp$.ClassVarForTest=cp$.ClassVarForTest'.	self		assert:			(self generator				currentClass: self class;				asString: astAssignment)		equals: 'cp$.ClassVarForTest=cp$.ClassVarForTest'.	self		assert:			(self generator				currentClass: self class class;				asString: astAssignment)		equals: 'cp$.ClassVarForTest=cp$.ClassVarForTest'.	classVar myClass: self class class.	self		assert:			(self generator				currentClass: self class class;				asString: astAssignment)		equals: 'cp$.ClassVarForTest=cp$.ClassVarForTest'! !!PjStringGenerationTest methodsFor: 'tests'!testField	| x bar |	x := PjTempVariableNode identifier: #x.	bar := PjMessageSelectorNode identifier: #bar.	self		assert: (PjFieldNode target: selfNode selectorNode: foo isNonNil: true)		asStringEquals: 'this.foo'.	self		assert: (PjApplyNode func: (PjFieldNode target: (PjFieldNode target: selfNode selectorNode: foo isNonNil: true)  selectorNode: bar isNonNil: false) args: #())		asStringEquals: self nilTestFunctionName,'(this.foo)._bar()'.	self		assert: (PjFieldNode target: x selectorNode: foo isNonNil: false)		asStringEquals: self nilTestFunctionName,'(x).foo'.	self		assert: (PjFieldNode target: pi selectorNode: foo isNonNil: true)		asStringEquals: '3.1415926.foo'.	self		assert: (PjFieldNode target: three selectorNode: foo isNonNil: true)		asStringEquals: '(3).foo'.	self		assert: (PjFieldNode target: foo selectorNode: bar isNonNil: true)		asStringEquals: '"foo"._bar'.	self		assert: (PjFieldNode target: (PjVariableNode identifier: #x) selectorNode: foo isNonNil: false)		asStringEquals: self nilTestFunctionName,'(x).foo'! !!PjStringGenerationTest methodsFor: 'tests'!testFieldForCall	| x |	x := PjTempVariableNode identifier: #x.	self		assert: (self apply: selfNode selector: #foo) 		asStringEquals: 'this._foo()'.	self		assert: (self apply: three selector: #foo) 		asStringEquals: '(3)._foo()'.	self		assert: (self apply: pi selector: #foo) 		asStringEquals: '3.1415926._foo()'.	self		assert: (self apply: selfNode selector: PjStringGenerator jsNativePrefix,#foo:)		asStringEquals: 'this.foo()'.	self		assert: (self apply: selfNode selector: #bar:)		asStringEquals: 'this._bar_()'.	self		assert: (self apply: selfNode selector: #<=)		asStringEquals: 'this._60_61_()'.	self		assert: (PjApplyNode func: (PjFieldNode target: selfNode selectorNode: nil isNonNil: true) args: nil)		asStringEquals: 'this'.	self		assert: (PjApplyNode func: (PjFieldNode target: x selectorNode: nil isNonNil: false) args: nil)		asStringEquals: self nilTestFunctionName,'(x)'.	self		assert: (PjApplyNode func: (PjFieldNode target: (PjFieldNode target: selfNode selectorNode: iv1ForTest isNonNil: true) selectorNode: nil isNonNil: false) args: nil)		asStringEquals: self nilTestFunctionName,'(this.iv1ForTest)'! !!PjStringGenerationTest methodsFor: 'tests'!testGlobalCall	self		assert: (self apply: (PjGlobalNode identifier: #Number) selector: #one)		asStringEquals: self nilTestFunctionName,'(Number)._one()'! !!PjStringGenerationTest methodsFor: 'tests'!testLiteral	self assert: (PjLiteralValueNode value: 42) asStringEquals: '42'.	self assert: (PjLiteralValueNode value: '42') asStringEquals: '"42"'.	self assert: (PjLiteralValueNode value: $x) asStringEquals: '"x"'.	self assert: (PjLiteralValueNode value: nil) asStringEquals: 'null'.	self assert: (PjLiteralValueNode value: (String with: (Character value: 7)),'a\b"x',(String with: Character null)) asStringEquals: '"\x07a\\b\"\rx\x00"'.	self assert: (PjLiteralValueNode value: 'a\b"',(String with: (Character value:257)) ) asStringEquals: '"a\\b\"\u0101"'.	self assert: (PjLiteralValueNode value: (String with: Character null),'a\b"xy',(String with: (Character value:257)) ) asStringEquals: '"\x00a\\b\"\rx\u3088\u3046\u3053\u305Dy\u0101"'.! !!PjStringGenerationTest methodsFor: 'tests'!testMethod	self		assert:			(PjMethodNode				parameters: #(#a #for)				locals: #(#d #in)				body:					{(PjAssignNode						target: (PjTempVariableNode identifier: #in)						expression: (PjArgumentNode identifier: #for)).					(PjReturnNode expression: (PjArgumentNode identifier: #a))}				methodName: #foo				needsSelf: false				isClassMethod: false)		asStringEquals: '_foo(a,$for){var d,$in;$in=$for;return a}'.	self		assert:			(PjMethodNode				parameters: #(#a)				locals: #(#d)				body:					{(PjAssignNode						target: (PjTempVariableNode identifier: #d)						expression:							(PjArrayNode								expressions:									{PjBlockNode										parameters: #()										locals: #()										body:											{one.											two}})).					(PjReturnNode expression: (PjArgumentNode identifier: #a))}				methodName: #foo				needsSelf: false				isClassMethod: false)		asStringEquals: '_foo(a){var d;d=[()=>{1;2}];return a}'! !!PjStringGenerationTest methodsFor: 'tests'!testObject	self		assert: (PjObjectNode dictionary: { #a -> selfNode. #* -> nilNode } asDictionary)		asStringEquals: '{"*":null,a:this}'.! !!PjStringGenerationTest methodsFor: 'tests'!testOperatorPrecedence	self assert: (PjBinaryNode operator: #+ left: (PjBinaryNode operator: #+ left: two right: three) right: one) asStringEquals: '2+3+1'.	self assert: (PjBinaryNode operator: #+ left: (PjBinaryNode operator: #- left: two right: three) right: one) asStringEquals: '2-3+1'.	self assert: (PjBinaryNode operator: #- left: (PjBinaryNode operator: #+ left: two right: three) right: one) asStringEquals: '2+3-1'.	self assert: (PjBinaryNode operator: #- left: ((PjAssignNode target: (PjTempVariableNode identifier: #x) expression:  two)) right: one) asStringEquals: '(x=2)-1'.	self assert: (PjBinaryNode operator: #* left: (PjBinaryNode operator: #* left: two right: three) right: one) asStringEquals: '2*3*1'.	self assert: (PjBinaryNode operator: #+ left: (PjBinaryNode operator: #* left: two right: three) right: one) asStringEquals: '2*3+1'.	self assert: (PjBinaryNode operator: #+ left: two right: (PjBinaryNode operator: #* left: three right: one)) asStringEquals: '2+3*1'.	self assert: (PjBinaryNode operator: #* left: (PjBinaryNode operator: #+ left: two right: three) right: one) asStringEquals: '(2+3)*1'.	self assert: (PjBinaryNode operator: #* left: two right: (PjBinaryNode operator: #/ left:  (PjBinaryNode operator: #+ left: three right: one) right: (PjBinaryNode operator: #- left: (PjLiteralValueNode value: 5) right: (PjLiteralValueNode value: 6)))) asStringEquals: '2*(3+1)/(5-6)'..	self assert: (PjBinaryNode operator: #+ left: two right: (PjBinaryNode operator: #- left:  (PjBinaryNode operator: #* left: three right: one) right: (PjBinaryNode operator: #/ left: (PjLiteralValueNode value: 5) right: (PjLiteralValueNode value: 6)))) asStringEquals: '2+3*1-5/6'! !!PjStringGenerationTest methodsFor: 'tests'!testOptimizedJsX	self		assert: (PjGlobalNode identifier: #this)		asStringEquals: 'this'.	self		assert: ((PjAssignNode target: (PjFieldNode target: selfNode selectorNode: three isNonNil: true) expression: two))		asStringEquals: 'this[3]=2'.	self		assert: ((PjAssignNode target: (PjFieldNode target: selfNode selectorNode: foo isNonNil: true) expression: two))		asStringEquals: 'this.foo=2'.	self		assert: ((PjAssignNode target: (PjFieldNode target: selfNode selectorNode: (PjLiteralValueNode value: 'a$b_c') isNonNil: true) expression: two))		asStringEquals: 'this.a$b_c=2'.	self		assert: ((PjAssignNode target: (PjFieldNode target: selfNode selectorNode: (PjLiteralValueNode value: 'a.b') isNonNil: true) expression: two))		asStringEquals: 'this["a.b"]=2'! !!PjStringGenerationTest methodsFor: 'tests'!testPoolVariables	| astAssignment poolVar |	poolVar := (PjPoolVariableNode identifier: #PoolVarForTest)		poolReference: PjBrowserGlobals.	astAssignment := PjAssignNode target: poolVar expression: poolVar.	self		assert: astAssignment		asStringEquals: 'cp$.PoolVarForTest=cp$.PoolVarForTest'.	self		assert:			(self generator				currentClass: self class;				asString: astAssignment)		equals: 'cp$.PoolVarForTest=cp$.PoolVarForTest'.	self		assert:			(self generator				currentClass: self class class;				asString: astAssignment)		equals: 'cp$.PoolVarForTest=cp$.PoolVarForTest'.	poolVar myClass: self class class.	self		assert:			(self generator				currentClass: self class class;				asString: astAssignment)		equals: 'cp$.PoolVarForTest=cp$.PoolVarForTest'! !!PjStringGenerationTest methodsFor: 'tests'!testReservedWords	self		assert: (PjFieldNode target: selfNode selectorNode: (PjInstanceVariableNode identifier: #in ) isNonNil: true)		asStringEquals: 'this.in'.	self		assert: (PjTempVariableNode identifier: #prototype )		asStringEquals: 'prototype'.	self		assert: (PjTempVariableNode identifier: #for )		asStringEquals: '$for'.	self		assert: (PjArgumentNode identifier: #prototype )		asStringEquals: 'prototype'.	self		assert: (PjArgumentNode identifier: #for )		asStringEquals: '$for'.	self		assert: (PjGlobalNode identifier: #prototype )		asStringEquals: 'prototype'.	self		assert: (PjGlobalNode identifier: #for )		asStringEquals: 'for'.	self		assert: (PjClassNode identifier: #prototype )		asStringEquals: 'prototype'.	self		assert: (PjClassNode identifier: #for )		asStringEquals: 'for'.	self		assert: ((PjClassVariableNode identifier: #prototype) myClass: self class)		asStringEquals: 'cp$.$prototype'.	self		assert: (PjClassVariableNode identifier: #for )		asStringEquals: 'cp$.for'.	self		assert: (PjInstanceVariableNode identifier: #while )		asStringEquals: '.while'.	self		assert: (PjInstanceVariableNode identifier: #constructor )		asStringEquals: '.$constructor'.	self		assert: (PjInstanceVariableNode identifier: #prototype )		asStringEquals: '.$prototype'.! !!PjStringGenerationTest methodsFor: 'tests'!testReturn	self assert: returnThree  asStringEquals: 'return 3'! !!PjStringGenerationTest methodsFor: 'tests'!testSelf	self assert: selfNode asStringEquals: 'this'.	self		assert: (self apply: (PjSelfNode myClass: Integer) selector: #value)		asStringEquals: 'this._value()'.	self		assert: (self apply: (PjSelfNode inBlock: true) selector: #value)		asStringEquals: PjStringGenerator selfName,'._value()'! !!PjStringGenerationTest methodsFor: 'tests'!testSuperCall	self		assert: (self apply: (PjSuperNode myClass: Integer) selector: #value)		asStringEquals: 'super._value()'.	self		assert: (self apply: ((PjSuperNode myClass: Integer class) inBlock: true) selector: #value)		asStringEquals: 'super._value()'! !!PjStringGenerationTest methodsFor: 'tests'!testTry	self		assert: (PjTryNode body: throwThree)		asStringEquals: 'var ', PjStringGenerator nonLocalReturnVariableName, '={};try{throw $_err_$=3}catch(e){if(e===', PjStringGenerator nonLocalReturnVariableName, ')return e;throw e}'! !!PjStringGenerationTest methodsFor: 'tests'!testUnparsedString	self		assert: (PjUnparsedStringNode string: 'a.b^c')		asStringEquals: 'a.b^c'.! !!PjBlockTranspilationSupportTest methodsFor: 'tests'!assertBlock: block externalVarValues: valuesDict	| context actualTempValue variable allVariables scope |	context := block originalBlock asContext.	scope := block originalBlock outerContext sourceNode scope.	allVariables := scope allTemps.	valuesDict keysDo: [ :tempName | 		variable := allVariables detect: [ : each | each name = tempName ].		actualTempValue := variable valueStartAtContext: context.		self			assert: actualTempValue			equals: (valuesDict at: tempName) ]! !!PjBlockTranspilationSupportTest methodsFor: 'tests'!innerClosedBlock: x	| y |	y := 23.	^  [: other | [:v| |w| {v.w.x.y.instVar.123. other}] asClosedBlock] value: 986! !!PjBlockTranspilationSupportTest methodsFor: 'tests'!openBlock: x	| y |	y := 23.	^  [:v| |w| {v.w.x.y.instVar.123}]! !!PjBlockTranspilationSupportTest methodsFor: 'tests'!test0ArgBlock1ExtenalVarLevel1	| block x valuesDict  |	valuesDict := { #x -> 1337.} asDictionary.	x := valuesDict at: #x.	block := [ x + 1 ].	self assertBlock: block externalVarValues: valuesDict ! !!PjBlockTranspilationSupportTest methodsFor: 'tests'!test0ArgBlock2ExternalVarsLevel1	| block x a valuesDict |	valuesDict := { 		              (#x -> 1337).		              (#a -> 42) } asDictionary.	x := valuesDict at: #x.	instVar := 1066.	a := valuesDict at: #a.	block := [ 	         | w |	         { 		         a.		         w.		         x.		         instVar.		         123 } ].	self assertBlock: block externalVarValues: valuesDict! !!PjBlockTranspilationSupportTest methodsFor: 'tests'!test1ArgBlock1ExternalVarLevel1		| block x valuesDict  |	valuesDict := { #x -> 1337.} asDictionary.	x := valuesDict at: #x.	block := [: a | x + 1 ].	self assertBlock: block externalVarValues: valuesDict ! !!PjBlockTranspilationSupportTest methodsFor: 'tests'!test1ArgBlock2ExternalVarsLevel1	| block x a valuesDict |	valuesDict := { 		              (#x -> 1337).		              (#a -> 42) } asDictionary.	x := valuesDict at: #x.	instVar := 1066.	a := valuesDict at: #a.	block := [ :v | 	         | w |	         { 		         a.		         v.		         w.		         x.		         instVar.		         123 } ].	self assertBlock: block externalVarValues: valuesDict! !!PjBlockTranspilationSupportTest methodsFor: 'tests'!test1ArgBlock3ExternalVarsLevel2	| block x a valuesDict |	valuesDict := { 		              (#x -> 1337).		              (#a -> 42).		              (#y -> 91) } asDictionary.	x := valuesDict at: #x.	instVar := 1066.	a := valuesDict at: #a.	block := [ :y | 	         [ :v | 	         | w |	         { 		         a.		         v.		         w.		         x.		         y.		         instVar.		         123 } ] ] value: (valuesDict at: #y).	self assertBlock: block externalVarValues: valuesDict.	self should: [(block externalVariablesDict at: #block) signal] raise: PjJavascriptTranspilationError ! !!PjBlockTranspilationSupportTest methodsFor: 'tests'!test1ArgClosedBlock3ExternalVarsLevel2	| outerBlock x a valuesDict closedBlock |	valuesDict := { 		              (#x -> 1337).		              (#a -> 42).		              (#y -> 91) } asDictionary.	x := valuesDict at: #x.	instVar := 1066.	a := valuesDict at: #a.	outerBlock := [ :y | 	              [ :v | 	              | w |	              { 		              a.		              v.		              w.		              x.		              y.		              instVar.		              123 } ] asClosedBlock ].	closedBlock := outerBlock value: (valuesDict at: #y).	self assertBlock: closedBlock externalVarValues: valuesDict.	self		assert: (closedBlock externalVariablesDict at: #outerBlock)		identicalTo: outerBlock.	self		assert: (closedBlock externalVariablesDict at: #closedBlock) isNil! !!PjBlockTranspilationSupportTest methodsFor: 'tests'!test1ArgClosedBlockLevel1CreatedByAnotherMethod	| closedBlock |	closedBlock := (self openBlock: 42) asClosedBlock.	self assertBlock: closedBlock externalVarValues: { #x -> 42. #y ->23 } asDictionary ! !!PjBlockTranspilationSupportTest methodsFor: 'tests'!test1ArgClosedBlockLevel2CreatedByAnotherMethod	| closedBlock |	closedBlock := self innerClosedBlock: 42.	self assertBlock: closedBlock externalVarValues: { #x -> 42. #y ->23. #other -> 986 } asDictionary ! !!PjClassNamingTest methodsFor: 'tests'!testClassNeedsCreation	self deny: Object needsClassDeclaration.	self deny: BlockClosure needsClassDeclaration.	self assert: UndefinedObject needsClassDeclaration.! !!PjClassSortingTest methodsFor: 'tests'!assert: aClass isBefore: bClass	self assert: (self should: aClass initializeBefore: bClass).	self deny: (self should: bClass initializeBefore: aClass)! !!PjClassSortingTest methodsFor: 'tests'!assert: aClass isUnrelatedTo: bClass	self deny: (self should: aClass initializeBefore: bClass).	self deny: (self should: bClass initializeBefore: aClass)! !!PjClassSortingTest methodsFor: 'tests'!checkInheritanceOrdered: sorted	sorted		withIndexDo: [ :first :index | 			index + 1 to: sorted size do: [ :secondIndex | 				| second |				second := sorted at: secondIndex.				self					assert: ((second inheritsFrom: first) or: [ (first inheritsFrom: second) not ]) ] ]! !!PjClassSortingTest methodsFor: 'tests'!checkInitializationOrdered: sorted	sorted		withIndexDo: [ :first :index | 			index + 1 to: sorted size do: [ :secondIndex | 				| second |				second := sorted at: secondIndex.				self					assert: ((self does: second reference: first) or: [ (self does: first reference: second) not ]) ] ]! !!PjClassSortingTest methodsFor: 'tests'!does: classB reference: classA	| classesReferencingA |	classesReferencingA := cache at: classA ifAbsentPut: [ 		                       | methodsReferencingA |		                       methodsReferencingA := SystemNavigation 			                                              globalRefsForPharoJS:			                                              classA				                                              nameToUseForJsConversion.		                       methodsReferencingA asSet collect: [ :each | 			                       each methodClass instanceSide ] ].	^ (classesReferencingA includes: classB) or: [ 		  classB sharedPools includes: classA ]! !!PjClassSortingTest methodsFor: 'running'!setUp	super setUp.	cache := IdentityDictionary new.	transpiler := PjTranspiler new.! !!PjClassSortingTest methodsFor: 'tests'!should: bClass initializeBefore: aClass	^ transpiler should: bClass occurBefore: aClass with: [ : first : last |		transpiler does: last reference: first ]! !!PjClassSortingTest methodsFor: 'tests'!testClassInheritenceBasedOrdering	| sorted classes |	classes := Object withAllSuperclasses asIdentitySet		, (Object subclasses first: 10) , IdentitySet withAllSuperclasses		, String withAllSuperclasses , SmallInteger withAllSuperclasses.	" all the above have no inheritance (once we remove Object superclasses at the end) "	Object withAllSuperclasses do: [ :each | classes remove: each ].	" now we have a bunch of heirarchies that are mutually incomparable "	sorted := Class superclassOrder: classes.	self checkInheritanceOrdered: sorted.! !!PjClassSortingTest methodsFor: 'tests'!testClassIntializationOrdering	| sorted classes |	classes := {		PjClassForTranspilationTest.		PjSuperClassForTranspilationTest.		PjSharedPoolForTest.		PjClientForInitializationTest.		PjClassDForPackageTranspilationTest.  		PjClassEForPackageTranspilationTest. 		PjClientForJavascriptInitializationTest.		PjClassCForPackageTranspilationTest.		PjProviderForInitializationTest.		PjClassBForPackageTranspilationTest.	}.	sorted := transpiler orderForInitialization: classes.	self checkInitializationOrdered: sorted.	self checkInheritanceOrdered: sorted.! !!PjClassSortingTest methodsFor: 'tests'!testShouldInitializeBefore	| relationships classes |	relationships := {		PjSharedPoolForTest -> PjSuperClassForTranspilationTest.		PjSuperClassForTranspilationTest -> PjClassForTranspilationTest.		PjProviderForInitializationTest -> PjClientForInitializationTest.		PjProviderForInitializationTest -> PjClientForJavascriptInitializationTest.		PjClassBForPackageTranspilationTest -> PjClassCForPackageTranspilationTest.		PjClassBForPackageTranspilationTest -> PjClassDForPackageTranspilationTest.		PjClassBForPackageTranspilationTest -> PjClassEForPackageTranspilationTest.		PjClassDForPackageTranspilationTest -> PjClassEForPackageTranspilationTest.		PjClientForJavascriptInitializationTest -> PjClassForTranspilationTest.	} asSet.	classes := IdentitySet new.	relationships do: [ : assoc |		self assert: assoc key isBefore: assoc value.		classes add: assoc key;add: assoc value	].	classes do: [ : first |		classes do: [ :second |			(first = second or: [(relationships includes: first->second) or: [relationships includes: second->first]]) ifFalse: [				self assert: first isUnrelatedTo: second	]]]! !!PjClosedBlockClosureTest methodsFor: 'tests'!testBlockFreeVariables	|x block closedBlock |	x := 1.	instVar := 42.	block := [x := 99].	self assert: block externalVariablesDict keys asSet equals: #(x instVar block closedBlock testSelector expectedFails) asSet.	closedBlock := block asClosedBlock.	x := 2.	instVar := 17.	self assert: block asClosedBlock externalVariablesDict equals: {#x->x. #instVar->instVar. #block->block. #closedBlock-> closedBlock. #testSelector->testSelector. #expectedFails->expectedFails} asDictionary.	self assert: closedBlock externalVariablesDict equals: {#x->1. #instVar->42. #block->block. #closedBlock-> nil. #testSelector->testSelector. #expectedFails->expectedFails} asDictionary.! !!PjClosedBlockClosureTest methodsFor: 'tests'!testBlockReferencingTempInMethod	|x closedBlock |	x := 1.	closedBlock := [x := 2] asClosedBlock.	closedBlock value.	self assert: x equals: 1.! !!PjClosedBlockClosureTest methodsFor: 'tests'!testClosingClosedBlock	| closedBlock |	closedBlock := [] asClosedBlock.	self assert: closedBlock asClosedBlock == closedBlock.! !!PjClosedBlockClosureTest methodsFor: 'tests'!testNestedBlockReferencingTempInMethod	|x closedBlock |	x := 1.	[closedBlock := [x := 2] asClosedBlock] value.	closedBlock value.	self assert: x equals: 1.! !!PjClosedBlockClosureTest methodsFor: 'tests'!testNestedBlockReferencingTempInOuterBlock	| xBlock closedBlock |	xBlock := [|x|		x := 1.		closedBlock := [x := 2] asClosedBlock.		[x]] value.	closedBlock value.	self assert: xBlock value equals: 1.! !!PjMessageConversionTest methodsFor: 'tests'!addSome	converter addAllConversions: (#(2 6 4) collect: [ : i | PjNullMessageConversionForTest new order: i selector: #foo]).	converter addAllConversions: (#(8 4) collect: [ : i | PjNullMessageConversionForTest new order: i selector: #bar])! !!PjMessageConversionTest methodsFor: 'tests'!convert: selector receiver: aLiteral args: args	| receiverAstNode |	receiverAstNode := RBLiteralNode value: aLiteral.	^converter convert: selector receiver: receiverAstNode args: args! !!PjMessageConversionTest methodsFor: 'tests'!setUp	super setUp.	converter := PjMessageConverter new.! !!PjMessageConversionTest methodsFor: 'tests'!testAdd	self addSome.	self assert: (self convert: #bar receiver: 5 args: #()) equals: 8.	converter addConversion: (PjNullMessageConversionForTest new order: 6 selector: #bar).	self assert: (self convert: #bar receiver: 5 args: #()) equals: 6! !!PjMessageConversionTest methodsFor: 'tests'!testEmpty	self assert: (self convert: #foo receiver: nil args: #()) equals: nil! !!PjMessageConversionTest methodsFor: 'tests'!testRemove	self addSome.	self assert: (self convert: #foo receiver: 3 args: #()) equals: 4.	converter removeConversion: (PjNullMessageConversionForTest new order: 4 selector: #foo).	self assert: (self convert: #foo receiver: 3 args: #()) equals: 6.	self assert: (self convert: #foo receiver: 1 args: #()) equals: 2.	converter removeConversion: (PjNullMessageConversionForTest new order: 6 selector: #foo).	self assert: (self convert: #foo receiver: 3 args: #()) equals: nil! !!PjMessageConversionTest methodsFor: 'tests'!testSome	self addSome.	self assert: (self convert: #foo receiver: 3 args: #()) equals: 4.	self assert: (self convert: #foo receiver: 5 args: #()) equals: 6.	self assert: (self convert: #foo receiver: 1 args: #()) equals: 2.	self assert: (self convert: #foo receiver: 6 args: #()) equals: nil.	self assert: (self convert: #bar receiver: 3 args: #()) equals: 4.	self assert: (self convert: #bar receiver: 5 args: #()) equals: 8.	self assert: (self convert: #bar receiver: 1 args: #()) equals: 4.	self assert: (self convert: #foo receiver: 9 args: #()) equals: nil! !!PjGeneratedClassTranspilationTest class methodsFor: 'accessing'!resources	^{PjClassFactoryTestResource}! !!PjGeneratedClassTranspilationTest methodsFor: 'checking'!assertStCode: methodBodyString convertedIncludes: expectedJsSubstring	self assertStMethodCode:  'm\' withCRs, methodBodyString convertedIncludes: expectedJsSubstring.! !!PjGeneratedClassTranspilationTest methodsFor: 'checking'!assertStMethodCode: methodString convertedIncludes: expectedJsSubstring	| jsCode |	class compile: methodString.	jsCode := self convertClass: class.	self assert: jsCode includes: expectedJsSubstring.! !!PjGeneratedClassTranspilationTest methodsFor: 'accessing'!classFactory	^PjClassFactoryTestResource current classFactory! !!PjGeneratedClassTranspilationTest methodsFor: 'accessing'!defaultClass	^PjClassFactoryTestResource current defaultClass! !!PjGeneratedClassTranspilationTest methodsFor: 'running'!setUp	super setUp.	class := self defaultClass.! !!PjStringWithBlockTranspilationTest methodsFor: 'tests'!testBlock0Arg	self 		assertStCode: '[123]' 		convertedIncludes: '()=>{return 123}'.! !!PjStringWithBlockTranspilationTest methodsFor: 'tests'!testBlock0ArgWithReturn	self 		assertStCode: '[^123]' 		convertedIncludes: '()=>{throw $_err_$=123}'! !!PjStringWithBlockTranspilationTest methodsFor: 'tests'!testBlock1Arg	self 		assertStCode: '[ :x | 123]' 		convertedIncludes: '(x)=>{return 123}'! !!PjStringWithBlockTranspilationTest methodsFor: 'tests'!testBlockAsArgument	self 		assertStCode: '1 to: 10 by: 2 do: [: x | x ]' 		convertedIncludes: '(1)._to_by_do_(10,2,(x)=>{return x})'! !!PjStringWithBlockTranspilationTest methodsFor: 'tests'!testEmptyBlock	self 		assertStCode: '[]' 		convertedIncludes: '()=>{return ', self nilInJavascript, '}'.! !!PjPackageTranspilationTest methodsFor: 'checking'!assert: firstClass classVariablesSetBefore: lastClass	self 		assert: firstClass 		inCodeWith: '.$$def(' 		before: lastClass! !!PjPackageTranspilationTest methodsFor: 'checking'!assert: firstClass inCodeWith: codeString before: lastClass	| firstIndex lastIndex |	firstIndex := self jsCode indexOfSubCollection: firstClass nameToUseForJsConversion, codeString.	self deny: firstIndex = 0.	lastIndex := self jsCode indexOfSubCollection: lastClass nameToUseForJsConversion, codeString.	self assert: firstIndex < lastIndex.! !!PjPackageTranspilationTest methodsFor: 'checking'!assert: firstClass inCodeWithPrefix: codeString before: lastClass	| firstIndex lastIndex |	firstIndex := self jsCode indexOfSubCollection: codeString, firstClass nameToUseForJsConversion.	self deny: firstIndex = 0.	lastIndex := self jsCode indexOfSubCollection: codeString, lastClass nameToUseForJsConversion.	self assert: firstIndex < lastIndex.! !!PjPackageTranspilationTest methodsFor: 'checking'!assert: firstClass initializedBefore: lastClass	self assert: firstClass inCodeWith: '._initialize();' before: lastClass.! !!PjPackageTranspilationTest methodsFor: 'checking'!assertClass: firstClass installedBefore: lastClass	self assert: firstClass inCodeWithPrefix: 'class ' before: lastClass.! !!PjPackageTranspilationTest methodsFor: 'checking'!assertClassExtension: firstClass installedBefore: lastClass	self assert: firstClass inCodeWithPrefix: '},' before: lastClass! !!PjPackageTranspilationTest methodsFor: 'testing'!testCircularClass	self generateJsCodeForClasses: {	PjClassBForCircularTranspilationTest.	}.	self deny: self jsCode includes: '.prototype.__proto__ = '! !!PjPackageTranspilationTest methodsFor: 'testing'!testClientClassUsesJavascriptNameOfReferencedClass	self generateJsCodeForClasses: {	PjClassBForReferenceTranspilationTest.	PjClassAForReferenceTranspilationTest.	}.	self assert: self jsCode includes: PjClassAForReferenceTranspilationTest javascriptName.	self deny: self jsCode includes: PjClassAForReferenceTranspilationTest name.! !!PjPackageTranspilationTest methodsFor: 'testing'!testDnuSetup	self generateJsCodeForClasses: {	PjClassBForCircularTranspilationTest.	}.	self assert: self jsCode includes: '._registerDnuForAll_(["isNil","javascriptName"]);'! !!PjPackageTranspilationTest methodsFor: 'testing'!testDuplicateClasses	| classesToConvert classDefintionString className classInitializationString|	classesToConvert := OrderedCollection new.	3 timesRepeat: [ classesToConvert add: PjClassAForPackageTranspilationTest].	self generateJsCodeForClasses: classesToConvert.	className := PjClassAForPackageTranspilationTest name.	classDefintionString := 'class ', className,' extends'.	classInitializationString := className, '._initialize();'.	{classDefintionString. classInitializationString} do: [:each |		self assert: (jsCode allRangesOfSubstring: each) size equals: 1] .! !!PjPackageTranspilationTest methodsFor: 'testing'!testJavascriptInitializeOverridesClassInitialize	self generateJsCodeForClasses: {	PjClientForJavascriptInitializationTest.	PjProviderForInitializationTest	}.	self assert: self jsCode includes: PjClientForJavascriptInitializationTest name, '._javascriptInitialize()'.	self deny: self jsCode includes: PjClientForJavascriptInitializationTest name, '._initialize()'.	self 		assert: PjProviderForInitializationTest name, '._initialize()'		appearsBefore: PjClientForJavascriptInitializationTest name, '._javascriptInitialize()'! !!PjPackageTranspilationTest methodsFor: 'testing'!testProviderInitializedBeforeClient	self generateJsCodeForClasses: {	PjClassCForPackageTranspilationTest.	PjClassBForPackageTranspilationTest.	PjClassAForPackageTranspilationTest.	}.	self assert: PjClassBForPackageTranspilationTest initializedBefore: PjClassCForPackageTranspilationTest.! !!PjPackageTranspilationTest methodsFor: 'testing'!testProviderInitializedBeforeClientSubclass	self generateJsCodeForClasses: {	PjClassEForPackageTranspilationTest.	PjClassDForPackageTranspilationTest.	PjClassBForPackageTranspilationTest.	PjClassAForPackageTranspilationTest.	}.	self assert: PjClassBForPackageTranspilationTest initializedBefore: PjClassEForPackageTranspilationTest.! !!PjPackageTranspilationTest methodsFor: 'testing'!testSuperclassInitializedBeforeSubclass	self generateJsCodeForClasses: {	PjClassBForPackageTranspilationTest.	PjClassAForPackageTranspilationTest.	}.	self assert: PjClassAForPackageTranspilationTest initializedBefore: PjClassBForPackageTranspilationTest.! !!PjPackageTranspilationTest methodsFor: 'testing'!testSuperclassProtoSetBeforeSubclass	self generateJsCodeForClasses: {	PjClassBForPackageTranspilationTest.	PjClassAForPackageTranspilationTest.	}.	self assertClass: PjClassAForPackageTranspilationTest installedBefore: PjClassBForPackageTranspilationTest.! !!PjPrimitiveTranspilationTest methodsFor: 'testing'!testPrimitiveFailing	self should: [		self generateJsCodeForClasses: {			PjClassForPrimitiveFailingTest.		}	] raise: PjJavascriptTranspilationError description: 'fail for primitive'! !!PjPrimitiveTranspilationTest methodsFor: 'testing'!testPrimitiveWithFallback	self generateJsCodeForClasses: {		PjClassForPrimitiveTest.	}.	self assertInstanceMethod: #+ equals: '(aNumber){return $asNil$(aNumber)._adaptToFloat_andSend_(this,"+")}'! !!PjClassDefinitionTranspilationTest methodsFor: 'accessing'!classToTranspile	^ PjClassForDefinitionTest! !!PjClassDefinitionTranspilationTest methodsFor: 'accessing'!expectedClassName	^self classToTranspile name! !!PjClassDefinitionTranspilationTest methodsFor: 'tests'!testClassDefinedAsConstructor	self assert: self jsCode includes: 'class ', className, ' extends Object{'.! !!PjClassExtensionTranspilationTest methodsFor: 'accessing'!classToTranspile	^ PjClassExtensionForTest! !!PjClassExtensionTranspilationTest methodsFor: 'tests'!testClassExtension	self deny: self jsCode includes: self classToTranspile name.	self deny: self jsCode includes: 'function ', self classToTranspile name, '(){}'.	self deny: self jsCode includes: 'function ', PjClassForTranspilationTest name, '(){}'.	self assert: self jsCode includes: 'instanceMethod'.	PjClassForTranspilationTest selectorsDo: [: selector |		self deny: self jsCode includes: selector]! !!PjClassExtensionTranspilationTest methodsFor: 'tests'!testJavascriptInitialize	self assertClassMethod: #javascriptInitialize equals: '(){return this}'.	self assert: self jsCode includes: PjClassForTranspilationTest name, '._javascriptInitialize()'.! !!PjCoreTranspilationTest methodsFor: 'accessing'!classToTranspile	^ self transpilerClass coreClass! !!PjCoreTranspilationTest methodsFor: 'tests'!testClassSideMethods	self		assertClassMethod: #require:		equals: '(moduleName){return require(moduleName);}'! !!PjCoreTranspilationTest methodsFor: 'tests'!testInstanceSideMethods	self assert: self classToTranspile methodDict size equals: 0! !!PjCoreTranspilationTest methodsFor: 'tests'!testOptimizedJsAt	| method asNil |	asNil := PjStringGenerator nilTestFunctionName.	method := self classMethod: #makePharoJsSelector:.	self assert: (method indexOfSubCollection: asNil,'(aSelector[0])._61_(') > 0.	self assert: (method indexOfSubCollection: asNil ,'(this.selectorCache.hasOwnProperty(aSelector))._ifTrue_(') > 0.! !!PjLiteralGeneratorTranspilationTest methodsFor: 'accessing'!classToTranspile	^ PjClassForDefinitionTest! !!PjLiteralGeneratorTranspilationTest methodsFor: 'tests'!testLiteralGeneratrion	self assert: self jsCode includes: '_literal(){return 7}'.	self assert: self jsCode includes: 'static _literal(){return "abcdef"}'.! !!PjPrefixForTranspilationTest methodsFor: 'accessing'!classToTranspile	^ PjClassForDefinitionTest! !!PjPrefixForTranspilationTest methodsFor: 'accessing'!selectorsPrefix	^ 'altPrefix_'! !!PjPrefixForTranspilationTest methodsFor: 'tests'!testPrefix	| pjPrefix |	pjPrefix := self selectorsPrefix.	self assert: self jsCode includes: pjPrefix,'literal(){'.	self assert: self jsCode includes: 'static ',pjPrefix,'literal(){'.! !!PjReplacedClassTranspilationTest methodsFor: 'accessing'!classToTranspile	^ PjReplacedClassForTest! !!PjReplacedClassTranspilationTest methodsFor: 'tests'!testClassReplacement	self deny: self jsCode includes: 'function ', className, '(){}'."We use defineProperty. See PjTranspiler>>#writeMethodsOf:named:with:"	self assert: self jsCode includes: '_add_and_(op1,op2){return op2}'.	self deny: self jsCode includes: 'notInPlaceholderClass'.	self assert: self jsCode includes: '_64_(op)'.	self assert: self jsCode includes: '_m_($in)'.	self assert: self jsCode includes: '_m1()'.	self assert: self jsCode includes: '_m2()'.	self assert: self jsCode includes: 'static _c1()'.	self assert: self jsCode includes: 'static _c2()'.! !!PjSharedPoolDefinitionTranspilationTest methodsFor: 'accessing'!classToTranspile	^ PjSharedPoolForTest! !!PjSharedPoolDefinitionTranspilationTest methodsFor: 'accessing'!expectedClassName	^ self classToTranspile name! !!PjSharedPoolDefinitionTranspilationTest methodsFor: 'tests'!expectedFullClassDefinition	| superclassName |	superclassName := self classToTranspile superclass		                  nameToUseForJsConversion.	^ 'Smalltalk.installClass(class {1} extends {2}\{static _initialize()\{{1}.cp$.A="sharedA";{1}.cp$.B="sharedB";{1}.cp$.C="sharedC";return this\}static cp$=\{"C":null,"X":null,"A":null,"B":null\}\},\{\},\{\});{1}._initialize();' format: { 			  className.			  superclassName }! !!PjSharedPoolDefinitionTranspilationTest methodsFor: 'tests'!testClassVariables		self		assert: self jsCode		includes: self expectedFullClassDefinition ! !!PjSingleClassTranspilationTest methodsFor: 'accessing'!classToTranspile	^ PjClassForTranspilationTest! !!PjSingleClassTranspilationTest methodsFor: 'accessing'!expectedClassName	^classToTranspile nameToUseForJsConversion! !!PjSingleClassTranspilationTest methodsFor: 'running'!setUp	super setUp.	transpiler poolFor: self classToTranspile.	transpiler pharoJsSelectorPrefix: self selectorsPrefix.	self jsCode: (self convertClass: self classToTranspile).	className := self expectedClassName! !!PjSingleClassTranspilationTest methodsFor: 'tests'!testBlockReferencingSelf	self assertInstanceMethod: #blocksReferencingSelf equals: '(){var ',PjStringGenerator selfName,'=this;(()=>{return ',PjStringGenerator selfName,'});return this}'! !!PjSingleClassTranspilationTest methodsFor: 'tests'!testCascade	self assertInstanceMethod: #cascadeSelf equals: '(){return (this._m1(),this._m_(4),this._yourself())}'.	self assertInstanceMethod: #cascadeSuper equals: '(){return (super._isNil(),super._yourself())}'.	self assertInstanceMethod: #cascade: equals: '(x){var $1;return ($1=$asNil$($asNil$(x)._foo()),$1._bar(),$1._yourself())}'.	self assertInstanceMethod: #cascadeNested equals: '(){return (this._m1(),this._m_((this._m1(),this._m2())),this._yourself())}'.! !!PjSingleClassTranspilationTest methodsFor: 'tests'!testClassAndPoolVariableDefinition	| sharedPoolVarsHolder superVarsHolder classVarHolder |	sharedPoolVarsHolder := PjSharedPoolForTest nameToUseForJsConversion	                        , '.cp$'.	superVarsHolder := PjSuperClassForTranspilationTest		                   nameToUseForJsConversion , '.cp$'.	classVarHolder := self expectedClassName, '.cp$'. 	self assert: self jsCode includes: '"A":null'.	self assert: self jsCode includes: classVarHolder , '.A'.	self deny: self jsCode includes: sharedPoolVarsHolder , '.A'.	self assert: self jsCode includes: '"X":null'.	self assert: self jsCode includes: classVarHolder , '.X'.	self deny: self jsCode includes: sharedPoolVarsHolder , '.X'.	self deny: self jsCode includes: '"B":null'.	self assert: self jsCode includes: superVarsHolder , '.B'.	self deny: self jsCode includes: sharedPoolVarsHolder , '.B'.	self deny: self jsCode includes: '"C":null'.	self assert: self jsCode includes: sharedPoolVarsHolder , '.C'.! !!PjSingleClassTranspilationTest methodsFor: 'tests'!testClassSideMethods	| superclassName sharedPoolName |	sharedPoolName := transpiler poolReference: PjSharedPoolForTest for: self classToTranspile.	superclassName := transpiler poolReference: PjSuperClassForTranspilationTest for: self classToTranspile.	self assertClassMethod: #c1 equals: '(){return this}'.	self assertClassMethod: #c2 equals: '(){return this}'.	self assertClassMethod: #initialize equals: '(){', className, '.cp$.A="testA";return this}'.	self assertClassMethod: #m1 equals: '(){',		className, '.cp$.X=', className, '.cp$.$prototype;',		superclassName,'.S=',superclassName,'.S;',		sharedPoolName,'.C=',sharedPoolName,'.C;',		'return this}'.	self assert: (self jsCode endsWith: className, '._initialize();').	self assertClassMethod: #javascriptName equals: nil.	self assertClassMethod: #methodWithJsGenerator equals: '(){', (self classToTranspile classMethod_jsGenerator: transpiler),'}'! !!PjSingleClassTranspilationTest methodsFor: 'tests'!testCompose	self assertInstanceMethod: #composedCalls equals: '(){return $asNil$($asNil$(this._m1())._m_(4))._m2()}'.! !!PjSingleClassTranspilationTest methodsFor: 'tests'!testInstanceSideMethods	| superclassName sharedPoolName |	sharedPoolName := transpiler poolReference: PjSharedPoolForTest for: self classToTranspile.	superclassName := transpiler poolReference: PjSuperClassForTranspilationTest for: self classToTranspile.	self assertInstanceMethod: #m1 equals: '(){',		className, '.cp$.X=', className, '.cp$.$prototype;',		superclassName,'.S=',superclassName,'.S;',		sharedPoolName,'.C=',sharedPoolName,'.C;',		'return this}'.	self assertInstanceMethod: #m2 equals: '(){return this}'.	self assertInstanceMethod: #@ equals: '(op){return this}'.	self assertInstanceMethod: #add:and: equals: '(op1,op2){return op2}'.	self deny: self jsCode includes: 'methodToSkip'.	self deny: self jsCode includes: 'ThisShouldBeSkipped'.	self assertInstanceMethod: #m: equals: '($in){console.log("abc")}'.	self assertInstanceMethod: #instanceMethodWithJsGenerator equals:  '(){', (self classToTranspile instanceMethod_jsGenerator: transpiler), '}'.! !!PjSingleClassTranspilationTest methodsFor: 'tests'!testMethodAlias	self assert: self jsCode includes: '"_alias":["myAlias"]'.	self assert: self jsCode includes: '"_alias2":["andAlias2","myAlias2"]'.! !!PjSingleClassTranspilationTest methodsFor: 'tests'!testNative	| method |	method := self instanceMethod: #native.	self assert: method includes: 'x=x[4]'.	self assert: method includes: 'x=x.foo'.	self assert: method includes: 'x=x["a.b"]'.	self assert: method includes: 'x[4]=42'.	self assert: method includes: 'x.m(17)'.! !!PjSingleClassTranspilationTest methodsFor: 'tests'!testToDoExpr	self assertInstanceMethod: #toDoWithObjectAsParameter equals: '(){(1)._to_do_(10,Object);return this}'! !!PjTranspilationClassCompilationTest methodsFor: 'checking'!assert: codeString1 appearsBefore: codeString2	self assert: (self jsCode includes: codeString1 before: codeString2 )! !!PjTranspilationClassCompilationTest methodsFor: 'checking'!assert: aString includes: mName then: mString	| pName pString pEnd |	pName := aString findString: mName startingAt: 1.	self assert: pName>0.	pString := aString findString: mString startingAt: pName.	self assert: pString > pName.	pEnd := aString findString: '}' startingAt: pName.	self assert: pString < pEnd.! !!PjTranspilationClassCompilationTest methodsFor: 'checking'!convertAllClasses: classes	^transpiler convertAllClasses: classes;jsCode! !!PjTranspilationClassCompilationTest methodsFor: 'checking'!generateJsCodeForClasses: classes	self classToTranspile: classes last.	self jsCode: (self convertAllClasses: classes)! !!PjTranspilationClassCompilationTest methodsFor: 'accessing'!jsCode	^ jsCode! !!PjTranspilationClassCompilationTest methodsFor: 'accessing'!jsCode: anObject	jsCode := anObject trim! !!PjTranspilationTest class methodsFor: 'testing'!isAbstract	^ self = PjTranspilationTest! !!PjTranspilationTest methodsFor: 'testing'!assertStBlock: aBlock convertsTo: expectedJsString	self assert: (transpiler convertToJs: aBlock) equals: expectedJsString! !!PjTranspilationTest methodsFor: 'accessing'!classToTranspile	^ classToTranspile! !!PjTranspilationTest methodsFor: 'accessing'!classToTranspile: aClass	classToTranspile := aClass! !!PjTranspilationTest methodsFor: 'accessing'!classVariablesHolderName	^ PjStringGenerator classVariablesHolderName! !!PjTranspilationTest methodsFor: 'converting'!convertClass: aClass	self classToTranspile: aClass.	^ transpiler convertToJs: aClass! !!PjTranspilationTest methodsFor: 'accessing' prior: 33644778!lineEnding	^self transpilerClass lineEnding! !!PjTranspilationTest methodsFor: 'accessing'!method: aString 	self shouldBeImplemented.! !!PjTranspilationTest methodsFor: 'accessing'!nilInJavascript	^PjStringGenerator nilInJavascript! !!PjTranspilationTest methodsFor: 'accessing'!nilTestFunctionName	^PjStringGenerator nilTestFunctionName! !!PjTranspilationTest methodsFor: 'accessing'!pharoJsSelectorPrefix	^ transpiler pharoJsSelectorPrefix! !!PjTranspilationTest methodsFor: 'accessing'!selectorsPrefix	^  '_'! !!PjTranspilationTest methodsFor: 'running'!setUp	super setUp.	transpiler := self transpilerClass new.! !!PjTranspilationTest methodsFor: 'accessing'!transpilerClass	^PjTranspiler! !!PjNullMessageConversionForTest methodsFor: 'optimization'!convertReceiver: anObject args: aCollection	anObject value < order ifTrue: [ ^ order ].	^ nil! !!PjNullMessageConversionForTest methodsFor: 'initialization'!order: aNumber selector: aString 	self order: aNumber.	selector := aString! !!PjNullMessageConversionForTest methodsFor: 'accessing'!selector	^ selector! !!PjNullMessageConversionForTest methodsFor: 'accessing'!selectors	^ {selector}! !!PjBlockTranspilationTest class methodsFor: 'class initialization'!initialize	SomeClassVar := 'SomeClassVariable'! !!PjBlockTranspilationTest methodsFor: 'private'!closedBlock: x	| y |	y := 23.	^  [:v| |w| {v.w.x.y.instVar.123}] asClosedBlock! !!PjBlockTranspilationTest methodsFor: 'private'!openBlock: x	| y |	y := 23.	^  [:v| |w| {v.w.x.y.instVar.123}]! !!PjBlockTranspilationTest methodsFor: 'tests'!testBlock1Arg	self 		assertStBlock: [ :x | 123]		convertsTo: '((x)=>{return 123})'! !!PjBlockTranspilationTest methodsFor: 'tests'!testBlock1ArgWithReturn	self		assertStBlock: [ :x | ^ 123 ]		convertsTo: '((x)=>{throw $_err_$=123})'! !!PjBlockTranspilationTest methodsFor: 'tests'!testBlock2Args	self		assertStBlock: [ :x :y | 			{ 				x.				y } ]		convertsTo: '((x,y)=>{return [x,y]})'! !!PjBlockTranspilationTest methodsFor: 'tests'!testBlock2ArgsWithReturn	self		assertStBlock: [ :x :y | 			^ { 				  x.				  y } ]		convertsTo: '((x,y)=>{throw $_err_$=[x,y]})'! !!PjBlockTranspilationTest methodsFor: 'tests'!testBlockEmpty	self 		assertStBlock: []		convertsTo: '(()=>{return ', self nilInJavascript, '})'! !!PjBlockTranspilationTest methodsFor: 'tests'!testBlockWithExternalVariables	| x |	self		assertStBlock: [ :y | 			| z |			z := y.			{ 				y.				z.				123 } ]		convertsTo: '((y)=>{var z;z=y;return [y,z,123]})'.	self		assertStBlock: [ document ]		convertsTo: '(()=>{return document})'.	x := nil.	self		assertStBlock: [ x ] asClosedBlock		convertsTo: '((x)=>{return ()=>{return x}})(null)'.	x := 'string'.	self		assertStBlock: [ x ] asClosedBlock		convertsTo: '((x)=>{return ()=>{return x}})("string")'.	x := #( 1 #( 2 3 ) 4 ).	self		assertStBlock: [ x ] asClosedBlock		convertsTo:		'((x)=>{return ()=>{return x}})([1,[2,3],4])'.	x := { 		     (#x -> 1).		     (#y -> 2) } asDictionary.	self		assertStBlock: [ x ] asClosedBlock		convertsTo:		'((x)=>{return ()=>{return x}})({"x":1,"y":2})'.	x := 1337.	self		assertStBlock: [ x ] asClosedBlock		convertsTo: '((x)=>{return ()=>{return x}})(1337)'.	self		assertStBlock: [ 			{ 				x.				self js_this } ] asClosedBlock		convertsTo:		'((x)=>{return ()=>{return [x,this]}})(1337)'.	self		should: [ transpiler convertToJs: [ Smalltalk ] ]		raise: PjJavascriptTranspilationError.	self		should: [ transpiler convertToJs: [ x ] ]		raise: PjJavascriptTranspilationError.	self		should: [ transpiler convertToJs: [ testSelector ] ]		raise: PjJavascriptTranspilationError.	self		should: [ transpiler convertToJs: [ SomeClassVar ] ]		raise: PjJavascriptTranspilationError.	self		should: [ 		transpiler convertToJs: [ self testBlockWithExternalVariables ] ]		raise: PjJavascriptTranspilationError.	self		should: [ 		transpiler convertToJs: [ super testBlockWithExternalVariables ] ]		raise: PjJavascriptTranspilationError.	{ 		Object new.		{ (1 -> 2) } asDictionary.		{ (#x -> Object new) } asDictionary.		{ Object new } } do: [ :y | 		self			should: [ transpiler convertToJs: [ y ] ]			raise: PjJavascriptTranspilationError ].	self		assertStBlock: ([ :x1 | [ x1 ] ] value: 42) asClosedBlock		convertsTo: '((x1)=>{return ()=>{return x1}})(42)'! !!PjBlockTranspilationTest methodsFor: 'tests'!testBlockWithNestedScopes	| openBlock closedBlock x a |	x := 1337.	instVar := 1066.	a := 42.	openBlock := [ :y | 	             [ :v | 	             | w |	             { 		             a.		             v.		             w.		             x.		             y.		             instVar.		             123 } ] ] value: 91.	closedBlock := [ :q | 	               [ :v | 	               | w |	               { 		               a.		               v.		               w.		               x.		               q.		               instVar.		               321 } ] asClosedBlock ] value: 73.	a := 107.	instVar := 1492.	self		assertStBlock: [ 			| z |			z := self js_this.			[ 			| w |			w := z.			{ 				z.				w.				self js_this.				123 } ] ]		convertsTo:		'(()=>{var z;z=this;return ()=>{var w;w=z;return [z,w,this,123]}})'.	self		assertStBlock: [ 			| z |			z := self js_this.			[ :v | 			| w |			{ 				v.				w.				x.				z.				instVar.				123 } ] ] asClosedBlock		convertsTo:		'((x,instVar)=>{return ()=>{var z;z=this;return (v)=>{var w;return [v,w,x,z,instVar,123]}}})(1337,1492)'.	self		assertStBlock: closedBlock		convertsTo:		'((a,x,q,instVar)=>{return (v)=>{var w;return [a,v,w,x,q,instVar,321]}})(42,1337,73,1066)'.	self		assertStBlock: openBlock asClosedBlock		convertsTo:		'((a,x,y,instVar)=>{return (v)=>{var w;return [a,v,w,x,y,instVar,123]}})(107,1337,91,1492)'.	self		assertStBlock: (self closedBlock: 17)		convertsTo:		'((x,y,instVar)=>{return (v)=>{var w;return [v,w,x,y,instVar,123]}})(17,23,1492)'.	self		assertStBlock: (self openBlock: 42) asClosedBlock		convertsTo:		'((x,y,instVar)=>{return (v)=>{var w;return [v,w,x,y,instVar,123]}})(42,23,1492)'! !!PjBlockTranspilationTest methodsFor: 'tests'!testBlockWithNestedScopesToFix	<expectedFailure>	self 		assertStBlock: ([ :y| [ |w| w:=17. [ { w.y.2} ] ] ] value: 4) value asClosedBlock		convertsTo: '(function(w,y){return function(){return [w,y,2]}})(17,4)'.	self 		assertStBlock: ([ :y| [ |w| w:=17. [ { w.y.2} ] ] ] value: 4) value		convertsTo: '(function(w,y){return function(){return [w,y,2]}})(17,4)'.! !!PjBlockTranspilationTest methodsFor: 'tests'!testBlockWithReferencedScopes	| x y superClosed |	y := 17.	superClosed := [ y ] asClosedBlock.	x := 1337.	self		assertStBlock: [ 			| w |			w := superClosed value.			{ 				w.				x.				123 } ] asClosedBlock		convertsTo:		'((superClosed,x)=>{return ()=>{var w;w=$asNil$(superClosed)._value();return [w,x,123]}})(((y)=>{return ()=>{return y}})(17),1337)'! !!PjBlockTranspilationTest methodsFor: 'tests'!testValuedBlock	self		assertStBlock: [ 23 ] asValuedBlock		convertsTo: '(()=>{return 23})()'.	self		assertStBlock: ([ :a :b |  ] asValuedBlockWithArgs: { 					 23.					 self class })		convertsTo:		'((a,b)=>{return null})(23,' , self className , ')'! !!PjClassFactoryTestResource methodsFor: 'running'!classFactory	^classFactory! !!PjClassFactoryTestResource methodsFor: 'running'!defaultClass	^defaultClass! !!PjClassFactoryTestResource methodsFor: 'running'!setUp	super setUp.	authorInitialName := Author uniqueInstance fullNamePerSe.	Author uniqueInstance fullName: 'PharoJS'.	classFactory := ClassFactoryForTestCase new.	defaultClass := classFactory silentlyNewClassInCategory: classFactory packageName.! !!PjClassFactoryTestResource methodsFor: 'running'!tearDown	super tearDown.	classFactory cleanUp.	Author uniqueInstance fullName: authorInitialName.! !!PjClassAForCircularTranspilationTest class methodsFor: 'pharoJs support'!javascriptName	^#A! !!PjClassBForCircularTranspilationTest class methodsFor: 'any'!javascriptName	^super javascriptName! !!PjClassBForCircularTranspilationTest class methodsFor: 'any'!other	^ Object isNil! !!PjClassAForPackageTranspilationTest class methodsFor: 'any'!initialize! !!PjClassBForPackageTranspilationTest class methodsFor: 'any'!initialize! !!PjClassAForReferenceTranspilationTest class methodsFor: 'any'!javascriptName	^#OtherName! !!PjClassBForReferenceTranspilationTest methodsFor: 'any'!m	^PjClassAForReferenceTranspilationTest! !!PjClassCForPackageTranspilationTest class methodsFor: 'any'!initialize	PjClassBForPackageTranspilationTest.! !!PjClassDForPackageTranspilationTest methodsFor: 'any'!m	PjClassBForPackageTranspilationTest.! !!PjClassEForPackageTranspilationTest class methodsFor: 'any'!initialize! !!PjClassExtensionForTest class methodsFor: 'accessing'!exampleForTest	^self! !!PjClassExtensionForTest class methodsFor: 'accessing'!javascriptInitialize	^self! !!PjClassExtensionForTest class methodsFor: 'accessing'!javascriptName	<pharoJsSkip>	^PjClassForTranspilationTest name! !!PjClassExtensionForTest class methodsFor: 'importing'!jsTranspilationImportMethods	<pharoJsSkip>	^ { 		  (Object -> #( yourself isArray )).			(PjFooClassForTest -> #(foo)).		  (Boolean -> #( eqv: )).		  (UndefinedObject class -> #( allInstances allInstancesDo:		      new )) } asDictionary! !!PjClassExtensionForTest methodsFor: 'any'!foo	^ 42! !!PjClassExtensionForTest methodsFor: 'any'!instanceMethod! !!PjClassForAstConversionTest methodsFor: 'test method'!basic1	1! !!PjClassForAstConversionTest methodsFor: 'test method'!basic2	^ 1! !!PjClassForAstConversionTest methodsFor: 'test method'!basic3	<javascript: 'return 3'>	^ (2 ifTrue: [^1] ifFalse: [3]) ifTrue: [ 2 ] ifFalse: [ 1 ]! !!PjClassForAstConversionTest methodsFor: 'test method'!basic4	3.	[ 2. 1 ]! !!PjClassForAstConversionTest methodsFor: 'test method'!basic5	3.	^ [ 2. 1 ]! !!PjClassForAstConversionTest methodsFor: 'test method'!basic6	[ 2. 1 ].	3! !!PjClassForAstConversionTest methodsFor: 'test method'!return1	3.	2.	1 ifTrue: [ ^ 2 ] ifFalse: [ 1 ]! !!PjClassForAstConversionTest methodsFor: 'test method'!return2	3.	2.	1 ifTrue: [ ^ 2 ] ifFalse: [ ^ 1 ]! !!PjClassForAstConversionTest methodsFor: 'test method'!return3	3.	2.	^ 1 ifTrue: [ 2 ] ifFalse: [ 1 ]! !!PjClassForAstConversionTest methodsFor: 'test method'!return4	3.	2.	^ (2 ifTrue: [^self] ifFalse: [3]) ifTrue: [ 2 ] ifFalse: [ 1 ]! !!PjClassForDefinitionTest class methodsFor: 'accessing'!literal	<jsLiteralGenerator>	^ 'abc','def'! !!PjClassForDefinitionTest methodsFor: 'accessing'!literal	<jsLiteralGenerator>	^ 3 + 4! !!PjClassForPrimitiveFailingTest methodsFor: 'any'!* aNumber 	"Primitive. Answer the sum of the receiver and aNumber. Essential.	Fail if the argument is not a Float. See Object documentation	whatIsAPrimitive."	<primitive: 49>! !!PjClassForPrimitiveTest methodsFor: 'any'!+ aNumber 	"Primitive. Answer the sum of the receiver and aNumber. Essential.	Fail if the argument is not a Float. See Object documentation	whatIsAPrimitive."	<primitive: 41>	^ aNumber adaptToFloat: self andSend: #+! !!PjClientForInitializationTest class methodsFor: 'initializing'!initialize! !!PjClientForInitializationTest methodsFor: 'any'!m	PjProviderForInitializationTest new! !!PjClientForJavascriptInitializationTest class methodsFor: 'initializing'!initialize! !!PjClientForJavascriptInitializationTest class methodsFor: 'initializing'!javascriptInitialize! !!PjClientForJavascriptInitializationTest methodsFor: 'any'!m	PjProviderForInitializationTest new! !!PjExtensionClassForAliasTest class methodsFor: 'aliasing'!classM1	<jsAlias: #classM1alias>	^ #classM1! !!PjExtensionClassForAliasTest class methodsFor: 'aliasing'!classM2	<jsAlias: #classM2alias1 with: #classM2alias2>	^ #classM2! !!PjExtensionClassForAliasTest class methodsFor: 'transpiling'!isJsClassPlaceholder	<pharoJsSkip>	^ true! !!PjExtensionClassForAliasTest class methodsFor: 'transpiling'!javascriptName 	<pharoJsSkip>	^ #Object! !!PjExtensionClassForAliasTest methodsFor: 'aliasing'!m1	<jsAlias: #m1alias>	^ #instanceM1! !!PjExtensionClassForAliasTest methodsFor: 'aliasing'!m2	<jsAlias: #m2alias1 with: #m2alias2 with: #m2alias3>	^ #instanceM2! !!PjExtensionClassForAliasTest methodsFor: 'aliasing'!twoPragmaWithAliases	<jsAlias: #firstAlias>	<jsAlias: #secondAlias>	^ 200! !!PjFooClassForTest methodsFor: 'accessing'!foo	^#bar! !!PjProviderForInitializationTest class methodsFor: 'initializing'!initialize! !!PjReplacedClassForTest class methodsFor: 'pharojs helper'!javascriptPlaceholder	^ PjClassForTranspilationTest! !!PjReplacedClassForTest methodsFor: 'any'!add: op1 and: op2	^op1 " note this is slightly different that the shadowed version "! !!PjReplacedClassForTest methodsFor: 'any'!notInPlaceholderClass! !!PjSharedPoolForTest class methodsFor: 'initialization-release'!initialize	A := #sharedA.	B := #sharedB.	C := #sharedC.! !!PjClassForTranspilationTest class methodsFor: 'accessing structure variables'!a	^ A! !!PjClassForTranspilationTest class methodsFor: 'accessing structure variables'!b	^ B! !!PjClassForTranspilationTest class methodsFor: 'any'!c1! !!PjClassForTranspilationTest class methodsFor: 'any'!c2! !!PjClassForTranspilationTest class methodsFor: 'pharojs support'!classMethod_jsGenerator: transpiler	<pharoJsSkip>	^self name asJSON! !!PjClassForTranspilationTest class methodsFor: 'any'!click: ev	| m |	m := self setupMessage ifNil: [^ self].	^ m! !!PjClassForTranspilationTest class methodsFor: 'any'!initialize	A := #testA.! !!PjClassForTranspilationTest class methodsFor: 'pharojs support'!instanceMethod_jsGenerator: transpiler	<pharoJsSkip>	^'return 1', ' + ', '2;'! !!PjClassForTranspilationTest class methodsFor: 'pharojs support'!isJsClassPlaceholder	<pharoJsSkip>	^ false! !!PjClassForTranspilationTest class methodsFor: 'pharojs support'!javascriptName	<pharoJsSkip>	^ #JsClass! !!PjClassForTranspilationTest class methodsFor: 'pharojs support'!jsTranspilationImportMethods	<pharoJsSkip>	^ {		PjNullMessageConversionForTest -> #(selectors).		PjClientForJavascriptInitializationTest class -> #(javascriptInitialize).	}! !!PjClassForTranspilationTest class methodsFor: 'pharojs support'!jsTranspilationImportMethodsNonstandard	<pharoJsSkip>	^ {		PjNullMessageConversionForTest -> #(selector order:selector:).		PjClassExtensionForTest class -> #(javascriptName exampleForTest).	}! !!PjClassForTranspilationTest class methodsFor: 'any'!m1	X := prototype.	S := S.	C := C.! !!PjClassForTranspilationTest class methodsFor: 'any'!methodWithJsGenerator	<jsGenerator: #classMethod_jsGenerator:>! !!PjClassForTranspilationTest class methodsFor: 'any'!setupMessage	^ (self == PjClassForTranspilationTest ifTrue: [				''			] ifFalse: [				'Sorry, ']) ,		'Click anywhere'! !!PjClassForTranspilationTest methodsFor: 'any'!@ op! !!PjClassForTranspilationTest methodsFor: 'any'!add: op1 and: op2	^op2! !!PjClassForTranspilationTest methodsFor: 'any'!alias	<jsAlias: #myAlias>	^ 42! !!PjClassForTranspilationTest methodsFor: 'any'!alias1: arg	<jsAlias: #myAlias1 >	^ arg + 1! !!PjClassForTranspilationTest methodsFor: 'any'!alias1Caller	<javascript: 'return this.myAlias1(41)'>! !!PjClassForTranspilationTest methodsFor: 'any'!alias1Caller: arg 	<javascript: 'return this.myAlias1(arg)'>! !!PjClassForTranspilationTest methodsFor: 'any'!alias2	<jsAlias: #myAlias2 and: #andAlias2>	^ 21! !!PjClassForTranspilationTest methodsFor: 'any'!alias2Caller	<javascript: 'return this.myAlias2() + this.andAlias2()'>! !!PjClassForTranspilationTest methodsFor: 'any'!aliasCaller	<javascript: 'return this.myAlias()'>! !!PjClassForTranspilationTest methodsFor: 'any'!aliasSpecialName	<jsAlias: #'_$$_special'>	^ 42! !!PjClassForTranspilationTest methodsFor: 'any'!aliasSpecialNameCaller	<javascript: 'return this._$$_special()'>! !!PjClassForTranspilationTest methodsFor: 'any'!blockWithNamedParameter"	self m2 ifNotNil: [ : foo | foo m2 ]."	^ self m1 ifNotNil: [ : foo | foo m1 ]! !!PjClassForTranspilationTest methodsFor: 'any'!blockWithUnnamedParameter	^ self m1 ifNil: [ 42 ]! !!PjClassForTranspilationTest methodsFor: 'any'!blockWithUnnamedParameterNonTail	^ 3+(self m1 ifNil: [ 42 ])! !!PjClassForTranspilationTest methodsFor: 'any'!blocksReferencingSelf	[self].	^self! !!PjClassForTranspilationTest methodsFor: 'any'!cascade: x	^ x foo bar;yourself! !!PjClassForTranspilationTest methodsFor: 'any'!cascadeNested	^ self m1;m:(self m1; m2);yourself! !!PjClassForTranspilationTest methodsFor: 'any'!cascadeSelf	^ self m1;m:4;yourself! !!PjClassForTranspilationTest methodsFor: 'any'!cascadeSuper	^ super isNil;yourself! !!PjClassForTranspilationTest methodsFor: 'any'!composedCalls	^ (self m1 m:4) m2! !!PjClassForTranspilationTest methodsFor: 'any'!instanceMethodWithJsGenerator		<jsGenerator: #instanceMethod_jsGenerator:>	^self! !!PjClassForTranspilationTest methodsFor: 'any'!m1	X := prototype.	S := S.	C := C.! !!PjClassForTranspilationTest methodsFor: 'any'!m2! !!PjClassForTranspilationTest methodsFor: 'any'!m: in	<javascript: 'console.log("abc")'>	^self! !!PjClassForTranspilationTest methodsFor: 'any'!methodToSkip		<pharoJsSkip>		^#ThisShouldBeSkipped! !!PjClassForTranspilationTest methodsFor: 'any'!methodWithPoolVars	A := A.	B := B.	C := C.	S := S.	X := X.	Y := Y.! !!PjClassForTranspilationTest methodsFor: 'any'!native	| x |	x := x js_at: 4.	x := x js_at: #foo.	x := x js_at: 'a.b'.	x js_at: 4 put: 42.	x js_m: 17! !!PjClassForTranspilationTest methodsFor: 'any'!nestedBlocksReferencingSelf	[[self]].	^1! !!PjClassForTranspilationTest methodsFor: 'any'!optimizeAtTest	| selectorCache aSelector |	(selectorCache js_at: aSelector) ifNotNil: [ self ].! !!PjClassForTranspilationTest methodsFor: 'any'!toDoWithObjectAsParameter	1 to: 10 do: Object! !!PjClassForTranspilationTest methodsFor: 'any'!twoPragmaWithAliases	<jsAlias: #firstAlias>	<jsAlias: #secondAlias>	^ 200! !!PjClassForTranspilationTest methodsFor: 'any'!whileAtEnd	self m: [:x|	[ x m1 ] whileTrue].	[ self m2 ] whileTrue.! !!PjClassForTranspilationTest methodsFor: 'any'!whileNotAtEnd	self m: [:x|	[ x m1 ] whileTrue].	[ self m2 ] whileTrue.	^ 42! !!PjSuperClassForTranspilationTest class methodsFor: 'class initialization'!initialize	B := #superB.! !"PharoJs-Base-Transpiler-Tests"!!PjTemporaryNode commentStamp: '' prior: 0!I am a special version of RBTemporaryNode used in optimizations.Note: I'm in the RB AST heirarchy, not the PjJavascript AST heirarchy!!ManifestPharoJsBaseTranspilerOptimizations commentStamp: '' prior: 0!I store metadata for this package. These meta data are used by other tools such as the SmalllintManifestChecker and the critics Browser!!PjForLoopNode commentStamp: '' prior: 0!I am part of the representation of a Javascript AST for visiting!!PjIfNode commentStamp: '' prior: 0!I am part of the representation of a Javascript AST for visiting with a subclass of PjASTVisitor!!PjIfNilNode commentStamp: '' prior: 0!I am part of the representation of a Javascript AST for visiting with a subclass of PjASTVisitor!!PjIfNotNilNode commentStamp: '' prior: 0!I am part of the representation of a Javascript AST for visiting with a subclass of PjASTVisitor!!PjIfNilIfNotNilNode commentStamp: '' prior: 0!I am part of the representation of a Javascript AST for visiting with a subclass of PjASTVisitor or PjASTEqual!!PjIfTrueNode commentStamp: '' prior: 0!I am part of the representation of a Javascript AST for visiting with a subclass of PjASTVisitor!!PjIfTrueIfFalseNode commentStamp: '' prior: 0!I am part of the representation of a Javascript AST for visiting with a subclass of PjASTVisitor or PjASTEqual!!PjWhileNode commentStamp: '' prior: 0!I am part of the representation of a Javascript AST for visiting!!PjArithmeticOptimization commentStamp: '' prior: 0!My subclasses are optimizations for all of the arithmetic operators!!PjComparisonOptimization commentStamp: '' prior: 0!My subclasses are optimizations for all of the comparison operators, most of which can be used directly in Javascript as they given legitimate results (if not always  meaningful if the types are different).!!PjEqualsOptimization commentStamp: '' prior: 0!Straight equality comparison doesn't work for arrays, so if we can't show that the left or right values are non-arrays, must fallback to method call.!!PjIfNilIfNotNilOptimization commentStamp: '' prior: 0!I handle optimizations of various flavors of ifNil:ifNotNil:!!PjIfTrueIfFalseOptimization commentStamp: '' prior: 0!I handle optimizations of various flavors of ifTrue:ifFalse!!RBProgramNode methodsFor: '*PharoJs-Base-Transpiler-Optimizations'!isOptimizableAsContionalBlock	^ false! !!PjTemporaryNode methodsFor: 'testing'!isOptimizableAsContionalBlock	^ true! !!PjTemporaryNode methodsFor: 'initialization'!named: aName start: aPosition	super named: aName start: aPosition.	variable := TemporaryVariable named: aName.! !!PjLiteralValueNode methodsFor: '*PharoJs-Base-Transpiler-Optimizations'!constantOrZero	value isNumber ifFalse: [ ^ 0 ].	^ value! !!PjLiteralValueNode methodsFor: '*PharoJs-Base-Transpiler-Optimizations'!isLiteralFalse	^ value = false! !!PjLiteralValueNode methodsFor: '*PharoJs-Base-Transpiler-Optimizations'!isLiteralTrue	^ value = true! !!PjLiteralValueNode methodsFor: '*PharoJs-Base-Transpiler-Optimizations'!target	^ self! !!PjAssignNode methodsFor: '*PharoJs-Base-Transpiler-Optimizations'!constantOrZero	^ expression constantOrZero! !!ManifestPharoJsBaseTranspilerOptimizations class methodsFor: 'code-critics'!ruleRBLongMethodsRuleV1FalsePositive	^ #(#(#(#RGMethodDefinition #(#PjConversionOptimizationTest #testBlockReturns #false)) #'2020-03-31T21:57:36.931316-04:00') #(#(#RGMethodDefinition #(#PjConversionOptimizationTest #testBlockReturns1 #false)) #'2020-03-31T22:18:03.661616-04:00') )! !!RBBlockNode methodsFor: '*PharoJs-Base-Transpiler-Optimizations'!isOptimizableAsContionalBlock	^ true! !!RBLiteralValueNode methodsFor: '*PharoJs-Base-Transpiler-Optimizations'!isOptimizableAsContionalBlock	^ true! !!PjForLoopNode class methodsFor: 'creation'!from: from to: to by: by body: body	^ self new from: from; to: to; by: by; body: body! !!PjForLoopNode methodsFor: 'visiting'!acceptVisitor: aPjStringGenerator	^ aPjStringGenerator visitToDoByNode: self! !!PjForLoopNode methodsFor: 'accessing'!body	^ body! !!PjForLoopNode methodsFor: 'accessing'!body: aCollection	body := aCollection! !!PjForLoopNode methodsFor: 'accessing'!by	^ by! !!PjForLoopNode methodsFor: 'accessing'!by: aPjAstNode	by := aPjAstNode! !!PjForLoopNode methodsFor: 'testing'!canPropogateReturns	^ true " not really, but we don't want to add a 'return this' at the end "! !!PjForLoopNode methodsFor: 'accessing'!from	^ from! !!PjForLoopNode methodsFor: 'accessing'!from: aPjAstNode	from := aPjAstNode! !!PjForLoopNode methodsFor: 'accessing'!to	^ to! !!PjForLoopNode methodsFor: 'accessing'!to: aPjAstNode	to := aPjAstNode! !!PjIfNilNode class methodsFor: 'creating'!test: test whenNil: whenNil	^ self new test: test; whenNil: whenNil; yourself! !!PjIfNilNode methodsFor: 'visiting'!acceptVisitor: aPjASTVisitor	^ aPjASTVisitor visitIfNilNode: self! !!PjIfNilNode methodsFor: 'accessing'!whenNil	^ whenNil! !!PjIfNilNode methodsFor: 'accessing'!whenNil: anObject	whenNil := anObject! !!PjIfNode class methodsFor: 'creating'!test: test	^ self new test: test; yourself! !!PjIfNode methodsFor: 'testing'!canPropogateReturns	^ true! !!PjIfNode methodsFor: 'accessing'!test	^ test! !!PjIfNode methodsFor: 'accessing'!test: anObject	test := anObject! !!PjIfNilIfNotNilNode class methodsFor: 'creating'!test: test whenNotNil: whenNotNil whenNil: whenNil	^ self new test: test; whenNotNil: whenNotNil; whenNil: whenNil; yourself! !!PjIfNilIfNotNilNode methodsFor: 'visiting'!acceptVisitor: aPjASTVisitor	^ aPjASTVisitor visitIfNilIfNotNilNode: self! !!PjIfNilIfNotNilNode methodsFor: 'accessing'!whenNil	^ whenNil! !!PjIfNilIfNotNilNode methodsFor: 'accessing'!whenNil: anObject	whenNil := anObject! !!PjIfNotNilNode class methodsFor: 'creating'!test: test whenNotNil: whenNotNil	^ self new test: test; whenNotNil: whenNotNil; yourself! !!PjIfNotNilNode methodsFor: 'visiting'!acceptVisitor: aPjASTVisitor	^ aPjASTVisitor visitIfNotNilNode: self! !!PjIfNotNilNode methodsFor: 'accessing'!whenNotNil	^ whenNotNil! !!PjIfNotNilNode methodsFor: 'accessing'!whenNotNil: anObject	whenNotNil := anObject! !!PjIfTrueIfFalseNode class methodsFor: 'creating'!test: test whenTrue: whenTrue whenFalse: whenFalse	^ self new test: test; whenTrue: whenTrue; whenFalse: whenFalse; yourself! !!PjIfTrueIfFalseNode methodsFor: 'visiting'!acceptVisitor: aPjASTVisitor	^ aPjASTVisitor visitIfTrueIfFalseNode: self! !!PjIfTrueIfFalseNode methodsFor: 'accessing'!whenFalse	^ whenFalse! !!PjIfTrueIfFalseNode methodsFor: 'accessing'!whenFalse: anObject	whenFalse := anObject! !!PjIfTrueNode class methodsFor: 'creating'!test: test whenTrue: whenTrue	^ self new test: test; whenTrue: whenTrue; yourself! !!PjIfTrueNode methodsFor: 'visiting'!acceptVisitor: aPjASTVisitor	^ aPjASTVisitor visitIfTrueNode: self! !!PjIfTrueNode methodsFor: 'accessing'!whenTrue	^ whenTrue! !!PjIfTrueNode methodsFor: 'accessing'!whenTrue: anObject	whenTrue := anObject! !!PjJavascriptAstNode methodsFor: '*PharoJs-Base-Transpiler-Optimizations'!constantOrZero	^ 0! !!PjJavascriptAstNode methodsFor: '*PharoJs-Base-Transpiler-Optimizations'!isArray	^ false! !!PjJavascriptAstNode methodsFor: '*PharoJs-Base-Transpiler-Optimizations'!isBlock	^ false! !!PjJavascriptAstNode methodsFor: '*PharoJs-Base-Transpiler-Optimizations'!isClass: aClass ifNot: aBlockClosure	myClass == aClass ifFalse: [		myClass ifNil: [ aBlockClosure value ].		(myClass inheritsFrom: aClass) ifFalse: [ aBlockClosure value ]]! !!PjJavascriptAstNode methodsFor: '*PharoJs-Base-Transpiler-Optimizations'!isLiteralFalse	^ false! !!PjJavascriptAstNode methodsFor: '*PharoJs-Base-Transpiler-Optimizations'!isLiteralTrue	^ false! !!PjJavascriptAstNode methodsFor: '*PharoJs-Base-Transpiler-Optimizations'!isNonArray	^ false! !!PjWhileNode class methodsFor: 'creating'!test: test body: body	^ self new test: test; body: body asArray; yourself! !!PjWhileNode methodsFor: 'visiting'!acceptVisitor: aPjASTVisitor	^ aPjASTVisitor visitWhileNode: self! !!PjWhileNode methodsFor: 'accessing'!body	^ body! !!PjWhileNode methodsFor: 'accessing'!body: anObject	body := anObject! !!PjWhileNode methodsFor: 'testing'!canPropogateReturns	^ true " not really, but we don't want to add a 'return this' at the end "! !!PjWhileNode methodsFor: 'accessing'!test	^ test! !!PjWhileNode methodsFor: 'accessing'!test: anObject	test := anObject! !!PjArrayNode methodsFor: '*PharoJs-Base-Transpiler-Optimizations'!isArray	^ true! !!PjFunctionNode methodsFor: '*PharoJs-Base-Transpiler-Optimizations'!isBlock	^ true! !!PjArithmeticOptimization methodsFor: 'converting'!convertReceiver: receiver args: args	| left right |	self inExpressionDo: [		left := self visit: receiver.		right := self visit: args first].	(self isOkWith: left and: right) ifFalse: [ ^ nil ].	^ PjBinaryNode operator: self operator left: left right: right! !!PjArithmeticOptimization methodsFor: 'converting'!isOkWith: receiver and: arg	^ receiver isLiteralNode or: [ arg isLiteralNode ]! !!PjArithmeticOptimization methodsFor: 'converting'!operator	^ self selector! !!PjMinusOptimization methodsFor: 'accessing'!selector	^#-! !!PjModOptimization methodsFor: 'converting'!operator	^ #%! !!PjModOptimization methodsFor: 'accessing'!selector	^#\\! !!PjPlusOptimization methodsFor: 'accessing'!selector	^#+! !!PjTimesOptimization methodsFor: 'accessing'!selector	^#*! !!PjComparisonOptimization methodsFor: 'converting'!convertReceiver: receiver args: args	| left right |	self inExpressionDo: [		left := self visit: receiver.		right := self visit: args first].	(self isOkWith: left and: right) ifFalse: [ ^ nil ].	^ PjBinaryNode operator: self operator left: left right: right! !!PjComparisonOptimization methodsFor: 'converting'!isOkWith: receiver and: arg	^ true! !!PjComparisonOptimization methodsFor: 'converting'!operator	^ self selector! !!PjEqualsOptimization methodsFor: 'converting'!isOkWith: receiver and: arg	receiver isNonArray ifFalse: [ arg isNonArray ifFalse: [ ^ false ]].	^ true! !!PjEqualsOptimization methodsFor: 'converting'!operator	^ #==! !!PjEqualsOptimization methodsFor: 'accessing'!selector	^#=! !!PjNotEqualsOptimization methodsFor: 'converting'!operator	^ #!!=! !!PjNotEqualsOptimization methodsFor: 'accessing'!selector	^#~=! !!PjGreaterEqualOptimization methodsFor: 'accessing'!selector	^#>=! !!PjGreaterThanOptimization methodsFor: 'accessing'!selector	^#>! !!PjIdenticalOptimization methodsFor: 'converting'!operator	^ #===! !!PjIdenticalOptimization methodsFor: 'accessing'!selector	^#==! !!PjLessEqualOptimization methodsFor: 'accessing'!selector	^#<=! !!PjLessThanOptimization methodsFor: 'accessing'!selector	^#<! !!PjNotIdenticalOptimization methodsFor: 'converting'!operator	^ #!!==! !!PjNotIdenticalOptimization methodsFor: 'accessing'!selector	^#~~! !!PjDoOptimization methodsFor: 'converting'!convertReceiver: aRBMessageNode args: aCollection	self flag: #todo.	^ nil! !!PjDoOptimization methodsFor: 'optimizing'!selector	^ #do:! !!PjIfNilIfNotNilOptimization methodsFor: 'converting'!convertReceiver: receiverNode args: aCollection 	| notNilBlockNode |	aCollection first isOptimizableAsContionalBlock ifFalse: [ ^ nil ].	notNilBlockNode := aCollection second.	notNilBlockNode isOptimizableAsContionalBlock ifFalse: [ ^ nil ].	(notNilBlockNode isBlock and: [ notNilBlockNode arguments notEmpty ]) ifTrue: [ | temp |		temp := notNilBlockNode arguments first name.		self astConverter newTemp: temp.		^ self			test: (self inExpressionDo: [PjAssignNode						target: (PjArgumentNode identifier: temp)						expression: (self visit: receiverNode)])			whenNotNil: (self visitInlineBlock: notNilBlockNode)			whenNil: (self visitInlineBlock: aCollection first)	].	^ self		test: (self inExpressionDo: [self visit: receiverNode])		whenNotNil: (self visitInlineBlock: notNilBlockNode)		whenNil: (self visitInlineBlock: aCollection first)! !!PjIfNilIfNotNilOptimization methodsFor: 'accessing'!selector	^#ifNil:ifNotNil:! !!PjIfNilIfNotNilOptimization methodsFor: 'optimizing'!test: aTest whenNotNil: whenNotAst whenNil: whenAst	(aTest class = PjUnaryNode and: [ aTest operator = #!! ]) ifTrue: [		^PjIfNilIfNotNilNode			test: aTest expression			whenNotNil: whenAst			whenNil: whenNotAst	].	^PjIfNilIfNotNilNode		test: aTest		whenNotNil: whenNotAst		whenNil: whenAst! !!PjIfNilOptimization methodsFor: 'optimizing'!convertReceiver: receiverNode args: aCollection	aCollection first isOptimizableAsContionalBlock ifFalse: [ ^ nil ].	self needsAllPaths ifTrue: [		^ self withTemp: [: tempName | 			| tempNode |			tempNode := PjTemporaryNode named: tempName.			(super  convertReceiver: (RBAssignmentNode variable: tempNode value: receiverNode) args: aCollection,{tempNode})	]].	^PjIfNilNode 		test: (self inExpressionDo: [self visit: receiverNode])		whenNil: (self visitInlineBlock: aCollection first).! !!PjIfNilOptimization methodsFor: 'accessing'!selector	^#ifNil:! !!PjIfNotNilIfNilOptimization methodsFor: 'converting'!convertReceiver: receiverNode args: aCollection 	^super convertReceiver: receiverNode args: aCollection reversed! !!PjIfNotNilIfNilOptimization methodsFor: 'accessing'!selector	^#ifNotNil:ifNil:! !!PjIfNotNilOptimization methodsFor: 'optimizing'!convertReceiver: receiverNode args: aCollection	| notNilBlockNode variableId |	aCollection first isOptimizableAsContionalBlock ifFalse: [ ^ nil ].	self needsAllPaths ifTrue: [^super  convertReceiver: receiverNode args: {RBLiteralValueNode value: nil}, aCollection].	notNilBlockNode := aCollection first.	(notNilBlockNode isBlock and: [ notNilBlockNode arguments notEmpty ]) ifFalse: [		^PjIfNotNilNode			test: (self inExpressionDo: [self visit: receiverNode])			whenNotNil: (self visitInlineBlock: notNilBlockNode)	].	variableId := notNilBlockNode arguments first name.	self astConverter newTemp: variableId.	^ PjIfNotNilNode			test: (self inExpressionDo: [PjAssignNode						target: (PjArgumentNode identifier: variableId)						expression: (self visit: receiverNode)])			whenNotNil: (self visitInlineBlock: notNilBlockNode)! !!PjIfNotNilOptimization methodsFor: 'accessing'!selector	^#ifNotNil:! !!PjAndOptimization methodsFor: 'converting'!convertReceiver: receiverNode args: aCollection 	| test |	aCollection first isOptimizableAsContionalBlock ifFalse: [ ^ nil ].	self needsAllPaths ifTrue: [		^super convertReceiver: receiverNode args: aCollection, { RBLiteralValueNode value: false}].	test := self inExpressionDo: [self visit: receiverNode].	^PjIfTrueIfFalseNode 		test: test		whenTrue: (self visitInlineBlock: aCollection first)		whenFalse: (PjLiteralValueNode value: false)! !!PjAndOptimization methodsFor: 'accessing'!selector	^#and:! !!PjIfFalseIfTrueOptimization methodsFor: 'converting'!convertReceiver: receiverNode args: aCollection 	^super convertReceiver: receiverNode args: aCollection reversed! !!PjIfFalseIfTrueOptimization methodsFor: 'accessing'!selector	^#ifFalse:ifTrue:! !!PjIfFalseOptimization methodsFor: 'converting'!convertReceiver: receiverNode args: aCollection 	| test |	aCollection first isOptimizableAsContionalBlock ifFalse: [ ^ nil ].	self needsAllPaths ifTrue: [		^super convertReceiver: receiverNode args: { RBLiteralNode value: nil }, aCollection].	test := self inExpressionDo: [self visit: receiverNode].	^PjIfTrueNode 		test: test not		whenTrue: (self visitInlineBlock: aCollection first)! !!PjIfFalseOptimization methodsFor: 'accessing'!selector	^#ifFalse:! !!PjIfTrueIfFalseOptimization methodsFor: 'converting'!convertReceiver: receiverNode args: aCollection 	| test first second |	aCollection first isOptimizableAsContionalBlock ifFalse: [ ^ nil ].	aCollection second isOptimizableAsContionalBlock ifFalse: [ ^ nil ].	test := self inExpressionDo: [self visit: receiverNode].	first := self visitInlineBlock: aCollection first.	second := self visitInlineBlock: aCollection second.	^PjIfTrueIfFalseNode 		test: test		whenTrue: first		whenFalse: second! !!PjIfTrueIfFalseOptimization methodsFor: 'accessing'!selector	^#ifTrue:ifFalse:! !!PjIfTrueOptimization methodsFor: 'converting'!convertReceiver: receiverNode args: aCollection 	| test |	aCollection first isOptimizableAsContionalBlock ifFalse: [ ^ nil ].	self needsAllPaths ifTrue: [		^super convertReceiver: receiverNode args: aCollection, { RBLiteralValueNode new}].	test := self inExpressionDo: [self visit: receiverNode].	^PjIfTrueNode 		test: test		whenTrue: (self visitInlineBlock: aCollection first)! !!PjIfTrueOptimization methodsFor: 'accessing'!selector	^#ifTrue:! !!PjOrOptimization methodsFor: 'converting'!convertReceiver: receiverNode args: aCollection 	| test |	aCollection first isOptimizableAsContionalBlock ifFalse: [ ^ nil ].	self needsAllPaths ifTrue: [		^super convertReceiver: receiverNode args: { RBLiteralValueNode value: true}, aCollection].	test := self inExpressionDo: [self visit: receiverNode].	^PjIfTrueIfFalseNode 		test: test		whenTrue: (PjLiteralValueNode value: true)		whenFalse: (self visitInlineBlock: aCollection first)! !!PjOrOptimization methodsFor: 'accessing'!selector	^#or:! !!PjStringAppendOptimization methodsFor: 'converting'!convertReceiver: receiver args: args	| left |	self inExpressionDo: [		left := self visit: receiver].	left isClass: String ifNot: [ ^ nil ].	^ (PjBinaryNode			operator: #+			left: left			right: (self inExpressionDo: [self visit: args first])		) myClass: String! !!PjStringAppendOptimization methodsFor: 'accessing'!selector	^#,! !!PjTimesRepeatOptimization methodsFor: 'converting'!convertReceiver: receiver args: args	| from to body fromName toName |	self astConverter isInExpression ifTrue: [ ^ nil ].	args last isBlock ifFalse: [ ^ nil ].	self inExpressionDo: [		fromName := self tempName.		from := PjAssignNode			target: (PjTempVariableNode identifier: fromName)			expression: (PjLiteralValueNode value: 1).		to := self visit: receiver.		to constantOrZero = 0 ifTrue: [			toName := self tempName.			to := PjAssignNode				target: (PjTempVariableNode identifier: toName)				expression: to].	].	^ self handleReturn: [		body := (self visitInlineLoopBlock: args last) expressions.		toName ifNotNil: [self tempNameFree: toName].		self tempNameFree: fromName.		PjForLoopNode			from: from			to: to			by: nil			body: body ]! !!PjTimesRepeatOptimization methodsFor: 'converting'!selector	^ #timesRepeat:! !!PjToByDoOptimization methodsFor: 'converting'!selector	^ #to:by:do:! !!PjToDoOptimization methodsFor: 'converting'!convertReceiver: receiver args: args	| from to by body toName byName |	true ifTrue: [ ^ nil ].	self flag: #todo.	self astConverter isInExpression ifTrue: [ ^ nil ].	args last isBlock ifFalse: [ ^ nil ].	args last arguments size = 1 ifFalse: [ ^ nil ].	self inExpressionDo: [		from := PjAssignNode			target: (PjArgumentNode identifier: args last arguments first name)			expression: (self visit: receiver).		to := self visit: args first.		to constantOrZero = 0 ifTrue: [			toName := self tempName.			to := PjAssignNode				target: (PjTempVariableNode identifier: toName)				expression: to].		args size = 3 ifTrue: [			by := self visit: args second.			by constantOrZero = 0 ifTrue: [				byName := self tempName.				by := PjAssignNode					target: (PjTempVariableNode identifier: byName)					expression: by]	]].	^ self handleReturn: [		body := (self visitInlineLoopBlock: args last) expressions.		byName ifNotNil: [self tempNameFree: byName].		toName ifNotNil: [self tempNameFree: toName].		PjForLoopNode			from: from			to: to			by: by			body: body ]! !!PjToDoOptimization methodsFor: 'converting'!selector	^ #to:do:! !!PjWhileFalseDoOptimization methodsFor: 'converting'!continueValue	^ false! !!PjWhileFalseDoOptimization methodsFor: 'converting'!selector	^ #whileFalse:! !!PjWhileFalseOptimization methodsFor: 'converting'!continueValue	^ false! !!PjWhileFalseOptimization methodsFor: 'converting'!selector	^ #whileFalse! !!PjWhileOptimization methodsFor: 'converting'!continueValue	self subclassResponsibility! !!PjWhileOptimization methodsFor: 'converting'!convertReceiver: receiver args: args	| test body |	self astConverter isInExpression ifTrue: [ ^ nil ].	receiver isBlock ifFalse: [ ^ nil ].	args isNotEmpty ifTrue: [args first isBlock ifFalse: [ ^ nil ]].	self inExpressionDo: [		test := self visitInlineLoopBlock: receiver].	self continueValue ifFalse: [ test := test not ].	^ self handleReturn: [		body := args size isZero ifTrue: [				#()			] ifFalse: [				(self visitInlineLoopBlock: args first) expressions			].		PjWhileNode test: test body: body]! !!PjWhileTrueDoOptimization methodsFor: 'converting'!continueValue	^ true! !!PjWhileTrueDoOptimization methodsFor: 'converting'!selector	^ #whileTrue:! !!PjWhileTrueOptimization methodsFor: 'converting'!continueValue	^ true! !!PjWhileTrueOptimization methodsFor: 'converting'!selector	^ #whileTrue! !!PjStringGenerator methodsFor: '*PharoJs-Base-Transpiler-Optimizations-Optimizations'!trueTest: test	| comparator testExpression |	comparator := true.	testExpression := test.	[ testExpression isNot ] whileTrue: [		comparator := comparator not.		testExpression := testExpression not ].	testExpression isComparison ifTrue: [		comparator ifFalse: [ testExpression := testExpression not ].		^ self visit: testExpression ].	self		print: comparator;		nextPutAll: '==';		atPrecedence: EqualityPrecedence+0.5 do: [self visit: testExpression]! !!PjStringGenerator methodsFor: '*PharoJs-Base-Transpiler-Optimizations-Optimizations'!visitIfNilIfNotNilNode: aPjIfNilIfNotNilNode	| then else |	then := aPjIfNilIfNotNilNode whenNil.	else := aPjIfNilIfNotNilNode whenNotNil.	self isAtStatementPrecedence ifFalse: [		^ self writeIfNilExpression: aPjIfNilIfNotNilNode test then: then else: else	].	self		nextPutAll: 'if(';		atPrecedence: EqualityPrecedence do: [ aPjIfNilIfNotNilNode test acceptVisitor: self ];		nextPutAll: '==';		nextPutAll: self class nilInJavascript;		writeNonBrace: '){';		visit: then;		maybeWriteSemicolon;		nextPutAll: '}else{';		visit: else;		writeNonBrace: $}! !!PjStringGenerator methodsFor: '*PharoJs-Base-Transpiler-Optimizations-Optimizations'!visitIfNilNode: aPjIfNilNode 	| then |	then := aPjIfNilNode whenNil.	self isAtStatementPrecedence ifFalse: [		^ self writeIfNilExpression: aPjIfNilNode test then: then else: PjNilNode new	].	self		nextPutAll: 'if(';		atPrecedence: EqualityPrecedence do: [ aPjIfNilNode test acceptVisitor: self ];		nextPutAll: '==';		nextPutAll: self class nilInJavascript;		writeNonBrace: '){';		visit: then;		writeNonBrace: $}! !!PjStringGenerator methodsFor: '*PharoJs-Base-Transpiler-Optimizations-Optimizations'!visitIfNotNilNode: aPjIfNotNilNode 	| body |	body := aPjIfNotNilNode whenNotNil.	self isAtStatementPrecedence ifFalse: [		^ self writeIfNilExpression: aPjIfNotNilNode test then: PjNilNode new else: body	].	self		nextPutAll: 'if(';		atPrecedence: EqualityPrecedence do: [ aPjIfNotNilNode test acceptVisitor: self ];		nextPutAll: '!!=';		nextPutAll: self class nilInJavascript;		writeNonBrace: '){';		visit: body;		writeNonBrace: $}! !!PjStringGenerator methodsFor: '*PharoJs-Base-Transpiler-Optimizations-Optimizations'!visitIfTrueIfFalseNode: aPjIfTrueIfFalseNode	self isAtStatementPrecedence ifFalse: [		^ self writeConditionalExpression: aPjIfTrueIfFalseNode test			then: aPjIfTrueIfFalseNode whenTrue			else: aPjIfTrueIfFalseNode whenFalse	].	self		nextPutAll: 'if(';		trueTest: aPjIfTrueIfFalseNode test;		writeNonBrace: '){';		visit: aPjIfTrueIfFalseNode whenTrue;		writeNonBrace: '}else{';		visit: aPjIfTrueIfFalseNode whenFalse;		writeNonBrace: $}! !!PjStringGenerator methodsFor: '*PharoJs-Base-Transpiler-Optimizations-Optimizations'!visitIfTrueNode: aPjIfTrueNode	self isAtStatementPrecedence ifFalse: [		^ self writeConditionalExpression: aPjIfTrueNode test then: PjNilNode new else: aPjIfTrueNode whenTrue	].	self		nextPutAll: 'if(';		trueTest: aPjIfTrueNode test;		writeNonBrace: '){';		visit: aPjIfTrueNode whenTrue;		writeNonBrace: $}! !!PjStringGenerator methodsFor: '*PharoJs-Base-Transpiler-Optimizations-Optimizations'!visitToDoByNode: aPjToDoByNode 	| step limit |	limit := aPjToDoByNode to constantOrZero.	self		nextPutAll: 'for(var ';		visit: aPjToDoByNode from.	limit = 0 ifTrue: [		self			nextPut: $,;			visit: aPjToDoByNode to].	aPjToDoByNode by ifNil: [		step := 1	] ifNotNil: [		step := aPjToDoByNode by constantOrZero.		step = 0 ifTrue: [			self				nextPut: $,;				visit: aPjToDoByNode by	].	].	self nextPut: $;.	step = 0 ifTrue: [		self			visit: aPjToDoByNode by target;			nextPutAll: '>=0?'].	step >= 0 ifTrue: [		self			visit: aPjToDoByNode from target;			nextPutAll: '<=';			visit: aPjToDoByNode to target].	step = 0 ifTrue: [	self nextPut: $:].	step <= 0 ifTrue: [		self			visit: aPjToDoByNode from target;			nextPutAll: '>=';			visit: aPjToDoByNode to target	].	self nextPut: $;.	step = 1 ifTrue: [ self nextPutAll: '++'].	step = -1 ifTrue: [ self nextPutAll: '--'].	self visit: aPjToDoByNode from target.	step abs = 1 ifFalse: [		self			nextPutAll: '+=';			visit: aPjToDoByNode by target	].	self writeLoopBody: aPjToDoByNode body! !!PjStringGenerator methodsFor: '*PharoJs-Base-Transpiler-Optimizations-Optimizations'!visitWhileNode: aPjWhileNode	self isAtStatementPrecedence		ifFalse: [ self error: 'PjWhileNode not at statement level' ].	self		nextPutAll: 'while(';		trueTest: aPjWhileNode test.	self writeLoopBody: aPjWhileNode body! !!PjStringGenerator methodsFor: '*PharoJs-Base-Transpiler-Optimizations-Optimizations'!writeConditionalExpression: test then: thenAst else: elseAst	self atPrecedence: ConditionalPrecedence do: [.		self			trueTest: test.		thenAst isLiteralTrue ifTrue: [			^ self				nextPutAll: '||';				visit: elseAst		].		elseAst isLiteralFalse ifTrue: [			^ self				nextPutAll: '&&';				visit: thenAst		].		self			nextPut: $?;			visit: thenAst;			nextPut: $:;			visit: elseAst	]! !!PjStringGenerator methodsFor: '*PharoJs-Base-Transpiler-Optimizations-Optimizations'!writeIfNilExpression: test then: thenAst else: elseAst	self writeConditionalExpression: (PjBinaryNode operator: #== left: test  right: PjNilNode new)		then: thenAst 		else: elseAst! !!PjStringGenerator methodsFor: '*PharoJs-Base-Transpiler-Optimizations-Optimizations'!writeLoopBody: body	self writeNonBrace: '){'.	body asOrderedCollection		do: [ :statement | statement acceptVisitor: self ]		separatedBy: [ self maybeWriteSemicolon ].	self writeCloseBrace! !"PharoJs-Base-Transpiler-Optimizations"!!PjTCollection commentStamp: '' prior: 0!I am the Collection trait.Because Collection cannot be inserted between Array and Object in the Javascript world, I have all the pieces that are needed by both PjCollection and PjArray.!!PjTArray commentStamp: '' prior: 0!I implement operations for array-like things in Javascript!!PjTArrayLike commentStamp: '' prior: 0!I provide behavior shared between JS classes that should have array-like behavior but that does not fit Array. Examples are: HTMLCollection and NodeList. From the JS point of view, they are not constructors, so we can't instantiate them for creating subcollections (as with e.g. allButFirst). So, we redefine method species to answer Array.!!PjTDate commentStamp: '' prior: 0!I gather methods shared by extensions to JS Date (PjTime, PjDate, PjDateAndTime)!!PjTDateAndTime commentStamp: '' prior: 0!A DateAndTime trait!!PjTDomController commentStamp: '' prior: 0!I provide behavior for a controller for DOM objects. I can subscribe to events (e.g. click, change, key stroke) to perform some action when they occur.The API allows handling both DOM objects direclty or by providing their IDs.!!PjTKernelClass commentStamp: '' prior: 0!An extension class is a class that provides methods to augment a javascript constructor, and thus provide primitive operations from the Pharo world.The convention is to name extension classes after the javascript constructor, prefixed by 'Pj'.!!PjTMagnitude commentStamp: '' prior: 0!I am the Magnitude trait.Because Magnitude cannot be inserted between Number and Object in the Javascript world, I have all the pieces that are needed by both PjMagnitude and PjNumber.!!PjDomController commentStamp: '' prior: 0!Generic controller for DOM objects in web browser!!PjDate commentStamp: '' prior: 0!Date representation as JavaScript Date!!PjDateAndTime commentStamp: '' prior: 0!DateAndTime representation as JavaScript Date!!PjTime commentStamp: '' prior: 0!Time in the Javascript world!!PjObject commentStamp: '' prior: 0!I represent the top-level Object constructor/class in JavascriptAll my direct subclasses exist as constructors/types in Javascript.  The classes exist to replace Smalltalk primitives or inlining.Methods from these classes are added to the built-in constructor prototypes or directly in the constructors.!!PjArray commentStamp: '' prior: 0!I represent the Javascript Array type.  I am the implementation for Arrays and OrderedCollections, since Javascript Arrays act pretty-much like Smalltalk OrderedCollections.!!PjByteArray commentStamp: '' prior: 0!I am the Javascript embodiment of ByteArray.!!PjSet commentStamp: '' prior: 0!I am the Javascript embodiment of Set.!!PjSortedCollection commentStamp: '' prior: 0!I am the Javascript embodiment of SortedCollection.!!PjStack commentStamp: '' prior: 0!I am a minimal implementation of Stack!!PjBoolean commentStamp: '' prior: 0!I represent the Javascript Boolean type.  Many of my operations may be optimized away, in which case these are fallbacks for perform: etc.!!PjCollection commentStamp: '' prior: 0!I am the Javascript embodiment of Collection.!!PjDictionary commentStamp: '' prior: 0!I am the Javascript embodiment of Dictionary.Note that the current implemenation uses objects, so only string keys are valid.!!PjIdentityDictionary commentStamp: '' prior: 0!I am the Javascript embodiment of IdentityDictionary.!!PjError commentStamp: '' prior: 0!I represent the Javascript Error type.!!PjFunction commentStamp: '' prior: 0!I represent the Javascript Function type.  I am the implementation for CompiledMethod and BlockClosure.All the instance creation category *should* be in PjClass instead, but is here so new etc. work on ordinary Javascript "classes".!!PjClass commentStamp: '' prior: 0!I am the implementation for Class and Behavior.I am a subclass of Javascript Function with appropriate methods for Class and Behavior.!!PjHTMLCollection commentStamp: '' prior: 0!I provide Smalltalk method to the HTMLCollection "class" in web browsers. Should not be included in NodeJS code.!!PjMagnitude commentStamp: '' prior: 0!I am the Javascript embodiment of Magnitude.!!PjDuration commentStamp: '' prior: 0!Duration representation!!PjLookupKey commentStamp: '' prior: 0!I am the Javascript embodiment of LookupKey.!!PjAssociation commentStamp: '' prior: 0!I am the Javascript embodiment of Association.!!PjMargin commentStamp: '' prior: 0!I am an empty implementation of Margin because Point has an asMargin method we don't support.!!PjNodeList commentStamp: '' prior: 0!I provide Smalltalk method to the NodeList "class" in web browsers. Should not be included in NodeJS code.!!PjNumber commentStamp: '' prior: 0!I represent the Javascript Number type.  I am the implementation for Integer, Float, and Number, since Javascript Numbers are the only kind of numbers available.!!PjReadWriteStream commentStamp: '' prior: 0!I am the common code for the simplistic ReadWriteStream.Because strings and arrays are very different in Javascript,I have subclasses that implement those differences.!!PjArrayStream commentStamp: '' prior: 0!I am a simplistic implementation of an Array ReadWriteStream!!PjStringStream commentStamp: '' prior: 0!I am a simplistic implementation of a String ReadWriteStream!!PjRectangle commentStamp: '' prior: 0!I am a minimal implementation of Rectangle, just so Point can create me.!!PjRxParser commentStamp: '' prior: 0!I am a minimal implementation of RxParser.!!PjSharedPool commentStamp: '' prior: 0!I am the Javascript embodiment of SharedPool.!!PjString commentStamp: '' prior: 0!strings in Javascript world!!PjUndefinedObject commentStamp: '' prior: 0!I am the implementation for UndefinedObject. Any method calls translate the Javascript values "undefined" and "null" into my sole instance using the global function $isNil$, so that method dispatch will happen through me.!!PjTArray classTrait methodsFor: 'enumerating'!collect_jsGenerator: transpiler	<pharoJsSkip> 	^'var result=[];for(var i=0,max=this.length;i<max;++i)result.push(typeof aBlock=="string"?$asNil$(this[i]).', transpiler pharoJsSelectorPrefix, 'perform_(aBlock):aBlock(this[i]));return result'! !!PjTArray classTrait methodsFor: 'testing'!includes_jsGenerator: transpiler	<pharoJsSkip>	^'if (x.', transpiler pharoJsSelectorPrefix, 'isJSPrimitiveType()) {		if (this.includes(x)) return true;		for(var i=this.length-1;i>=0;--i) if (x==this[i]) return true;		return false}			for(var i=this.length-1;i>=0;--i) if (x.', transpiler pharoJsSelectorPrefix, '61_(this[i])) return true;	return false'! !!PjTArray classTrait methodsFor: 'pharoJs support'!jsTranspilationImportMethods	<pharoJsSkip>	^ self jsTranspilationImportMethodsArray! !!PjTArray classTrait methodsFor: 'pharoJs support'!jsTranspilationImportMethodsArray	<pharoJsSkip>	^ self jsTranspilationImportMethodsCollection , { 		  (Array		   ->			   #( isArray shouldBePrintedAsLiteral			      printAsLiteralFormOn: isSelfEvaluating printAsSelfEvaluatingFormOn:			      isLiteral )).		  (ByteArray -> #( asString )).		  (OrderedCollection -> #( join: addAllLast: )).		  (Collection -> #( doWithIndex: printElementsOn: printNameOn: )).		  (SequenceableCollection		   ->			   #( withIndexDo: allButFirst allButFirst: allButLast allButLast:			      #copyFrom:to: #copyReplaceFrom:to:with:			      copyWith: copyWithFirst: copyWithoutIndex: #from:to:put:			      grownBy: #replaceFrom:to:with: reverseDo: appendTo: putOn: )).		  (ArrayedCollection class		   -> #( with: #with:with: #with:with:with: #with:with:with:with: )) }! !!PjTArray classTrait methodsFor: 'enumerating'!select_jsGenerator: transpiler	<pharoJsSkip> 	^'var result=[];for(var i=0,max=this.length;i<max;++i){if(true==(typeof aBlock=="string"?$asNil$(this[i]).', transpiler pharoJsSelectorPrefix, 'perform_(aBlock):aBlock(this[i])))result.push(this[i])}return result'! !!PjTArray methodsFor: 'copying'!, other	^ self class new addAll: self; addAll: other; yourself! !!PjTArray methodsFor: 'enumerating'!= anArray	self == anArray ifTrue: [ ^true ].	(anArray isKindOf: Array) ifFalse: [^false].	self size = anArray size ifFalse: [ ^false ].	self with: anArray do: [ : myElement : otherElement|		myElement = otherElement ifFalse: [ ^false ]	].	^true! !!PjTArray methodsFor: 'converting'!asArray	^ Array from: self! !!PjTArray methodsFor: 'converting'!asJsObject	| jsObject |	self isEmpty ifTrue: [ ^ self ].	(self first isKindOf: Association) ifFalse: [		^ self collect: [: each | each asJsObject ]	].	jsObject := Object new.	self do: [ : association |		jsObject at: association key put: association value asJsObject].	^jsObject! !!PjTArray methodsFor: 'converting'!asSortedCollection	^ SortedCollection new addAll: self;yourself! !!PjTArray methodsFor: 'accessing'!at: i	<javascript: 'return this[i-1]'>! !!PjTArray methodsFor: 'accessing'!at: index ifAbsent: aBlock	(index > 0 and: [index > self size]) ifTrue: [ ^aBlock value ].	^self at: index! !!PjTArray methodsFor: 'enumerating'!collect: aBlock	<jsGenerator: #collect_jsGenerator:>! !!PjTArray methodsFor: 'enumerating'!do: aBlock	<javascript: 'for(var i=0,max=this.length;i<max;++i)aBlock(this[i]);return this'>! !!PjTArray methodsFor: 'enumerating'!do: elementBlock separatedBy: separatorBlock	<javascript: 'for(var i=0,max=this.length;i<max;++i){if(i)separatorBlock();elementBlock(this[i])};return this'>! !!PjTArray methodsFor: 'accessing'!eighth	<javascript: 'return this[7]'>! !!PjTArray methodsFor: 'accessing'!fifth	<javascript: 'return this[4]'>! !!PjTArray methodsFor: 'accessing'!first	<javascript: 'return this[0]'>! !!PjTArray methodsFor: 'accessing'!first: n	<javascript: 'return this.slice(0,n)'>! !!PjTArray methodsFor: 'accessing'!fourth	<javascript: 'return this[3]'>! !!PjTArray methodsFor: 'testing'!ifEmpty: aBlock	self isEmpty ifTrue: [^aBlock value].	^self! !!PjTArray methodsFor: 'testing'!includes: x	<jsGenerator: #includes_jsGenerator:>! !!PjTArray methodsFor: 'accessing'!indexOf: x	<javascript: 'return this.indexOf(x)+1'>! !!PjTArray methodsFor: 'accessing'!indexOf: x startingAt: n	<javascript: 'return this.indexOf(x,n-1)+1'>! !!PjTArray methodsFor: 'accessing'!insert: anObject before: spot	<javascript: 'this.splice(spot-1, 0, anObject);return anObject'>! !!PjTArray methodsFor: 'testing'!isEmpty	^ self size = 0! !!PjTArray methodsFor: 'accessing'!last	<javascript: 'return this[this.length-1]'>! !!PjTArray methodsFor: 'accessing'!last: n	<javascript: 'return this.slice(this.length-n)'>! !!PjTArray methodsFor: 'accessing'!ninth	<javascript: 'return this[8]'>! !!PjTArray methodsFor: 'enumerating'!notEmpty	<javascript: 'return this.length!!=0'>! !!PjTArray methodsFor: 'converting'!reversed	^ self asArray reverse! !!PjTArray methodsFor: 'accessing'!second	<javascript: 'return this[1]'>! !!PjTArray methodsFor: 'enumerating'!select: aBlock	<jsGenerator: #select_jsGenerator:>! !!PjTArray methodsFor: 'accessing'!seventh	<javascript: 'return this[6]'>! !!PjTArray methodsFor: 'accessing'!sixth	<javascript: 'return this[5]'>! !!PjTArray methodsFor: 'enumerating'!size	<javascript: 'return this.length'>! !!PjTArray methodsFor: 'accessing'!third	<javascript: 'return this[2]'>! !!PjTArray methodsFor: 'enumerating'!with: otherCollection do: aBlock 	<javascript: 'for(var i=0,max=this.length;i<max;++i)aBlock(this[i],otherCollection[i]);return this'>! !!PjTArray methodsFor: 'enumerating'!withIndexDo: aBlock 	<javascript: 'for(var i=0,max=this.length;i<max;++i)aBlock(this[i],i+1);return this'>! !!PjTArrayLike methodsFor: 'accessing'!indexOf: x	<javascript: 'for(var i = 0; i < this.length; i++){		if(x == this[i]){return i + 1}	}	return 0;	'>! !!PjTArrayLike methodsFor: 'accessing'!species	^Array! !!PjTCollection classTrait methodsFor: 'random'!atRandom_jsGenerator: transpiler	<pharoJsSkip>	^'var randomIndex = Math.floor((Math.random() * this.', transpiler pharoJsSelectorPrefix, 'size()) + 1);	return this.', transpiler pharoJsSelectorPrefix, 'at_(randomIndex);'! !!PjTCollection classTrait methodsFor: 'pharojs support'!jsTranspilationImportMethodsCollection	<pharoJsSkip>	^ {		Collection ->#(asSet reject: asOrderedCollection			allSatisfy: anySatisfy: noneSatisfy: inject:into: 			detect:ifFound:ifNone: detect:ifNone: detect:ifFound: remove: isCollection 			asDictionary associationsDo: addAll: isEmptyOrNil removeAll: 			includesAll: includesAny:		).		Collection class ->#(			withAll: 		).		OrderedCollection class -> #( newFrom: ).	}! !!PjTCollection methodsFor: 'testing'!= aMagnitude	^self explicitRequirement! !!PjTCollection methodsFor: 'random'!atRandom	<jsGenerator: #atRandom_jsGenerator:>! !!PjTDate classTrait methodsFor: 'pharoJs support'!javascriptName	<pharoJsSkip>	^ #Date! !!PjTDate classTrait methodsFor: 'instance creation'!now	<javascript: 'return new this()'>! !!PjTDate classTrait methodsFor: 'instance creation'!today	^self now! !!PjTDate methodsFor: 'converting'!asDateAndTime	^self! !!PjTDate methodsFor: 'accessing'!dayOfMonth	^self getDate! !!PjTDate methodsFor: 'accessing'!dayOfWeek	^self getDay + 1! !!PjTDate methodsFor: 'accessing'!monthIndex	^self getMonth + 1! !!PjTDate methodsFor: 'accessing'!monthIndex: anInteger	^self month: anInteger - 1! !!PjTDate methodsFor: 'accessing'!year	^self getFullYear! !!PjTDateAndTime classTrait methodsFor: 'pharoJs support'!javascriptName	<pharoJsSkip>	^ #Date! !!PjTDateAndTime classTrait methodsFor: 'instance creation'!now	<javascript: 'return new this()'>! !!PjTDateAndTime methodsFor: 'converting'!asDateAndTime	^self! !!PjTDateAndTime methodsFor: 'accessing'!dayOfMonth	^self getDate! !!PjTDateAndTime methodsFor: 'accessing'!dayOfWeek	^self getDay + 1! !!PjTDateAndTime methodsFor: 'accessing'!hour	^self hour24! !!PjTDateAndTime methodsFor: 'accessing'!hour12	| hour24 |	hour24 := self hour24.	hour24 = 0 ifTrue: [ ^12 ].	hour24 > 12 ifTrue: [ ^hour24 - 12 ].	^hour24! !!PjTDateAndTime methodsFor: 'accessing'!hour24	^self getHours! !!PjTDateAndTime methodsFor: 'accessing'!milliSecond	^self getMilliseconds! !!PjTDateAndTime methodsFor: 'accessing'!minute	^self getMinutes! !!PjTDateAndTime methodsFor: 'accessing'!monthIndex	^self getMonth + 1! !!PjTDateAndTime methodsFor: 'accessing'!monthIndex: anInteger	^self month: anInteger - 1! !!PjTDateAndTime methodsFor: 'accessing'!second	^self getSeconds! !!PjTDateAndTime methodsFor: 'accessing'!year	^self getFullYear! !!PjTDomController methodsFor: 'creating'!addElement: tagString	^self addElement: tagString to: self body! !!PjTDomController methodsFor: 'creating'!addElement: tagString style: cssStyleAssociations	^self addElement: tagString to: self body style: cssStyleAssociations! !!PjTDomController methodsFor: 'creating'!addElement: tagString to: parentNode	| newElement |	newElement := self createElement: tagString.	parentNode appendChild: newElement.	^newElement! !!PjTDomController methodsFor: 'creating'!addElement: tagString to: parentNode style: cssStyleAssociations	| newElement |	newElement := self createElement: tagString style: cssStyleAssociations.	parentNode appendChild: newElement.	^ newElement! !!PjTDomController methodsFor: 'accessing'!attribute: attributeName at: elementId	^self attribute: attributeName ofElement: (self elementAt: elementId)! !!PjTDomController methodsFor: 'accessing'!attribute: attributeName at: elementId set: attributeValue	self attribute: attributeName ofElement: (self elementAt: elementId) set: attributeValue! !!PjTDomController methodsFor: 'accessing'!attribute: attributeName ofElement: domElement	^domElement getAttribute: attributeName! !!PjTDomController methodsFor: 'accessing'!attribute: attributeName ofElement: domElement set: attributeValue	domElement setAttribute: attributeName to: attributeValue! !!PjTDomController methodsFor: 'accessing'!body	^self document body! !!PjTDomController methodsFor: 'creating'!createElement: tagString 	^self document createElement: tagString.! !!PjTDomController methodsFor: 'creating'!createElement: tagString style: cssStyleAssociations	| newElement |	newElement := self document createElement: tagString.	self setElement: newElement style: cssStyleAssociations.	^newElement! !!PjTDomController methodsFor: 'css'!cssClassesAddAll: newClasses element: domElement	self cssClassesReplaceAll: #() byAll: newClasses element: domElement! !!PjTDomController methodsFor: 'css'!cssClassesElement: domElement	^(' ' split: (self cssClassesStringElement: domElement)) 		"asOrderedCollection reject: [ : each | each isEmpty]"! !!PjTDomController methodsFor: 'css'!cssClassesElement: domElement set: cssClasses	| classString |	classString := ''.	cssClasses do: [: each |		classString := classString, ' ', each  ].	self cssClassesStringElement: domElement set: classString! !!PjTDomController methodsFor: 'css'!cssClassesRemoveAll: oldCssClasses element: domElement	self cssClassesReplaceAll: oldCssClasses byAll: #() element: domElement! !!PjTDomController methodsFor: 'css'!cssClassesReplaceAll: oldCssClasses byAll: newClasses element: domElement	| cssClasses |	cssClasses := self cssClassesElement: domElement.	oldCssClasses do: [: each | cssClasses remove: each ifAbsent: nil].	cssClasses addAll: newClasses.	self cssClassesElement: domElement set: cssClasses.! !!PjTDomController methodsFor: 'css'!cssClassesString: elementId	^ self cssClassesStringElement: (self elementAt: elementId)! !!PjTDomController methodsFor: 'css'!cssClassesString: elementId set: attributeValue	^ self attribute: #class at: elementId set: attributeValue! !!PjTDomController methodsFor: 'css'!cssClassesStringElement: domElement	^ (self attribute: #class ofElement: domElement) ifNil: [ '' ]! !!PjTDomController methodsFor: 'css'!cssClassesStringElement: domElement set: newClassesString	self attribute: #class ofElement: domElement set: newClassesString! !!PjTDomController methodsFor: 'accessing'!document	self explicitRequirement! !!PjTDomController methodsFor: 'accessing'!elementAt: elementId	^self document getElementById: elementId! !!PjTDomController methodsFor: 'accessing'!elementAt: childId in: container	"Method querySelector: Returns the first child element that matches a specified 	CSS selector(s) of an element. To search for an element by Id, we need to use	a sharp (#) as prefix. A dot (.) should be used for searching by class"	^container querySelector: '#', childId.! !!PjTDomController methodsFor: 'visibility'!hide: domElement	domElement style display: 'none'! !!PjTDomController methodsFor: 'visibility'!hideElementAt: domElementId in: container	self show: false elementAt: domElementId in: container! !!PjTDomController methodsFor: 'accessing'!innerHtmlAt: elementId	^(self elementAt: elementId) innerHTML! !!PjTDomController methodsFor: 'accessing'!innerHtmlAt: elementId set: aString	(self elementAt: elementId) innerHTML: aString! !!PjTDomController methodsFor: 'event init'!onChange: elementId do: aBlock	self onChange: elementId in: self body do: aBlock! !!PjTDomController methodsFor: 'event init'!onChange: elementId in: container do: aBlock	| element |	element := self elementAt: elementId in: container.	self onChangeElement: element do: aBlock! !!PjTDomController methodsFor: 'event init'!onChangeElement: element do: aBlock	element addEventListener: #change block: [ aBlock cull: element value cull: element ]! !!PjTDomController methodsFor: 'event init'!onClick: elementId  do: aBlock	self onClick: elementId in: self body do: aBlock! !!PjTDomController methodsFor: 'event init'!onClick: elementId in: container do: aBlock	| element |	element := self elementAt: elementId in: container.	self onClickElement: element do: aBlock! !!PjTDomController methodsFor: 'event init'!onClickElement: element do: aBlock	element addEventListener: #click block: [ aBlock cull: element ].! !!PjTDomController methodsFor: 'event init'!onEvent: eventId for: elementId in: container do: aBlock	| element |	element := self elementAt: elementId in: container.	element addEventListener: eventId block: aBlock! !!PjTDomController methodsFor: 'event init'!onKeyUp: elementId do: aBlock	self onKeyUp: elementId in: self body do: aBlock! !!PjTDomController methodsFor: 'event init'!onKeyUp: elementId in: container do: aBlock	| element |	element := self elementAt: elementId in: container.	self onKeyUpElement: element do: aBlock! !!PjTDomController methodsFor: 'event init'!onKeyUpElement: element do: aBlock	element addEventListener: #keyup block: [aBlock cull: element value cull: element ]! !!PjTDomController methodsFor: 'css'!setElement: domElement style: cssStyleAssociations	| style |	style := domElement style.	cssStyleAssociations asDictionary keysAndValuesDo: [ :key :value | 		style at: key put: value ]! !!PjTDomController methodsFor: 'visibility'!show: domElement	domElement style display: ''! !!PjTDomController methodsFor: 'visibility'!show: aBoolean element: domElement	aBoolean ifTrue: [ ^self show: domElement ].	self hide: domElement! !!PjTDomController methodsFor: 'visibility'!show: aBoolean elementAt: domElementId in: container	| element |	element := self elementAt: domElementId in: container.	self show: aBoolean element: element! !!PjTDomController methodsFor: 'visibility'!showElementAt: domElementId in: container	self show: true elementAt: domElementId in: container! !!PjTKernelClass classTrait methodsFor: 'pharoJs support'!javascriptName	<pharoJsSkip>	^ (self name allButFirst: 2) asSymbol! !!PjTMagnitude classTrait methodsFor: 'pharoJs support'!jsTranspilationImportMethodsMagnitude	<pharoJsSkip>	^ {Magnitude -> #(				min: max: min:max: between:and: 				compareWith:ifLesser:ifEqual:ifGreater: 				> <= >=			).		}! !!PjTMagnitude methodsFor: 'testing'!< aMagnitude	^self explicitRequirement! !!PjTMagnitude methodsFor: 'testing'!= aMagnitude	^self explicitRequirement! !!Dictionary class methodsFor: '*PharoJs-Base-JS-CoreLibraries'!javascriptPlaceholder	^ PjDictionary! !!Set class methodsFor: '*PharoJs-Base-JS-CoreLibraries'!javascriptPlaceholder	^ PjSet! !!ArrayedCollection class methodsFor: '*PharoJs-Base-JS-CoreLibraries'!javascriptPlaceholder	^ PjArray! !!Object class methodsFor: '*PharoJs-Base-JS-CoreLibraries'!javascriptPlaceholder	^PjObject! !!Object methodsFor: '*PharoJs-Base-JS-CoreLibraries-converting'!asJsObject	^PjJsObjectBuilder convert: self! !!Object methodsFor: '*PharoJs-Base-JS-CoreLibraries-converting'!asJsObjectUsing: converter	| dict value |	dict := Dictionary new.	self class instVarNames do: [ : iv |		value := self instVarNamed: iv.		value ifNotNil: [ dict at: iv put: (converter convert: value)] ].	^dict! !!Object methodsFor: '*PharoJs-Base-JS-CoreLibraries'!isPjProxyOrNil	^ false! !!Object methodsFor: '*PharoJs-Base-JS-CoreLibraries'!setTimeout: aBlock afterMilliseconds: anInteger	[anInteger milliSeconds wait.	aBlock value] fork! !!PjJsObjectBuilder class methodsFor: 'converting'!convert: anObject	^self new convert: anObject! !!PjJsObjectBuilder methodsFor: 'converting'!convert: anObject	| jsObject |	convertedObjects at: anObject ifPresent: [: cachedJsObject | ^cachedJsObject].	jsObject := anObject asJsObjectUsing: self.	convertedObjects at: anObject put: jsObject.	^jsObject! !!PjJsObjectBuilder methodsFor: 'initialize-release'!initialize	super initialize.	convertedObjects := Dictionary new! !!Behavior class methodsFor: '*PharoJs-Base-JS-CoreLibraries'!javascriptPlaceholder	^PjClass! !!Behavior methodsFor: '*PharoJs-Base-JS-CoreLibraries'!subclassesDo: aBlock	"Evaluate the argument, aBlock, for each of the receiver's immediate subclasses."	self subclasses do: aBlock! !!Stack class methodsFor: '*PharoJs-Base-JS-CoreLibraries'!javascriptPlaceholder	^ PjStack! !!PjDomController class methodsFor: 'accessing'!document	^document! !!PjDomController methodsFor: 'accessing'!document	^document! !!DateAndTime class methodsFor: '*PharoJs-Base-JS-CoreLibraries-Chronology'!javascriptPlaceholder	<pharoJsSkip>	^PjDateAndTime! !!DateAndTime methodsFor: '*PharoJs-Base-JS-CoreLibraries'!getTime	" answer number of milliseconds since unix epoch (midnight Jan 1, 1970, UTC)	 - for compatibility with Javascript "	^ self asUnixTime * 1000! !!Rectangle class methodsFor: '*PharoJs-Base-JS-CoreLibraries'!javascriptPlaceholder	^PjRectangle! !!PjDate class methodsFor: 'instance creation'!fromString: aString	<javascript: 'return new this(aString)'>! !!PjDate class methodsFor: 'pharoJs support'!javascriptName	<pharoJsSkip>	^ #Date! !!PjDate class methodsFor: 'instance creation'!now	<javascript: 'return new this()'>! !!PjDate class methodsFor: 'instance creation'!today	^self now! !!PjDate methodsFor: 'converting'!asDateAndTime	^self! !!PjDate methodsFor: 'accessing'!dayOfMonth	^self getDate! !!PjDate methodsFor: 'accessing'!dayOfWeek	^self getDay + 1! !!PjDate methodsFor: 'accessing'!monthIndex	^self getMonth + 1! !!PjDate methodsFor: 'accessing'!monthIndex: anInteger	^self month: anInteger - 1! !!PjDate methodsFor: 'accessing'!year	^self getFullYear! !!PjDateAndTime class methodsFor: 'instance creation'!basicfromString: aString	<javascript: 'return new this(aString)'>! !!PjDateAndTime class methodsFor: 'instance creation'!fromString: aString	| offset |	'[-+](\d\d)\:(\d\d)$' asRegex matchesIn: aString do: [ :match | 		| sign hoursAndMinutes |		sign := (match includes: $+)			        ifTrue: [ 1 ]			        ifFalse: [ -1 ].		hoursAndMinutes := '(\d\d)' asRegex matchesIn: match.		offset := (sign * hoursAndMinutes first asNumber * 60		           + (sign * hoursAndMinutes second asNumber)) minutes ].	^ (self basicfromString: aString)		  offset: offset;		  yourself! !!PjDateAndTime class methodsFor: 'pharoJs support'!javascriptName	<pharoJsSkip>	^ #Date! !!PjDateAndTime class methodsFor: 'pharoJs support'!jsTranspilationImportMethods	<pharoJsSkip>	^ { 		  (DateAndTime class		   -> #( #todayHour:minute: #tomorrowHour:minute: )).		  (DateAndTime -> #( daysInYear )) }! !!PjDateAndTime class methodsFor: 'instance creation'!now	<javascript: 'return new this()'>! !!PjDateAndTime class methodsFor: 'instance creation'!todayHour: hour minute: minute second: second	"setXXX methods are defined in JS"	^self new		setHours: hour;		setMinutes: minute;		setSeconds: second;		yourself! !!PjDateAndTime class methodsFor: 'instance creation'!tomorrowHour: hour minute: minute second: second	^(self todayHour: hour minute: minute second: second) + 1 day! !!PjDateAndTime class methodsFor: 'instance creation'!year: year month: month1To12 day: day1To31 hour: hour minute: minute second: second	<javascript: 'return new this(year, month1To12 - 1, day1To31, hour, minute, second)'>! !!PjDateAndTime methodsFor: 'arithmetics'!+ otherObject	^otherObject addDateAndTime: self! !!PjDateAndTime methodsFor: 'arithmetics'!- anObject	^anObject subtractFromDateAndTime: self! !!PjDateAndTime methodsFor: 'converting'!asDateAndTime	^self! !!PjDateAndTime methodsFor: 'printing'!basicPrintString	<javascript: 'let d;	d = [    "0" + (this.getMonth() + 1),    "0" + this.getDate(),    "0" + this.getHours(),    "0" + this.getMinutes(),    "0" + this.getSeconds()  ].map(component => component.slice(-2)); // take last 2 digits of every component  // join the components into date  return ("000"+ this.getFullYear()).slice(-4)+"-"+d.slice(0, 2).join("-")+ "T" + d.slice(2,5).join(":")'> ! !!PjDateAndTime methodsFor: 'arithmetics'!basicSubtractFromDateAndTime: other	<javascript: 'return other - this;'>! !!PjDateAndTime methodsFor: 'accessing'!dayOfMonth	^self getDate! !!PjDateAndTime methodsFor: 'accessing'!dayOfWeek	^self getDay + 1! !!PjDateAndTime methodsFor: 'accessing'!hour	^self hour24! !!PjDateAndTime methodsFor: 'accessing'!hour12	| hour24 |	hour24 := self hour24.	hour24 = 0 ifTrue: [ ^12 ].	hour24 > 12 ifTrue: [ ^hour24 - 12 ].	^hour24! !!PjDateAndTime methodsFor: 'accessing'!hour24	^self getHours! !!PjDateAndTime methodsFor: 'accessing'!milliSecond	^self getMilliseconds! !!PjDateAndTime methodsFor: 'accessing'!minute	^self getMinutes! !!PjDateAndTime methodsFor: 'accessing'!monthIndex	^self getMonth + 1! !!PjDateAndTime methodsFor: 'accessing'!monthIndex: anInteger	^self month: anInteger - 1! !!PjDateAndTime methodsFor: 'accessing'!offset	^ offset ifNil: [ offset := (-1 * self getTimezoneOffset) minutes ]! !!PjDateAndTime methodsFor: 'accessing'!offset: aDuration	offset := aDuration! !!PjDateAndTime methodsFor: 'printing'!printOn: str	str << (self getTimezoneOffset minutes addDateAndTime:		 (self offset addDateAndTime: self)) basicPrintString.	self offset printStringAsTimzoneOn: str! !!PjDateAndTime methodsFor: 'accessing'!second	^self getSeconds! !!PjDateAndTime methodsFor: 'arithmetics'!subtractFromDateAndTime: aDateAndTime	^Duration milliSeconds: (self basicSubtractFromDateAndTime: aDateAndTime)! !!PjDateAndTime methodsFor: 'accessing'!year	^self getFullYear! !!PjTime class methodsFor: 'instance creation'!hour: hour minute: minute second: second milliSecond: milliseconds	<javascript: '	var today = new Date();	return new Date(today.getFullYear(), today.getMonth(), today.getDate(), hour, minute, second, milliseconds);'>! !!PjTime class methodsFor: 'instance creation'!hour: hour minute: minute second: second nanoSecond: nanoCount	^self hour: hour minute: minute second: second milliSecond: nanoCount // 1000000! !!PjTime class methodsFor: 'pharoJs support'!javascriptName	<pharoJsSkip>	^ #Date! !!PjTime class methodsFor: 'pharoJs support'!jsTranspilationImportMethods	<pharoJsSkip>	| classSelectors instanceSelectors |	classSelectors := Time class 		selectorsInProtocols: #('instance creation' '*PharoExtra-instance creation' '*Kernel-Chronology-Extras')  		exclude: #(now nowLocal fromString: readFrom: seconds:nanoSeconds: seconds:  hour:minute:second:milliSecond: hour:minute:second:nanoSecond:		benchmarkMillisecondClock benchmarkPrimitiveResponseDelay dateAndTimeFromSeconds:		). 	instanceSelectors := Time 		selectorsInProtocols: #(accessing "adding comparing converting")		exclude: #(hour12 hour24 minute second).	^{Time class -> classSelectors.	Time -> instanceSelectors }! !!PjTime class methodsFor: 'clock'!millisecondClockValue	<javascript: 'if(typeof performance=="object") return performance.now();if(typeof process=="object"){var hr=process.hrtime();return hr[0]*1000+hr[1]/1000000}return Date.now()'>! !!PjTime class methodsFor: 'instance creation'!now	<javascript: 'return new this()'>! !!PjTime class methodsFor: 'instance creation'!seconds: seconds	^self seconds: seconds nanoSeconds: 0! !!PjTime class methodsFor: 'instance creation'!seconds: seconds nanoSeconds: nanoCount	"Answer a Time from midnight."	^self basicNew		seconds: seconds nanoSeconds: nanoCount;		yourself! !!PjTime methodsFor: 'converting'!asDateAndTime	^self! !!PjTime methodsFor: 'converting'!asSeconds	^(self hour24 * 3600) + (self minute * 60) + self seconds! !!PjTime methodsFor: 'accessing'!dayOfMonth	^self getDate! !!PjTime methodsFor: 'accessing'!dayOfWeek	^self getDay + 1! !!PjTime methodsFor: 'accessing'!hour	^self hour24! !!PjTime methodsFor: 'accessing'!hour12	| hour24 |	hour24 := self hour24.	hour24 = 0 ifTrue: [ ^12 ].	hour24 > 12 ifTrue: [ ^hour24 - 12 ].	^hour24! !!PjTime methodsFor: 'accessing'!hour24	^self getHours! !!PjTime methodsFor: 'accessing'!milliSecond	^self getMilliseconds! !!PjTime methodsFor: 'accessing'!minute	^self getMinutes! !!PjTime methodsFor: 'accessing'!monthIndex	^self getMonth + 1! !!PjTime methodsFor: 'accessing'!monthIndex: anInteger	^self month: anInteger - 1! !!PjTime methodsFor: 'accessing'!second	^self getSeconds! !!PjTime methodsFor: 'private'!seconds: secondCount	| minuteSecondsCount |	self setHours: (secondCount quo: SecondsInHour).	minuteSecondsCount := secondCount rem: SecondsInHour.	self setMinutes: (minuteSecondsCount quo: SecondsInMinute).	self setSeconds: (minuteSecondsCount rem: SecondsInMinute).! !!PjTime methodsFor: 'private'!seconds: secondCount nanoSeconds: nanoCount 	self seconds: secondCount.	self setMilliseconds: nanoCount//1000000! !!PjTime methodsFor: 'private'!ticks: anArray	"ticks is an Array: { days. seconds. nanoSeconds }"	self seconds: (anArray at: 2) nanoSeconds: anArray last! !!PjTime methodsFor: 'accessing'!year	^self getFullYear! !!SharedPool class methodsFor: '*PharoJs-Base-JS-CoreLibraries'!javascriptPlaceholder	^PjSharedPool! !!SmallInteger class methodsFor: '*PharoJs-Base-JS-CoreLibraries'!javascriptPlaceholder	^ PjNumber! !!String class methodsFor: '*PharoJs-Base-JS-CoreLibraries'!javascriptPlaceholder	^ PjString! !!String methodsFor: '*PharoJs-Base-JS-CoreLibraries-converting'!asJsObjectUsing: converter	^self! !!Symbol class methodsFor: '*PharoJs-Base-JS-CoreLibraries'!javascriptPlaceholder	^ PjString! !!LookupKey class methodsFor: '*PharoJs-Base-JS-CoreLibraries'!javascriptPlaceholder	^PjLookupKey! !!IdentityDictionary class methodsFor: '*PharoJs-Base-JS-CoreLibraries'!javascriptPlaceholder	^ PjIdentityDictionary! !!Character class methodsFor: '*PharoJs-Base-JS-CoreLibraries'!javascriptPlaceholder	^ PjString! !!Magnitude class methodsFor: '*PharoJs-Base-JS-CoreLibraries'!javascriptPlaceholder	^ PjMagnitude! !!Magnitude methodsFor: '*PharoJs-Base-JS-CoreLibraries-converting'!asJsObjectUsing: converter	^self! !!OrderedCollection class methodsFor: '*PharoJs-Base-JS-CoreLibraries-Kernel'!javascriptPlaceholder	^ PjArray! !!ByteArray class methodsFor: '*PharoJs-Base-JS-CoreLibraries'!javascriptPlaceholder	^ PjByteArray! !!ProtoObject class methodsFor: '*PharoJs-Base-JS-CoreLibraries'!javascriptPlaceholder	^PjObject! !!Integer class methodsFor: '*PharoJs-Base-JS-CoreLibraries'!javascriptPlaceholder	^ PjNumber! !!ClassDescription methodsFor: '*PharoJs-Base-JS-CoreLibraries'!selectorsInProtocols: protocols	<pharoJsSkip>	| selectors |	selectors := Set new.	protocols do: [ : protocol |		selectors addAll: (self selectorsInProtocol: protocol)].	^selectors! !!ClassDescription methodsFor: '*PharoJs-Base-JS-CoreLibraries'!selectorsInProtocols: protocols exclude: excludedSelectors	<pharoJsSkip>	| selectors |	selectors := self selectorsInProtocols: protocols. 	^selectors copyWithoutAll: excludedSelectors! !!Date class methodsFor: '*PharoJs-Base-JS-CoreLibraries'!javascriptPlaceholder	<pharoJsSkip>	^PjDate! !!Duration class methodsFor: '*PharoJs-Base-JS-CoreLibraries-Chronology'!javascriptPlaceholder	<pharoJsSkip>	^PjDuration! !!Association class methodsFor: '*PharoJs-Base-JS-CoreLibraries'!javascriptPlaceholder	^PjAssociation! !!Boolean class methodsFor: '*PharoJs-Base-JS-CoreLibraries'!javascriptPlaceholder	^ PjBoolean! !!Boolean methodsFor: '*PharoJs-Base-JS-CoreLibraries-converting'!asJsObjectUsing: converter	^self! !!Error class methodsFor: '*PharoJs-Base-JS-CoreLibraries'!javascriptPlaceholder	^PjError! !!PjArray class methodsFor: 'class initialization'!javascriptInitialize 	Smalltalk at: #OrderedCollection put: Array! !!PjArray class methodsFor: 'instance creation'!new: ignored	^ self new! !!PjArray class methodsFor: 'instance creation'!streamContents: aBlock	| stream |	stream := PjArrayStream new.	aBlock value: stream.	^ stream contents! !!PjArray class methodsFor: 'instance creation'!with: anObject 	"Answer a new instance of me, containing only anObject."	<javascript: 'return [anObject]'>! !!PjArray class methodsFor: 'instance creation'!with: firstObject with: secondObject 	"Answer a new instance of me, containing firstObject and secondObject."	<javascript: 'return [firstObject,secondObject]'>! !!PjArray methodsFor: 'enumerating'!add: x	^ self addLast: x! !!PjArray methodsFor: 'enumerating'!addFirst: x	<javascript: 'this.unshift(x);return x'>! !!PjArray methodsFor: 'enumerating'!addLast: x	<javascript: 'this.push(x);return x'>! !!PjArray methodsFor: 'enumerating'!at: i put: x	<javascript: 'return this[i-1]=x'>! !!PjArray methodsFor: 'printing'!printOn: aStream	"Merging printOn: methods of Array and Collection because JS Array directly inherits from Object"	self shouldBePrintedAsLiteral ifTrue: [ 		self printAsLiteralFormOn: aStream.		^ self ].	self isSelfEvaluating ifTrue: [ 		self printAsSelfEvaluatingFormOn: aStream.		^ self ].	self printNameOn: aStream.	self printElementsOn: aStream! !!PjArray methodsFor: 'accessing'!readStream	^ PjArrayStream on: self! !!PjArray methodsFor: 'removing'!remove: oldObject ifAbsent: absentBlock	| index |	index := self findIndex: [ : each | oldObject = each ].	index >= 0 ifTrue: [ ^ self removeAt: index + 1].	^ absentBlock value! !!PjArray methodsFor: 'removing'!removeAll	self size timesRepeat: [ self removeFirst ]! !!PjArray methodsFor: 'removing'!removeAt: aNumber	<javascript: 'var result=this[aNumber-1];this.splice(aNumber - 1,1);return result'>! !!PjArray methodsFor: 'removing'!removeFirst	<javascript: 'return this.shift()'>! !!PjArray methodsFor: 'removing'!removeLast	<javascript: 'return this.pop()'>! !!PjArray methodsFor: 'accessing'!replaceFrom: start to: stop with: replacement startingAt: repStart	<javascript: '	for(var mine=stop-1,other=mine+repStart-start;		mine>=start-1;		--other,--mine		)this[mine]=replacement[other];return this'>! !!PjArray methodsFor: 'accessing'!writeStream	^ PjArrayStream new! !!PjSet class methodsFor: 'pharoJs support'!jsTranspilationImportMethods	<pharoJsSkip>	^{Set -> #(asSet)}! !!PjSet methodsFor: 'enumerating'!addFirst: element	(self includes: element) ifTrue: [ ^element ].	^super addFirst: element! !!PjSet methodsFor: 'enumerating'!addLast: element	(self includes: element) ifTrue: [ ^element ].	^super addLast: element! !!PjSet methodsFor: 'enumerating'!like: anObject	(self includes: anObject) ifTrue: [ ^ anObject ].	^ nil! !!PjSet methodsFor: 'enumerating'!like: anObject ifAbsent: aBlock	(self includes: anObject) ifTrue: [ ^ anObject ].	^ aBlock value! !!PjSortedCollection class methodsFor: 'pharoJs support'!jsSortUsing: aBlock   ^ (self respondsTo: #sortUsing:) ifTrue: [ self sortUsing: aBlock] ifFalse: [ self new sortBlock: aBlock ]! !!PjSortedCollection class methodsFor: 'pharoJs support'!jsTranspilationImportMethods	<pharoJsSkip>	^ { 		  (SortedCollection -> (SortedCollection selectors copyWithoutAll:			    #( collect: #insert:before: indexForInserting:			       addAll: reSort #sort:to: groupedBy:))).		  (SortedCollection class -> #( sortBlock: sortUsing: )) }! !!PjSortedCollection methodsFor: 'adding'!addAll: otherCollection	otherCollection do: [ : each | self add: each ]! !!PjSortedCollection methodsFor: 'enumerating'!collect: aBlock 	"Evaluate aBlock with each of my elements as the argument. Collect the 	resulting values into an OrderedCollection. Answer the new collection. 	Override the superclass in order to produce an OrderedCollection instead	of a SortedCollection."	| newCollection | 	newCollection := OrderedCollection new.	self do: [:each | newCollection addLast: (aBlock value: each)].	^ newCollection! !!PjSortedCollection methodsFor: 'private'!indexForInserting: newObject	self ifEmpty: [ ^1 ].	self withIndexDo: [ : element : index | 		(self sortBlock value: newObject value: element) ifTrue: [ ^index ] ].	^self size + 1! !!PjSortedCollection methodsFor: 'initialize-release'!initialize	super initialize.	self instVarNamed: #firstIndex put: 1.	self instVarNamed: #lastIndex put: 0.	self sortBlock: [ : a : b | a <= b ].! !!PjSortedCollection methodsFor: 'accessing'!insert: newObject before: index	self splice: index - 1 remove: 0 element: newObject! !!PjSortedCollection methodsFor: 'private'!reSort	| copy |	copy := self species sortBlock: self sortBlock.	copy addAll: self.	copy withIndexDo: [ : each : index |		super at: index put: each ]! !!PjSortedCollection methodsFor: 'accessing'!replaceFrom: start to: stop with: replacement startingAt: repStart	| repStop |	repStop := repStart + stop - start.	repStart to: repStop do: [ : otherIndex |		self add: (replacement at: otherIndex)  ]! !!PjStack class methodsFor: 'pharoJs support'!jsTranspilationImportMethods	<pharoJsSkip>	^{Stack -> #(top pop push:)}! !!PjBoolean class methodsFor: 'class initialization'!identityHash_jsGenerator: transpiler	<pharoJsSkip>	^'if(this == true){		return ', true identityHash asString,';}	return ', false identityHash asString! !!PjBoolean class methodsFor: 'pharoJs support'!jsTranspilationImportMethods	<pharoJsSkip>	^ { (Boolean -> #( ==> eqv: isLiteral)) }! !!PjBoolean methodsFor: 'logical operations'!& aBoolean	^ self ifTrue: [ ^ aBoolean ] ifFalse: [ ^ false ]! !!PjBoolean methodsFor: 'comparing'!= other	<javascript: 'return this==Boolean(other)'>! !!PjBoolean methodsFor: 'comparing'!== other	^ self = other! !!PjBoolean methodsFor: 'controlling'!and: aBlock	<javascript: 'if(this==true){return aBlock();}else{return false;}'>! !!PjBoolean methodsFor: 'converting'!asBit	<javascript: 'return this + 0'>! !!PjBoolean methodsFor: 'converting'!asJsObject	"We want primitive booleans and not boxed ones!!"	"This is necessary because if a value like true is sent as a message, then it is wrapped, so returning this doesnt do the right thing. so the block [ false not == true ] will return false."	<javascript: 'return this == true'>! !!PjBoolean methodsFor: 'converting'!asString	<javascript: 'return this + ""'>! !!PjBoolean methodsFor: 'not defined category'!identityHash	<jsGenerator: #identityHash_jsGenerator:>! !!PjBoolean methodsFor: 'controlling'!ifFalse: aBlock	^ self ifTrue: [] ifFalse: aBlock! !!PjBoolean methodsFor: 'controlling'!ifFalse: falseBlock ifTrue: trueBlock	^self ifTrue: trueBlock ifFalse: falseBlock! !!PjBoolean methodsFor: 'controlling'!ifTrue: aBlock	^ self ifTrue: aBlock ifFalse: [  ]! !!PjBoolean methodsFor: 'controlling'!ifTrue: trueBlock ifFalse: falseBlock	<javascript: 'if(this==true){return typeof trueBlock=="function"?trueBlock():trueBlock}else{return typeof falseBlock=="function"?falseBlock():falseBlock}'>! !!PjBoolean methodsFor: 'testing'!isJSPrimitiveType	^ true! !!PjBoolean methodsFor: 'logical operations'!not	^ self ifTrue: [ ^ false ] ifFalse: [ ^ true ]! !!PjBoolean methodsFor: 'controlling'!or: aBlock	<javascript: 'if(this==true){return true}else{return aBlock()}'>! !!PjBoolean methodsFor: 'printing'!printOn: aStream	aStream nextPutAll: self asString! !!PjBoolean methodsFor: 'proxy'!proxyResponse	<javascript: 'return true==this'>! !!PjBoolean methodsFor: 'converting'!value	<javascript: 'return true==this'>! !!PjBoolean methodsFor: 'controlling'!xor: aBoolean	self ifTrue: [ ^ aBoolean value not ] ifFalse: [ ^ aBoolean value ]! !!PjBoolean methodsFor: 'logical operations'!| aBoolean	^ self ifFalse: [ ^ aBoolean ] ifTrue: [ ^ true ]! !!PjBoolean methodsFor: 'comparing'!~~ other	^ self ~= other! !!PjCollection class methodsFor: 'pharojs support'!jsTranspilationImportMethods	<pharoJsSkip>	^ self jsTranspilationImportMethodsCollection! !!PjCollection class methodsFor: 'instance creation'!new: ignored	" if this gets down to object, the numeric parameter will not do what we want "	^ self new! !!PjCollection methodsFor: 'testing'!= aMagnitude	^self subclassResponsibility! !!PjDictionary class methodsFor: 'pharojs support'!jsTranspilationImportMethods	<pharoJsSkip>	^{		Dictionary -> #(at:ifAbsentPut:).	}! !!PjDictionary methodsFor: 'converting'!asDictionary	^self! !!PjDictionary methodsFor: 'converting'!asJsObject	| jsObject |	jsObject := Object new.	self keysAndValuesDo: [ : key : value |		jsObject at: key put: value asJsObject].	^jsObject! !!PjDictionary methodsFor: 'dictionary access'!at: key	^super at: (self keyFrom: key)! !!PjDictionary methodsFor: 'dictionary access'!at: key ifAbsent: aBlock	^super at: (self keyFrom: key) ifAbsent: aBlock! !!PjDictionary methodsFor: 'dictionary access'!at: key ifPresent: aBlock	^super at: (self keyFrom: key) ifPresent: aBlock! !!PjDictionary methodsFor: 'dictionary access'!at: key ifPresent: aBlock ifAbsent: anotherBlock	^super at: (self keyFrom: key) ifPresent: aBlock ifAbsent: anotherBlock! !!PjDictionary methodsFor: 'dictionary access'!at: key put: value	^super at: (self keyFrom: key) put: value! !!PjDictionary methodsFor: 'enumerating'!collect: aBlock	| resultDict |	resultDict := self class new.	self keysAndValuesDo: [: key : value |		resultDict at: key put: (aBlock value: value)	].	^resultDict! !!PjDictionary methodsFor: 'dictionary access'!keyFrom: anObject	anObject class == String ifTrue: [ ^anObject ].	anObject class == Number ifTrue: [ ^anObject ].	^anObject hash! !!PjIdentityDictionary methodsFor: 'dictionary access'!at: key		<javascript: 'return this.map.get(key)'>! !!PjIdentityDictionary methodsFor: 'dictionary access'!at: key ifAbsent: aBlock	| value |	value := self at: key.	value ifNil: [^aBlock value].	^value! !!PjIdentityDictionary methodsFor: 'dictionary access'!at: key ifAbsentPut: aBlock	^ self at: key ifAbsent: [ self at: key put: aBlock value ]! !!PjIdentityDictionary methodsFor: 'dictionary access'!at: key ifPresent: aBlock	| value |	value := self at: key.	value ifNil: [^nil].	^aBlock value! !!PjIdentityDictionary methodsFor: 'dictionary access'!at: key ifPresent: aBlock ifAbsent: anotherBlock	| value |	value := self at: key.	value ifNil: [^anotherBlock value].	^aBlock value! !!PjIdentityDictionary methodsFor: 'dictionary access'!at: key put: value	<javascript: 'this.map.set(key,value); return value'>! !!PjIdentityDictionary methodsFor: 'dictionary access'!do: aBlock	self valuesDo: aBlock! !!PjIdentityDictionary methodsFor: 'initialize-release'!initialize	super initialize.	map := self newMap! !!PjIdentityDictionary methodsFor: 'dictionary access'!isEmpty	^self size = 0! !!PjIdentityDictionary methodsFor: 'dictionary access'!keysAndValuesDo: twoArgsBlock	<javascript: 'let iterator = this.map.entries();	let iteration = iterator.next();	while(!!iteration.done){		twoArgsBlock.apply(this,iteration.value);		iteration = iterator.next();	}	return this;	'>! !!PjIdentityDictionary methodsFor: 'initialize-release'!newMap	<javascript: 'return new Map()'>! !!PjIdentityDictionary methodsFor: 'dictionary access'!size	<javascript: 'return this.map.size'>! !!PjIdentityDictionary methodsFor: 'dictionary access'!valuesDo: aBlock	self keysAndValuesDo: [ : key : value| aBlock value: value ]! !!PjError class methodsFor: 'initialization-release'!javascriptInitialize	self instVarNamed: #stackTraceLimit put: 100! !!PjError class methodsFor: 'pharoJs support'!jsTranspilationImportMethods	<pharoJsSkip>	^ { (Exception -> #( defaultDescription description )) }! !!PjError class methodsFor: 'instance creation'!signal	^self new signal! !!PjError class methodsFor: 'instance creation'!signal: aString	^self new signal: aString! !!PjError methodsFor: 'accessing'!messageText	^ message! !!PjError methodsFor: 'accessing'!messageText: anObject	message := anObject! !!PjError methodsFor: 'signaling'!signal	<javascript: 'throw this'>! !!PjError methodsFor: 'signaling'!signal: aString	self messageText: aString.	^self signal.! !!PjClass class methodsFor: 'as yet unclassified'!classPool_jsGenerator: transpiler	<pharoJsSkip>	^ 'return this.' , transpiler classVarsPoolName! !!PjClass class methodsFor: 'Behavior: reflection'!hasClassMethod_jsGenerator: transpiler	<pharoJsSkip>	^'return this.__proto__.hasOwnProperty(Smalltalk.', transpiler pharoJsSelectorPrefix, 'makePharoJsSelector_(aSymbol))'! !!PjClass class methodsFor: 'pharoJs support'!jsTranspilationImportMethods	<pharoJsSkip>	^{		Behavior -> #( subclassesDo: allSubclasses allSubclassesDo: isBehavior ).		Class -> #( isClass classVarNames).	}! !!PjClass methodsFor: 'Behaviour: object creatioin'!adoptInstance: anObject	anObject js_at: #__proto__ put: (self js_at:#prototype)" here so that ordinary Javascript 'classes' will respond to the message"! !!PjClass methodsFor: 'Behavior: reflection'!class	^ PjCore metaclassOf: self! !!PjClass methodsFor: 'accessing'!classPool	<jsGenerator: #classPool_jsGenerator:>	! !!PjClass methodsFor: 'Behavior: reflection'!classVarNamed: aString	^ self classPool at: aString! !!PjClass methodsFor: 'Behavior: reflection'!classVarNamed: aString put: otherString	self classPool at: aString put: otherString! !!PjClass methodsFor: 'Behavior: reflection'!hasClassMethod: aSymbol	<jsGenerator: #hasClassMethod_jsGenerator:>! !!PjClass methodsFor: 'testing'!isBlock	^ false! !!PjClass methodsFor: 'testing'!isClass	^ true! !!PjClass methodsFor: 'accessing'!name	<javascript:	'var s=this.name||this.prototype.toString();	if (s.substr(0,1)=="[") s=s.substr(8,s.length-9);	return s'>! !!PjClass methodsFor: 'Behaviour: object creatioin'!newFromJsonString: jsonString	| newInstance |	newInstance := JSON js_parse: jsonString.	self adoptInstance: newInstance.	^newInstance" here so that ordinary Javascript 'classes' will respond to the message"! !!PjClass methodsFor: 'printing'!printOn: aStream	aStream nextPutAll: self name! !!PjClass methodsFor: 'Behavior: reflection'!prototype	^ self js_at: #prototype! !!PjClass methodsFor: 'Behavior: reflection'!subclasses	^ subclasses! !!PjClass methodsFor: 'Behavior: reflection'!theMetaClass	^ self class! !!PjClass methodsFor: 'Behavior: reflection'!theNonMetaClass	^ self! !!PjFunction class methodsFor: 'setup'!forceSubclass: aFunction	aFunction js_at: #__proto__ put: (self js_at: #prototype)! !!PjFunction class methodsFor: 'pharoJs support'!jsTranspilationImportMethods	<pharoJsSkip>	^{		Behavior -> #( inheritsFrom: ).		BlockClosure -> #( isBlock ).	}! !!PjFunction class methodsFor: 'exceptions'!on_do_jsGenerator: transpiler	<pharoJsSkip>	^'try{		return this()	}catch(ex){		if(ex.', transpiler pharoJsSelectorPrefix, 'isKindOf_(exception)){return handlerAction(ex)}		throw ex	}'! !!PjFunction methodsFor: 'exceptions'!assert	self value ifFalse: [AssertionFailure signal: 'Assertion failed']! !!PjFunction methodsFor: 'instance creation'!basicNew" here so that ordinary Javascript 'classes' will respond to the message"	<javascript: 'return new this()'>! !!PjFunction methodsFor: 'instance creation'!basicNew: arg" here so that ordinary Javascript 'classes' will respond to the message"	<javascript: 'return new this(arg)'>! !!PjFunction methodsFor: 'instance creation'!basicNew: arg1 with: arg2" here so that ordinary Javascript 'classes' will respond to the message"	<javascript: 'return new this(arg1, arg2)'>! !!PjFunction methodsFor: 'instance creation'!basicNew: arg1 with: arg2 with: arg3" here so that ordinary Javascript 'classes' will respond to the message"	<javascript: 'return new this(arg1, arg2, arg3)'>! !!PjFunction methodsFor: 'instance creation'!basicNew: arg1 with: arg2 with: arg3 with: arg4" here so that ordinary Javascript 'classes' will respond to the message"	<javascript: 'return new this(arg1, arg2, arg3, arg4)'>! !!PjFunction methodsFor: 'instance creation'!basicNew: arg1 with: arg2 with: arg3 with: arg4 with: arg5" here so that ordinary Javascript 'classes' will respond to the message"	<javascript: 'return new this(arg1, arg2, arg3, arg4, arg5)'>! !!PjFunction methodsFor: 'Behavior: reflection'!canUnderstand: selector	| jsSelector |	jsSelector := PjCore makePharoJsSelector: selector.	^ (self prototype js_at: jsSelector) ifNil: [ false ] ifNotNil: [: selct | '__DNU' ~= (selct js_at: #name)]! !!PjFunction methodsFor: 'evaluating'!close	PjCore log: 'unoptimized close may not capture semantics'.	^ self! !!PjFunction methodsFor: 'evaluating'!cull: arg	"In javascript a function always uses only required arguments"	^self value: arg! !!PjFunction methodsFor: 'evaluating'!cull: arg1 cull: arg2	"In javascript a function always uses only required arguments"	^self value: arg1 value: arg2! !!PjFunction methodsFor: 'evaluating'!cull: arg1 cull: arg2 cull: arg3	"In javascript a function always uses only required arguments"	^self value: arg1 value: arg2 value: arg3! !!PjFunction methodsFor: 'evaluating'!cull: arg1 cull: arg2 cull: arg3 cul: arg4	"In javascript a function always uses only required arguments"	^self value: arg1 value: arg2 value: arg3 value: arg4! !!PjFunction methodsFor: 'exceptions'!ensure: aBlock	<javascript: '	try{		return this()	}finally{aBlock()}'>! !!PjFunction methodsFor: 'exceptions'!ifCurtailed: curtailBlock	| result curtailed |	curtailed := true.	[		result := self value.		curtailed := false	] ensure: [		curtailed ifTrue: [ curtailBlock value ] ].	^ result! !!PjFunction methodsFor: 'instance creation'!new	^self basicNew 		initialize;		yourself! !!PjFunction methodsFor: 'instance creation'!new: arg	^(self basicNew: arg)		initialize;		yourself! !!PjFunction methodsFor: 'instance creation'!new: arg1 with: arg2	^(self basicNew: arg1 with: arg2)		initialize;		yourself! !!PjFunction methodsFor: 'instance creation'!new: arg1 with: arg2 with: arg3	^(self basicNew: arg1 with: arg2 with: arg3)		initialize;		yourself! !!PjFunction methodsFor: 'instance creation'!new: arg1 with: arg2 with: arg3 with: arg4	^(self basicNew: arg1 with: arg2 with: arg3 with: arg4)		initialize;		yourself! !!PjFunction methodsFor: 'instance creation'!new: arg1 with: arg2 with: arg3 with: arg4 with: arg5	^(self basicNew: arg1 with: arg2 with: arg3 with: arg4 with: arg5)		initialize;		yourself! !!PjFunction methodsFor: 'exceptions'!on: exception do: handlerAction	<jsGenerator: #on_do_jsGenerator:>! !!PjFunction methodsFor: 'printing'!printOn: aStream	aStream nextPutAll: 'a Block'! !!PjFunction methodsFor: 'Behavior: reflection'!superclass	self == Object ifTrue: [ ^nil ].	^((self js_at: #prototype) js_at: #__proto__) class! !!PjFunction methodsFor: 'evaluating'!value	<javascript: 'return this();'>! !!PjFunction methodsFor: 'evaluating'!value: arg	<javascript: 'return this(arg);'>! !!PjFunction methodsFor: 'evaluating'!value: arg1 value: arg2	<javascript: 'return this(arg1, arg2);'>! !!PjFunction methodsFor: 'evaluating'!value: arg1 value: arg2 value: arg3	<javascript: 'return this(arg1, arg2, arg3);'>! !!PjFunction methodsFor: 'evaluating'!value: arg1 value: arg2 value: arg3 value: arg4	<javascript: 'return this(arg1, arg2, arg3, arg4);'>! !!PjFunction methodsFor: 'evaluating'!valueWithArguments: anArray	<javascript: 'return this.apply(this,anArray)'>! !!PjFunction methodsFor: 'evaluating'!valueWithEnoughArguments: anArray	"call me with enough arguments from anArray"	"In javascript a function always uses only required arguments"	<javascript: 'return this.apply(this,anArray)'>! !!PjFunction methodsFor: 'evaluating'!valueWithPossibleArgs: args	<javascript: 'return this.apply(null,args);'>! !!PjFunction methodsFor: 'looping'!whileFalse	self whileFalse: []! !!PjFunction methodsFor: 'looping'!whileFalse: loopBlock	<javascript: 'while(false==this()){loopBlock();}'>! !!PjFunction methodsFor: 'looping'!whileTrue	self whileTrue: []! !!PjFunction methodsFor: 'looping'!whileTrue: loopBlock	<javascript: 'while(true==this()){loopBlock();}'>! !!PjDuration class methodsFor: 'pharoJs support'!jsTranspilationImportMethods	<pharoJsSkip>	| creationSelectors instanceSelectors |	creationSelectors := Duration class 		selectorsInProtocols: #('instance creation' 'instance creation simple' '*PharoExtra-Chronology')  		exclude: #(readFrom: fromString: month:).	instanceSelectors := Duration 		selectorsInProtocols: #(accessing arithmetic comparing converting initialization private '*PharoExtra-Chronology')		exclude: #(asDelay storeOn:). "asDelay exclued because no support for Delay yet!!"	^{Duration class -> creationSelectors.	Duration -> instanceSelectors }! !!PjDuration methodsFor: 'adding'!addDateAndTime: aDateAndTime	^(DateAndTime 		year: aDateAndTime year		month: aDateAndTime monthIndex		day: (aDateAndTime dayOfMonth + self days)		hour: (aDateAndTime hour24 + self hoursCount) 		minute: (aDateAndTime minute + self minutesCount)		second: (aDateAndTime second + self secondsCount))		setMilliseconds: (aDateAndTime getMilliseconds + self millisecondsCount);		yourself! !!PjDuration methodsFor: 'adding'!printStringAsTimzoneOn: str	self asNanoSeconds < 0		ifTrue: [ str << $- ]		ifFalse: [ str << $+ ].	self printWithLeading0: self hoursCount on: str.	str << ':'.	self printWithLeading0: self minutesCount on: str! !!PjDuration methodsFor: 'adding'!printStringOn: str	self asNanoSeconds < 0		ifTrue: [ str << $- ]		ifFalse: [ str << $+ ].	self printWithLeading0: self hoursCount on: str.	str << ':'.	self printWithLeading0: self minutesCount on: str! !!PjDuration methodsFor: 'adding'!printWithLeading0: aNumber	^ String streamContents: [ :str | 		  aNumber abs < 10 ifTrue: [ str print: 0 ].		  str print: aNumber abs asString]! !!PjDuration methodsFor: 'adding'!printWithLeading0: aNumber on: str	aNumber abs < 10 ifTrue: [ str print: 0 ].	str print: aNumber abs! !!PjAssociation class methodsFor: 'pharojs support'!jsTranspilationImportMethods	<pharoJsSkip>	^{		Association -> #( = key:value: value value: ).		Association class -> #( key:value: ).	}! !!PjLookupKey class methodsFor: 'pharojs support'!javascriptName	<pharoJsSkip>	^self name! !!PjLookupKey class methodsFor: 'pharojs support'!jsTranspilationImportMethods	<pharoJsSkip>	^{		LookupKey -> #( < = key key:  ).		LookupKey class -> #( key:  ).	}! !!PjMagnitude class methodsFor: 'pharojs support'!jsTranspilationImportMethods	<pharoJsSkip>	^ self jsTranspilationImportMethodsMagnitude! !!PjMagnitude methodsFor: 'testing'!< aMagnitude	^self subclassResponsibility! !!PjMagnitude methodsFor: 'testing'!= aMagnitude	^self subclassResponsibility! !!PjNumber class methodsFor: 'arithmetics'!divide_jsGenerator: transpiler	<pharoJsSkip> 	^'if(anObject==0) return ZeroDivide.', transpiler pharoJsSelectorPrefix, 'signal();return this / anObject;'! !!PjNumber class methodsFor: 'class initialization'!javascriptInitialize	Pi := Math instVarNamed: #PI.	Halfpi := Pi / 2.0.	Twopi := Pi * 2.0.	ThreePi := Pi * 3.0.	RadiansPerDegree := Pi / 180.0.	Ln2 := Math instVarNamed: #LN2.	Ln10 :=  Math instVarNamed: #LN10.	Sqrt2 :=  Math instVarNamed: #SQRT2.	E :=  Math instVarNamed: #E.	Epsilon := 0.000000000001.  "Defines precision of mathematical functions"	MaxVal := Number instVarNamed: #MAX_VALUE.	MaxValLn := 709.782712893384.	MinValLogBase2 := -1074.	Infinity := Number instVarNamed: #POSITIVE_INFINITY.	NegativeInfinity := Number instVarNamed: #NEGATIVE_INFINITY.	NaN := Number instVarNamed: #NaN.	NegativeZero := 1.0 / NegativeInfinity.! !!PjNumber class methodsFor: 'pharoJs support'!jsTranspilationImportMethods	<pharoJsSkip>	| selectorsForChronology numberSelectors |	selectorsForChronology := #( year years week weeks day days hour hours	                             minute minutes second seconds milliSecond	                             milliSeconds )	                          ,	                          (Number selectorsInProtocol:		                           '*PharoExtra-Chronology').	numberSelectors := selectorsForChronology	                   ,		                   #( floorLog: negated reciprocal log: asInteger		                      asNumber squared even odd fractionPart		                      integerPart // strictlyPositive		                      positive negative raisedToInteger:		                      raisedTo: isNumber isZero quo: rem: ).	^ self jsTranspilationImportMethodsMagnitude , { 		  (Number -> numberSelectors).		  (Number class -> #( one )).		  (Integer -> #( asCharacter isPowerOfTwo isLiteral)).		  (SmallInteger		   -> #( highBit basicIdentityHash identityHash hashMultiply		      hash )).		  (Float -> #( isInfinite rounded asFloat isSelfEvaluating)).		  (Float class		   ->			   #( denormalized e emax emin epsilon fmax fmin fminDenormalized			      fminNormalized halfPi infinity maxExactInteger			      nan negativeInfinity negativeZero one pi precision radix			      threePi twoPi zero )) }! !!PjNumber methodsFor: 'arithmetics'!% anObject	<javascript: 'return Math.sign(anObject)*(Math.abs(this) % anObject)'>! !!PjNumber methodsFor: 'arithmetics'!* anObject	<javascript: 'return this * anObject;'>! !!PjNumber methodsFor: 'arithmetics'!+ anObject	<javascript: 'return this + anObject;'>! !!PjNumber methodsFor: 'arithmetics'!- anObject	<javascript: 'return this - anObject;'>! !!PjNumber methodsFor: 'arithmetics'!/ anObject	<jsGenerator: #divide_jsGenerator:>! !!PjNumber methodsFor: 'arithmetics'!// anObject	^ Math floor: self / anObject! !!PjNumber methodsFor: 'comparing'!< other	<javascript: 'return this < other'>! !!PjNumber methodsFor: 'comparing'!= other	<javascript: 'return this == other'>! !!PjNumber methodsFor: 'comparing'!== other	<javascript: 'return this == other'>! !!PjNumber methodsFor: 'converting'!@ y 	^Point x: self y: y! !!PjNumber methodsFor: 'arithmetics'!\\ anObject	^ self % anObject! !!PjNumber methodsFor: 'arithmetics'!abs	<javascript: 'return Math.abs(this);'>! !!PjNumber methodsFor: 'mathematical functions'!arcCos	<javascript: 'return Math.acos(this);'>! !!PjNumber methodsFor: 'mathematical functions'!arcSin	<javascript: 'return Math.asin(this);'>! !!PjNumber methodsFor: 'mathematical functions'!arcTan	<javascript: 'return Math.atan(this);'>! !!PjNumber methodsFor: 'mathematical functions'!arcTan: denominator	<javascript: 'return Math.atan2(this,denominator);'>! !!PjNumber methodsFor: 'converting'!asFloat	<javascript: 'return +this'>! !!PjNumber methodsFor: 'converting'!asJsObject	"Ensure we get a primitive type number and not a Number object"	<javascript: 'return this.valueOf()'>! !!PjNumber methodsFor: 'converting'!asString	<javascript: 'return this + ""'>! !!PjNumber methodsFor: 'comparing'!between: min and: max 	^ self >= min and: [ self <= max ]! !!PjNumber methodsFor: 'bit manipulation'!bitAnd: arg 	<javascript: 'return this&arg'>! !!PjNumber methodsFor: 'bit manipulation'!bitInvert	<javascript: 'return ~this'>! !!PjNumber methodsFor: 'bit manipulation'!bitOr: arg 	<javascript: 'return this|arg'>! !!PjNumber methodsFor: 'bit manipulation'!bitShift: shiftCount	<javascript: 'if (shiftCount<0) return this>>(-shiftCount);return this<<shiftCount'>! !!PjNumber methodsFor: 'bit manipulation'!bitXor: arg 	<javascript: 'return this^arg'>! !!PjNumber methodsFor: 'converting'!ch	<javascript: 'return this + "ch"'>! !!PjNumber methodsFor: 'converting'!cm	<javascript: 'return this + "cm"'>! !!PjNumber methodsFor: 'mathematical functions'!cos	<javascript: 'return Math.cos(this);'>! !!PjNumber methodsFor: 'converting'!degreesToRadians	^ self * RadiansPerDegree! !!PjNumber methodsFor: 'converting'!em	<javascript: 'return this + "em"'>! !!PjNumber methodsFor: 'converting'!ex	<javascript: 'return this + "ex"'>! !!PjNumber methodsFor: 'mathematical functions'!exp	<javascript: 'return Math.exp(this);'>! !!PjNumber methodsFor: 'bit manipulation'!highBitOfPositiveReceiver	| shifted bitNo |	"Answer the index of the high order bit of the receiver, or zero if the 	receiver is zero. Receiver has to be positive!!"	shifted := self.	bitNo := 0.	[shifted < 65536]		whileFalse: 			[shifted := shifted bitShift: -16.			bitNo := bitNo + 16].	shifted < 256		ifFalse: 			[shifted := shifted bitShift: -8.			bitNo := bitNo + 8].	shifted < 16		ifFalse: 			[shifted := shifted bitShift: -4.			bitNo := bitNo + 4].	shifted < 4		ifFalse: 			[shifted := shifted bitShift: -2.			bitNo := bitNo + 2].	shifted < 2		ifFalse: 			[shifted := shifted bitShift: -1.			bitNo := bitNo +1].	^ shifted+bitNo! !!PjNumber methodsFor: 'converting'!in	<javascript: 'return this + "in"'>! !!PjNumber methodsFor: 'testing'!isFloat	^ self isInteger not! !!PjNumber methodsFor: 'testing'!isInteger	<javascript: 'return (this|0)==this'>! !!PjNumber methodsFor: 'testing'!isJSPrimitiveType	^ true! !!PjNumber methodsFor: 'testing'!isNaN	<javascript: 'return isNaN(this)'>! !!PjNumber methodsFor: 'mathematical functions'!ln	<javascript: 'return Math.log(this);'>! !!PjNumber methodsFor: 'mathematical functions'!log	<javascript: 'return Math.log10(this);'>! !!PjNumber methodsFor: 'bit manipulation'!lowBit	" Answer the index of the low order one bit.		2r00101000 lowBit       (Answers: 4)		2r-00101000 lowBit      (Answers: 4)	  First we skip bits in groups of 8, then by 1.	  While not optimal, this is a good tradeoff; long	  integer #lowBit always invokes us with bytes."	| n result |	n := self.	n = 0 ifTrue: [ ^ 0 ].	result := 1.	[(n bitAnd: 16rFF) = 0]		whileTrue: [			result := result + 8.			n := n bitShift: -8 ].	[(n bitAnd: 1) = 0]		whileTrue: [			result := result + 1.			n := n bitShift: -1 ].	^ result! !!PjNumber methodsFor: 'converting'!mm	<javascript: 'return this + "mm"'>! !!PjNumber methodsFor: 'converting'!pc	<javascript: 'return this + "pc"'>! !!PjNumber methodsFor: 'converting'!percnt	<javascript: 'return this + "%"'>! !!PjNumber methodsFor: 'printing'!printOn: aStream	self isNaN ifTrue: [ ^ aStream nextPutAll: 'Float nan' ].	self isInfinite ifTrue: [ 		^ aStream nextPutAll: 'Float infinity' ].	aStream nextPutAll: self js_toString! !!PjNumber methodsFor: 'proxy'!proxyResponse	<javascript: 'return 0+this'>! !!PjNumber methodsFor: 'converting'!pt	<javascript: 'return this + "pt"'>! !!PjNumber methodsFor: 'converting'!px	<javascript: 'return this + "px"'>! !!PjNumber methodsFor: 'converting'!radiansToDegrees	^ self / RadiansPerDegree! !!PjNumber methodsFor: 'converting'!rem	<javascript: 'return this + "rem"'>! !!PjNumber methodsFor: 'mathematical functions'!sign	<javascript: 'return Math.sign(this);'>! !!PjNumber methodsFor: 'mathematical functions'!sin	<javascript: 'return Math.sin(this);'>! !!PjNumber methodsFor: 'mathematical functions'!sqrt	<javascript: 'return Math.sqrt(this);'>! !!PjNumber methodsFor: 'mathematical functions'!tan	<javascript: 'return Math.tan(this);'>! !!PjNumber methodsFor: 'looping'!timesRepeat: aBlock	1 to: self do: aBlock! !!PjNumber methodsFor: 'looping'!to: end	| interval |	interval := OrderedCollection new.	self to: end by: 1 do: [ : each | interval add: each ].	^interval! !!PjNumber methodsFor: 'looping'!to: end by: step do: aBlock	step >= 0		ifTrue: [ self to: end byPositive: step do: aBlock ]		ifFalse: [ self to: end byNegative: step do: aBlock ]! !!PjNumber methodsFor: 'looping'!to: end byNegative: step do: aBlock		<javascript: 'for(var i=this; i >= end; i += step){aBlock(i);}'>! !!PjNumber methodsFor: 'looping'!to: end byPositive: step do: aBlock		<javascript: 'for(var i=this; i <= end; i += step){aBlock(i);}'>! !!PjNumber methodsFor: 'looping'!to: end do: aBlock	self to: end by: 1 do: aBlock! !!PjNumber methodsFor: 'converting'!truncated	<javascript: 'if (this>=0)return Math.floor(this);return Math.ceil(this)'>! !!PjNumber methodsFor: 'converting'!value	<javascript: 'return 0+this'>! !!PjNumber methodsFor: 'converting'!vh	<javascript: 'return this + "vh"'>! !!PjNumber methodsFor: 'converting'!vmax	<javascript: 'return this + "vmax"'>! !!PjNumber methodsFor: 'converting'!vmin	<javascript: 'return this + "vmin"'>! !!PjNumber methodsFor: 'converting'!vw	<javascript: 'return this + "vw"'>! !!PjNumber methodsFor: 'arithmetics'!| anObject	<javascript: 'return this | anObject;'>! !!PjNumber methodsFor: 'comparing'!~= other	<javascript: 'return this !!= other'>! !!PjObject class methodsFor: 'doesNotUnderstand support'!addDnuSupportFor: selector	<javascript: 'if(Object.prototype.hasOwnProperty(selector)){return;}		Object.prototype.selector =  function(){			throw "Does not understand message " + selector;};	'>	self flag: #todo "see JbObject>>#registerDNU:"! !!PjObject class methodsFor: 'reflection'!allEnumeratableKeysDo_jsGenerator: transpiler	<pharoJsSkip>	^'for (var i in this){aBlock.', transpiler pharoJsSelectorPrefix, 'value_(i)};	return this;'! !!PjObject class methodsFor: 'pharoJs support'!jsTranspilationImportMethods	<pharoJsSkip>	^ { 		  (ProtoObject		   -> #( isNil ifNil: ifNotNil: #ifNil:ifNotNil: #ifNotNil:ifNil: )).		  (Object		   ->			   #( -> as: asOrderedCollection isKindOf: error: respondsTo:			      isMemberOf: className isNotNil notNil isString isClass			      isBlock isNumber isBehavior isCollection isArray isFloat			      isInteger isCharacter isSymbol isStream isPjProxyOrNil			      printOn: shouldBePrintedAsLiteral isLiteral isSelfEvaluating )).		  (Collection		   -> #( addAll: #ifEmpty:ifNotEmpty: #ifNotEmpty:ifEmpty:			      ifEmpty: ifNotEmpty: )).		  (Dictionary -> #( do: )).		  (Dictionary class -> #( newFrom: newFromPairs: )) }! !!PjObject class methodsFor: 'dictionary emulation'!keysAndValuesDo_jsGenerator: transpiler	<pharoJsSkip>	^'for (var i in this){if(this.hasOwnProperty(i))aBlock.', transpiler pharoJsSelectorPrefix, 'value_value_(i,this[i])};	return this;'! !!PjObject class methodsFor: 'dictionary emulation'!keysDo_jsGenerator: transpiler	<pharoJsSkip>	^'for (var i in this){if(this.hasOwnProperty(i))aBlock.', transpiler pharoJsSelectorPrefix, 'value_(i)};	return this;'! !!PjObject class methodsFor: 'comparing'!nextIdentityHash	^ nextIdentityHash := (nextIdentityHash ifNil: [12345]) hashMultiply! !!PjObject class methodsFor: 'dictionary emulation'!valuesDo_jsGenerator: transpiler	<pharoJsSkip>	^'for (var i in this){if(this.hasOwnProperty(i))aBlock.', transpiler pharoJsSelectorPrefix, 'value_(this[i])};	return this;'! !!PjObject methodsFor: 'comparing'!= other	<javascript: 'return this==other'>! !!PjObject methodsFor: 'comparing'!== other	<javascript: 'return this===other'>! !!PjObject methodsFor: 'dictionary emulation'!add: assoc	" this strange code is to install add: for objects that already have an add field or to do at:put: "	^ PjCore		installDnuArgs: {assoc}		selector: #add		js: #_add_		for: self		else: [ self js_at: assoc key put: assoc value ]! !!PjObject methodsFor: 'reflection'!allEnumeratableKeys	| allKeys |	allKeys := Set new.	self allEnumeratableKeysDo: [ : each | allKeys add: each ].	^allKeys! !!PjObject methodsFor: 'reflection'!allEnumeratableKeysDo: aBlock	<jsGenerator: #allEnumeratableKeysDo_jsGenerator:>! !!PjObject methodsFor: 'converting'!asJSON	^ JSON stringify: self value! !!PjObject methodsFor: 'converting'!asJsObject	^self! !!PjObject methodsFor: 'dictionary emulation'!associationsDo: aBlock	self keysAndValuesDo: [: key : value |		aBlock value: (Association key: key value: value)	]! !!PjObject methodsFor: 'dictionary emulation'!at: key	<javascript: 'return this[key]'>! !!PjObject methodsFor: 'dictionary emulation'!at: key ifAbsent: aBlock	(self js_hasOwnProperty: key) ifTrue: [ ^self js_at: key].	^ aBlock value! !!PjObject methodsFor: 'dictionary emulation'!at: key ifPresent: aBlock	(self js_hasOwnProperty: key) ifFalse: [ ^ nil].	^ aBlock cull: (self js_at: key)! !!PjObject methodsFor: 'dictionary emulation'!at: key ifPresent: aBlock ifAbsent: anotherBlock	(self js_hasOwnProperty: key) ifTrue: [ ^ aBlock cull: (self js_at: key)].	^ anotherBlock value! !!PjObject methodsFor: 'dictionary emulation'!at: key put: value	<javascript: 'return this[key]=value'>! !!PjObject methodsFor: 'reflection'!class	^ self js_at: #constructor! !!PjObject methodsFor: 'copying'!copy	^self shallowCopy postCopy! !!PjObject methodsFor: 'reflection'!doesNotUnderstand: aMessage	^ PjCore handleDNU: aMessage for: self! !!PjObject methodsFor: 'flagging'!flag: aSymbol! !!PjObject methodsFor: 'reflection'!halt	<javascript: 'debugger'>! !!PjObject methodsFor: 'comparing'!hash	^ self identityHash! !!PjObject methodsFor: 'comparing'!identityHash	^ (self instVarNamed: #_js_hash) ifNil: [		self instVarNamed: #_js_hash putHidden: self class nextIdentityHash ]! !!PjObject methodsFor: 'dictionary emulation'!includesKey: key	<javascript: 'return this.hasOwnProperty(key)'>! !!PjObject methodsFor: 'initialize-release'!initialize! !!PjObject methodsFor: 'introspection'!instVarNamed: aString	^ self js_at: aString! !!PjObject methodsFor: 'introspection'!instVarNamed: aString put: anObject	^ self js_at: aString put: anObject! !!PjObject methodsFor: 'introspection'!instVarNamed: aString putHidden: anObject	<javascript: '	try{Object.defineProperty(this,aString,{value:anObject,writable:true})}catch(e){}	return anObject'>! !!PjObject methodsFor: 'dictionary emulation'!isEmpty	self keysDo: [ ^ false ].	^ true! !!PjObject methodsFor: 'dictionary emulation'!isEmptyOrNil	^ false! !!PjObject methodsFor: 'testing'!isJSPrimitiveType	^ false! !!PjObject methodsFor: 'dictionary emulation'!keys	"Answer an Array containing the receiver's keys."	| result |	result := Array new.	self keysDo: [:key| result addLast: key].	^ result! !!PjObject methodsFor: 'dictionary emulation'!keysAndValuesDo: aBlock	<jsGenerator: #keysAndValuesDo_jsGenerator:>! !!PjObject methodsFor: 'dictionary emulation'!keysDo: aBlock	<jsGenerator: #keysDo_jsGenerator:>! !!PjObject methodsFor: 'message performing'!perform: selector	^ (self js_at: (PjCore registerDnu: selector)) call: self! !!PjObject methodsFor: 'message performing'!perform: selector with: arg	^ (self js_at: (PjCore registerDnu: selector)) call: self with: arg! !!PjObject methodsFor: 'message performing'!perform: selector with: arg1 with: arg2	^ (self js_at: (PjCore registerDnu: selector)) call: self with: arg1 with: arg2! !!PjObject methodsFor: 'message performing'!perform: selector with: arg1 with: arg2 with: arg3	^ (self js_at: (PjCore registerDnu: selector)) call: self with: arg1 with: arg2 with: arg3! !!PjObject methodsFor: 'message performing'!perform: selector withArguments: argArray	^ (self js_at: (PjCore registerDnu: selector)) apply: self with: argArray! !!PjObject methodsFor: 'message performing'!perform: selector withArguments: argArray inSuperclass: lookupClass	^ (lookupClass prototype js_at: (PjCore registerDnu: selector)) apply: self with: argArray! !!PjObject methodsFor: 'copying'!postCopy	^self! !!PjObject methodsFor: 'printing'!printString	^String streamContents: [ : stream | self printOn: stream ]! !!PjObject methodsFor: 'proxy'!proxyResponse	<PjTodo: 'not sure if proxyResponse is a good name'>	| assoc p |	assoc := PjProxyManager ensureObjectRegistered: self.	p := PjProxyInfo new.	p oid: assoc key.	p remove: (self instVarNamed: '$PjProxyRemove').	p globalName: assoc value.	^ p! !!PjObject methodsFor: 'initialize-release'!release! !!PjObject methodsFor: 'dictionary emulation'!removeKey: key	<javascript: 'var result=this[key];delete this[key];return result'>! !!PjObject methodsFor: 'process operations'!setTimeout: aBlock afterMilliseconds: anInteger	<javascript: 'global.setTimeout(aBlock, anInteger)'>	super setTimeout: aBlock afterMilliseconds: anInteger! !!PjObject methodsFor: 'copying'!shallowCopy	| copy |	copy := self class basicNew.	self keysAndValuesDo: [ : key : value |		copy instVarNamed: key put: value ].	^copy! !!PjObject methodsFor: 'accessing'!size	| count |	count := 0.	self keysDo: [: value |		count := count + 1	].	^ count! !!PjObject methodsFor: 'reflection'!species	^ self class! !!PjObject methodsFor: 'reflection'!typeof	<javascript: 'return typeof this'>! !!PjObject methodsFor: 'reflection'!typeof: anObject	<javascript: 'return typeof anObject'>! !!PjObject methodsFor: 'testing'!value	" this strange code is to install _value for objects that already have a value field or to return self "	^ PjCore		installDnuArgs: #()		selector: #value		js: PjCore pharoJsSelectorPrefix, 'value'		for: self		else: [ self ]! !!PjObject methodsFor: 'dictionary emulation'!valuesDo: aBlock	<jsGenerator: #valuesDo_jsGenerator:>! !!PjObject methodsFor: 'accessing'!yourself	^self! !!PjObject methodsFor: 'comparing'!~= other	^ (self = other) not! !!PjObject methodsFor: 'comparing'!~~ other	^ (self == other) not! !!PjArrayStream class methodsFor: 'instance creation'!on: aCollection	^ self new on: aCollection! !!PjArrayStream methodsFor: 'initialize-release'!emptyCollection	^ #()! !!PjArrayStream methodsFor: 'accessing'!join	| temp |	temp := OrderedCollection new.	array do: [: each |		each do: [: element |			temp addLast: element		]	].	^ temp! !!PjArrayStream methodsFor: 'accessing'!nextPut: aValue	array addLast: {aValue}.	^ aValue! !!PjReadWriteStream class methodsFor: 'pharoJs support'!jsTranspilationImportMethods	<pharoJsSkip>	^ { 		  (PositionableStream		   ->			   #( back isEmpty match: next: nextDelimited: peek peekBack			      peekFor: position position: positionError reset resetContents			      #setFrom:to: setToEnd skip: upTo: )).		  (WriteStream -> #( << space tab )).		  (Stream -> #( print: )) }! !!PjReadWriteStream methodsFor: 'accessing'!atEnd	position >= readLimit ifTrue: [ self contents ].	^ position >= readLimit! !!PjReadWriteStream methodsFor: 'accessing'!contents	1 < array size ifTrue: [ self load: self join ].	^ collection! !!PjReadWriteStream methodsFor: 'initialize-release'!emptyCollection	self subclassResponsibility! !!PjReadWriteStream methodsFor: 'initialize-release'!initialize	super initialize.	array := OrderedCollection with: (collection := self emptyCollection).	readLimit := 0.	position := 0.! !!PjReadWriteStream methodsFor: 'accessing'!join	^ self subclassResponsibility! !!PjReadWriteStream methodsFor: 'accessing'!load: temp	array := OrderedCollection with: temp.	collection := temp.	readLimit := temp size.	^ temp! !!PjReadWriteStream methodsFor: 'accessing'!next	self atEnd ifTrue: [ ^ nil ].	^ collection at: (position := position + 1)! !!PjReadWriteStream methodsFor: 'accessing'!nextPut: aCharacter	^ self subclassResponsibility! !!PjReadWriteStream methodsFor: 'accessing'!nextPutAll: aCollection	array addLast: aCollection.	^ aCollection! !!PjReadWriteStream methodsFor: 'accessing'!on: temp	self load: temp.	self reset.! !!PjReadWriteStream methodsFor: 'accessing'!skip: n	position := position + n.! !!PjStringStream class methodsFor: 'instance creation'!on: aCollection	^ self new on: aCollection! !!PjStringStream methodsFor: 'initialize-release'!emptyCollection	^ ''! !!PjStringStream methodsFor: 'accessing'!join	^ '' join: array! !!PjStringStream methodsFor: 'accessing'!nextPut: aCharacter	array addLast: aCharacter asString.	^ aCharacter! !!PjRectangle class methodsFor: 'pharojs support'!jsTranspilationImportMethods	<pharoJsSkip>	^ {(Rectangle  				->					#(containsPoint: setPoint:point:)).		(Rectangle class 				->					#(origin:corner:)).							}! !!PjRxParser class methodsFor: 'pharoJs support'!javascriptName	<pharoJsSkip>	^ 'RegExp' ! !!PjRxParser methodsFor: 'testing'!matchesIn: aString	^ aString match: self! !!PjRxParser methodsFor: 'testing'!matchesIn: aString do: aBlock	| matches |	matches := (self matchesIn: aString).	matches ifNil: [ ^ self ].	^ matches do: aBlock! !!PjString class methodsFor: 'instance creation'!defaultSize	^10! !!PjString class methodsFor: 'pharoJs support'!jsTranspilationImportMethods	<pharoJsSkip>	^ self jsTranspilationImportMethodsArray , { 		  (String class -> #( #stringHash:initialHash:		      fromByteArray: )).		  (String		   ->		   #( findTokens: linesDo: lineIndicesDo: printOn: storeOn: isLiteral shouldBePrintedAsLiteral)).		  (Symbol -> #( cull: value: )).		  (Character class -> #( cr escape lf linefeed space tab )).		  (Character -> #( isVowel isCharacter to: )) }! !!PjString class methodsFor: 'instance creation'!new	^ ''! !!PjString class methodsFor: 'instance creation'!new: ignored	^ self new! !!PjString class methodsFor: 'instance creation'!new: anInteger streamContents: aBlock	^ self streamContents: aBlock! !!PjString class methodsFor: 'instance creation'!streamContents: aBlock	| stream |	stream := PjStringStream new.	aBlock value: stream.	^ stream contents! !!PjString class methodsFor: 'instance creation'!value: anInteger	^ String js_fromCharCode: anInteger! !!PjString methodsFor: 'copying'!, other	<javascript: 'return this+other'>! !!PjString methodsFor: 'comparing'!< other	<javascript: 'return this<other'>! !!PjString methodsFor: 'comparing'!<= other	<javascript: 'return this<=other'>! !!PjString methodsFor: 'comparing'!= other	<javascript: 'return this==other'>! !!PjString methodsFor: 'comparing'!> other	<javascript: 'return this>other'>! !!PjString methodsFor: 'comparing'!>= other	<javascript: 'return this>=other'>! !!PjString methodsFor: 'accessing'!allButFirst	^ self js_substring: 1! !!PjString methodsFor: 'accessing'!allButFirst: n	^ self js_substring: n! !!PjString methodsFor: 'accessing'!allButLast	^ self js_substring: 0 to: self size - 1! !!PjString methodsFor: 'accessing'!allButLast: n	^ self js_substring: 0 to: self size - n! !!PjString methodsFor: 'converting'!asCharacter	^ self js_charAt: 0! !!PjString methodsFor: 'converting'!asElementId	^ document getElementById: self! !!PjString methodsFor: 'converting'!asElementSelector	^ document querySelector: self! !!PjString methodsFor: 'converting'!asInteger	<javascript: 'return parseInt(this)'>! !!PjString methodsFor: 'converting'!asJsObject	"Ensure we get a primitive type string and not a String object"	<javascript: 'return this.valueOf()'>! !!PjString methodsFor: 'converting'!asLowercase	^ self js_toLowerCase! !!PjString methodsFor: 'converting'!asNumber	<javascript: 'return parseFloat(this)'>! !!PjString methodsFor: 'converting'!asRegex	^ PjRxParser new: self with: 'g'! !!PjString methodsFor: 'converting'!asString	<javascript: 'return ""+this'>! !!PjString methodsFor: 'converting'!asSymbol	<javascript: 'return ""+this'>! !!PjString methodsFor: 'converting'!asUppercase	^ self js_toUpperCase! !!PjString methodsFor: 'accessing'!asciiValue	^ self js_charCodeAt: 0! !!PjString methodsFor: 'accessing'!at: index	"JavaScript arrays first index is 0 "	<javascript: 'return this[index - 1];'>! !!PjString methodsFor: 'accessing'!at: index put: anObject	<javascript: 'throw new Error("cannot mutate strings");'>! !!PjString methodsFor: 'accessing'!basicAt: aNumber	^ 	self js_charCodeAt: aNumber-1! !!PjString methodsFor: 'comparing'!beginsWith: prefix	^ (self js_substring: 0 to: prefix size)=prefix! !!PjString methodsFor: 'converting'!capitalized	self isEmpty ifTrue: [ ^self ].	^ (self js_charAt:0) js_toUpperCase,(self js_substring: 1)! !!PjString methodsFor: 'accessing'!charCode	^ self basicAt: 1! !!PjString methodsFor: 'accessing'!codePoint	^ self js_charCodeAt: 0! !!PjString methodsFor: 'enumerating'!collect: aBlock	| arr |	arr := self js_split: ''.	1 to: self size do: [: idx |		arr at: idx put: (aBlock value: (arr at: idx))	].	^ arr js_join: ''! !!PjString methodsFor: 'comparing'!copyFrom: start	^ self js_substring: start-1! !!PjString methodsFor: 'comparing'!copyFrom: start to: stop	^ self js_substring: start-1 to: stop! !!PjString methodsFor: 'comparing'!endsWith: suffix	^ (self js_substring: self size - suffix size)=suffix! !!PjString methodsFor: 'accessing'!findString: substring startingAt: start	<javaScript: 'return this.indexOf(substring,start-1)+1'>! !!PjString methodsFor: 'accessing'!first	^self at: 1! !!PjString methodsFor: 'accessing'!first: n	^ self js_substring: 0 to: n! !!PjString methodsFor: 'comparing'!hash	"#hash is implemented, because #= is implemented"	"ar 4/10/2005: I had to change this to use ByteString hash as initial 	hash in order to avoid having to rehash everything and yet compute	the same hash for ByteString and WideString."	^ self class stringHash: self initialHash: 0! !!PjString methodsFor: 'testing'!ifEmpty: aBlock	self isEmpty ifTrue: [^aBlock value].	^self! !!PjString methodsFor: 'testing'!isAlphaNumeric	| char |	char := (self js_charAt: 0).	^ char isLetter or: [ char isDigit ]! !!PjString methodsFor: 'testing'!isDigit	^ (self js_charCodeAt: 0) between: 48 and: 57 ! !!PjString methodsFor: 'testing'!isEmpty	^self = ''! !!PjString methodsFor: 'testing'!isJSPrimitiveType	^ true! !!PjString methodsFor: 'testing'!isLetter	^self letterCharCodes includes: (self js_charCodeAt: 0)! !!PjString methodsFor: 'testing'!isSelfEvaluating 	^true! !!PjString methodsFor: 'testing'!isSeparator 	| in |	^ (in := (self js_charCodeAt: 0) asInteger) == 32 or: [ in == 13 or: [ in == 9 or: [ in == 10 or: [ in == 12 ] ] ] ]! !!PjString methodsFor: 'testing'!isString	^ true! !!PjString methodsFor: 'splitjoin'!join: anArray	^ anArray js_join: self! !!PjString methodsFor: 'accessing'!last	^self at: self size! !!PjString methodsFor: 'accessing'!lastIndexOf: x	<javascript: 'return this.lastIndexOf(x)+1'>! !!PjString methodsFor: 'testing'!letterCharCodes	^#(65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 170 181 186 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 248 249 250 251 252 253 254 255)! !!PjString methodsFor: 'testing'!notEmpty	^self ~= ''! !!PjString methodsFor: 'proxy'!proxyResponse	<javascript: 'return ""+this'>! !!PjString methodsFor: 'writing'!readStream	^ PjStringStream on: self! !!PjString methodsFor: 'accessing'!replaceFrom: start to: stop with: replacement startingAt: repStart	<javascript: '	var repl=[],isString=typeof replacement=="string";	for(var mine=stop-1,other=mine+repStart-start;		mine>=start-1;		--other,--mine		)repl[other]=isString?replacement[other]:String.fromCharCode(replacement[other]);		return this.substring(0,start-1)+repl.join("")+this.substr(stop)'>! !!PjString methodsFor: 'converting'!reversed	^ '' join: self asArray reverse! !!PjString methodsFor: 'testing'!shouldBePrintedAsLiteral	^true! !!PjString methodsFor: 'accessing'!size	^self js_at:#length! !!PjString methodsFor: 'splitjoin'!split: aString	^ aString js_split: self! !!PjString methodsFor: 'splitjoin'!splitOn: anArray	^ anArray split: self! !!PjString methodsFor: 'converting'!value	<javascript: 'return ""+this'>! !!PjString methodsFor: 'writing'!writeStream	^ PjStringStream new! !!PjString methodsFor: 'comparing'!~= other	<javascript: 'return this!!=other'>! !!PjUndefinedObject class methodsFor: 'class initialization'!identityHash_jsGenerator: transpiler	<pharoJsSkip>	^'return ', nil identityHash asString! !!PjUndefinedObject class methodsFor: 'class initialization'!javascriptInitialize	uniqueInstance := self basicNew.	Object js_freeze: uniqueInstance;	 js_freeze: self	! !!PjUndefinedObject class methodsFor: 'pharojs support'!javascriptName	<pharoJsSkip>	^self name! !!PjUndefinedObject class methodsFor: 'pharoJs support'!jsTranspilationImportMethods	<pharoJsSkip>	^ { (UndefinedObject	   -> #( isNil ifNil: ifNotNil: #ifNil:ifNotNil: #ifNotNil:ifNil:		      isNotNil notNil isEmptyOrNil isLiteral printOn: )) }! !!PjUndefinedObject class methodsFor: 'class initialization'!new	^PjCore signal: 'cannot create instances of UndefinedObject'! !!PjUndefinedObject methodsFor: 'comparing'!= other	<javascript: 'return null==other'>! !!PjUndefinedObject methodsFor: 'converting'!asJSON	^ 'null'! !!PjUndefinedObject methodsFor: 'comparing'!identityHash	<jsGenerator: #identityHash_jsGenerator:>! !!PjUndefinedObject methodsFor: 'accessing'!isJSPrimitiveType	^ true! !!PjUndefinedObject methodsFor: 'converting'!proxyResponse	^ self! !!PjUndefinedObject methodsFor: 'converting'!value	^ nil! !!Float class methodsFor: '*PharoJs-Base-JS-CoreLibraries'!javascriptPlaceholder	^ PjNumber! !!Time class methodsFor: '*PharoJs-Base-JS-CoreLibraries'!javascriptPlaceholder	^ PjTime! !!Margin class methodsFor: '*PharoJs-Base-JS-CoreLibraries'!javascriptPlaceholder	^ PjMargin! !!SequenceableCollection class methodsFor: '*PharoJs-Base-JS-CoreLibraries'!javascriptPlaceholder	^ PjArray! !!Number class methodsFor: '*PharoJs-Base-JS-CoreLibraries'!javascriptPlaceholder	^ PjNumber! !!UndefinedObject class methodsFor: '*PharoJs-Base-JS-CoreLibraries'!javascriptPlaceholder	^ PjUndefinedObject! !!UndefinedObject methodsFor: '*PharoJs-Base-JS-CoreLibraries-converting'!asJsObjectUsing: converter	^self! !!UndefinedObject methodsFor: '*PharoJs-Base-JS-CoreLibraries'!isPjProxyOrNil	^ false! !!Class class methodsFor: '*PharoJs-Base-JS-CoreLibraries'!javascriptPlaceholder	^PjClass! !!BlockClosure class methodsFor: '*PharoJs-Base-JS-CoreLibraries'!javascriptPlaceholder	^ PjFunction! !!SortedCollection class methodsFor: '*PharoJs-Base-JS-CoreLibraries-Kernel'!javascriptPlaceholder	<pharoJsSkip>	^PjSortedCollection! !!Collection class methodsFor: '*PharoJs-Base-JS-CoreLibraries'!javascriptPlaceholder	^PjCollection! !!Collection methodsFor: '*PharoJs-Base-JS-CoreLibraries-converting'!asJsObjectUsing: converter	^self collect: [ : each | each  asJsObjectUsing: converter]! !!Array class methodsFor: '*PharoJs-Base-JS-CoreLibraries'!javascriptPlaceholder	^ PjArray! !!Array methodsFor: '*PharoJs-Base-JS-CoreLibraries-converting'!asJsObjectUsing: converter	"This method is used only in the Pharo world. In JS, we use instead PjTArray>>#asJsObject"	(self notEmpty and: [(self first isKindOf: Association) not]) ifTrue: [ 		^self	].	^self asDictionary asJsObjectUsing: converter! !"PharoJs-Base-JS-CoreLibraries"!!ManifestPharoJsBaseSerialization commentStamp: '' prior: 0!Obviously one of the most rudimentary needs is the ability to transfer instances between pharo an js world in a transparent and reciprocal way.I concidered using STON or NeoJson, but neither are useable in js world (I think? By the way, I really miss String streamContents in js )Eventhough it feels like I'm trying to renvent the wheel, I just started working on r/w classes: PhxJsonWriter and PhxJsonReader.The serialized form is pure JSON. It includes meta info, needed for deserialization.example:	(Date newDay: 1 month: 2 year: 2003) asPhxJsonString  evaluates as: '{"class":"Date","instance":"2003-02-01"}'.	It's a bit like STON except:-it's pure JSON (not a superset)-The  r/w classes can be used in js world.It also uses references to instances (for efficiency an cyclic problems)So far following tests are green in Pharo.	self isEqualAfterWriteReadCycle: {}.	self isEqualAfterWriteReadCycle: OrderedCollection new.	self isEqualAfterWriteReadCycle: Date today.		self isEqualAfterWriteReadCycle: DateAndTime now.		self isEqualAfterWriteReadCycle: 'Hi there, I''m just a "String", and I cost only 2. Ol!!'.	self isEqualAfterWriteReadCycle: Object new.	self isEqualAfterWriteReadCycle: 123456789.	self isEqualAfterWriteReadCycle: 12345.6789.	self isEqualAfterWriteReadCycle: PhxJsonWriter testObject1	Now I stumble upon the fact that OrderedCollection in js world becomes an Array.Also DateAndTime becomes a Date in js.Suggestions or ideas anyone?!!PhxJsonReader commentStamp: '' prior: 0!A JSON Reader - to read an object from JSON format!!PhxJsonWriter commentStamp: '' prior: 0!A JSON Writer - to write an object into JSON format!!Number methodsFor: '*PharoJs-Base-Serialization'!writePhxJsonOn: w	w << self asString! !!Set class methodsFor: '*PharoJs-Base-Serialization'!instantiateWithPhxJsonReader: reader instanceJsonObject: jsonObject	| newCollection |	newCollection := self new.	reader addKnownObject: newCollection.	jsonObject do: [ : each | newCollection add: (reader readFromJsObjectOrDictionary: each) ].	^newCollection! !!PjBoolean methodsFor: '*PharoJs-Base-Serialization'!writePhxJsonOn: w	w << self! !!PjSet class methodsFor: '*PharoJs-Base-Serialization'!phxJsonClassName	^ 'Set'! !!PjDate class methodsFor: '*PharoJs-Base-Serialization'!instantiateWithPhxJsonReader: reader instanceJsonObject: str	"<javascript:		'  var y = str.substr(0,4),        m = str.substr(5,2) - 1,        d = str.substr(8,2);    return new Date(y,m,d);'>"	<javascript: 'return new Date(str);'>! !!PjDate class methodsFor: '*PharoJs-Base-Serialization'!phxJsonClassName	^ 'DateAndTime'! !!PjDate methodsFor: '*PharoJs-Base-Serialization'!writePhxJsonRepresentationOn: w	w writeQuoted: "self yyyymmdd" self toISOString "toString"! !!PjDate methodsFor: '*PharoJs-Base-Serialization'!yyyymmdd	<javascript: ' var d = new Date(this),        month = "" + (d.getMonth() + 1),        day = "" + d.getDate(),        year = d.getFullYear();    if (month.length < 2)         month = "0" + month;    if (day.length < 2)         day = "0" + day;    return [year, month, day].join("-");'>! !!DateAndTime class methodsFor: '*PharoJs-Base-Serialization'!instantiateWithPhxJsonReader: reader instanceJsonObject: jsonObject	^ reader addKnownObject: (self fromString: jsonObject)! !!DateAndTime methodsFor: '*PharoJs-Base-Serialization'!writePhxJsonOn: w	self writePhxJsonObjectOn: w! !!DateAndTime methodsFor: '*PharoJs-Base-Serialization'!writePhxJsonRepresentationOn: w	w writeQuoted: self asUTC asString! !!False methodsFor: '*PharoJs-Base-Serialization'!writePhxJsonOn: w	w << 'false'! !!PjTArray classTrait methodsFor: '*PharoJs-Base-Serialization'!instantiateWithPhxJsonReader: reader instanceJsonObject: jsonObject	| resultCollection elements |	resultCollection := self new: jsonObject size.	reader addKnownObject: resultCollection.	elements := jsonObject collect: [ :each | reader readFromJsObjectOrDictionary: each ].	^resultCollection		addAll: elements;		yourself! !!PjArray methodsFor: '*PharoJs-Base-Serialization'!writePhxJsonRepresentationOn: w	w		doBetweenSquareBrackets: [ self				do: [ :each | each writePhxJsonOn: w ]				separatedBy: [ w comma ] ]! !!ScaledDecimal methodsFor: '*PharoJs-Base-Serialization'!writePhxJsonOn: w	w << (self printShowingDecimalPlaces: self scale)! !!Dictionary class methodsFor: '*PharoJs-Base-Serialization'!instantiateWithPhxJsonReader: reader instanceJsonObject: jsonObject	| newDict |	newDict := self new.	reader addKnownObject: newDict.	jsonObject keysAndValuesDo: [ :key :value | 		newDict at: key put: (reader readFromJsObjectOrDictionary: value) ].	^ newDict! !!Dictionary methodsFor: '*PharoJs-Base-Serialization'!writePhxJsonRepresentationOn: w	w		doBetweenCurlyBraces: [ self keys				do:					[ :key | w writeKeyName: key andValue: [ (self at: key) writePhxJsonOn: w ] ]				separatedBy: [ w comma ] ]! !!PjDictionary class methodsFor: '*PharoJs-Base-Serialization'!phxJsonClassName	^ 'Dictionary'! !!PjDictionary methodsFor: '*PharoJs-Base-Serialization'!writePhxJsonRepresentationOn: w	self asJsObject writePhxJsonRepresentationOn: w! !!SequenceableCollection class methodsFor: '*PharoJs-Base-Serialization'!instantiateWithPhxJsonReader: reader instanceJsonObject: jsonObject	| resultCollection |	resultCollection := self ofSize: jsonObject size.	reader addKnownObject: resultCollection.	jsonObject		doWithIndex: [ :each :index | 			resultCollection				at: index				put: (reader readFromJsObjectOrDictionary: each) ].	^ resultCollection! !!PjObject class methodsFor: '*PharoJs-Base-Serialization'!instantiateWithPhxJsonReader: reader instanceJsonObject: jsonObject	| obj |	obj := self new.	reader addKnownObject: obj.	jsonObject		keysAndValuesDo: [ :k :v | obj instVarNamed: k put: (reader readFromJsObjectOrDictionary: v) ].	^ obj! !!PjObject class methodsFor: '*PharoJs-Base-Serialization'!jsTranspilationImportMethodsNonstandard	<pharoJsSkip>	^ {(Object class -> #(newPhxJsonWriter)).	(Object		->			#(asPhxJsonString #writePhxJsonOn: writePhxJsonRepresentationOn: #writePhxJsonObjectOn:))}! !!PjObject class methodsFor: '*PharoJs-Base-Serialization'!phxJsonClassName	^ self name! !!PjObject methodsFor: '*PharoJs-Base-Serialization'!allPhxJsonInstvarNames	^ self keys! !!PjAssociation class methodsFor: '*PharoJs-Base-Serialization'!phxJsonClassName	^ 'Association'! !!UndefinedObject methodsFor: '*PharoJs-Base-Serialization'!writePhxJsonOn: w	w << 'null'! !!PjString methodsFor: '*PharoJs-Base-Serialization'!writePhxJsonOn: w	w << self asJSON! !!PhxJsonReader class methodsFor: 'instance creation'!materializeJsonString: aString	<javascript: 'return JSON.parse(aString)'>	"returns a javascript object in js world"	"returns a dictionary in st world"		^ STONJSON fromString: aString readStream! !!PhxJsonReader class methodsFor: 'instance creation'!readFromJsObjectOrDictionary: jsObjectOrDictionary	^ self new readFromJsObjectOrDictionary: jsObjectOrDictionary! !!PhxJsonReader class methodsFor: 'instance creation'!readFromString: aString	^ self readFromJsObjectOrDictionary: (self materializeJsonString: aString)! !!PhxJsonReader methodsFor: 'instance creation'!addKnownObject: anObject	^knownObjects add: anObject! !!PhxJsonReader methodsFor: 'instance creation'!classNameForJsonClassName: jsonClassName	<javascript:		'if(jsonClassName == "DateAndTime") { return "Date"}if(jsonClassName == "Dictionary") { return "PjDictionary"}if(jsonClassName == "Association") { return "PjAssociation"}if(jsonClassName == "IdentityDictionary") { return "PjIdentityDictionary"}if(jsonClassName == "Set") { return "PjSet"}return jsonClassName;'>	^ jsonClassName! !!PhxJsonReader methodsFor: 'initialize-release'!initialize	knownObjects := OrderedCollection new! !!PhxJsonReader methodsFor: 'instance creation'!readFromJsObjectOrDictionary: jsonObject	| jsonClassName |	jsonObject ifNil: [ ^ nil ].	jsonObject isString		ifTrue: [ ^ jsonObject ].	jsonObject isNumber		ifTrue: [ ^ jsonObject ].	jsonObject == true		ifTrue: [ ^ true ].	jsonObject == false		ifTrue: [ ^ false ].	(jsonObject at: 'instRef' ifAbsent: [ nil ])		ifNotNil: [ :idx | ^ knownObjects at: idx ].	jsonClassName := jsonObject at: 'class' ifAbsent: [ nil ].	(self classNameForJsonClassName: jsonClassName)		ifNotNil: [ :className | 			| class instJsonObject |			class := Smalltalk at: className asSymbol ifAbsent: [ nil ].			class ifNil: [ self error: 'Class not found: ' , className ].			instJsonObject := jsonObject at: 'instance'.			^ (class						instantiateWithPhxJsonReader: self						instanceJsonObject: instJsonObject) ].	^ self error! !!PhxJsonWriter methodsFor: 'writing'!<< aString	stream nextPutAll: aString! !!PhxJsonWriter methodsFor: 'writing'!comma	self << ','! !!PhxJsonWriter methodsFor: 'writing'!doBetweenCurlyBraces: aBlock	self << '{'.	aBlock value. 	self << '}'! !!PhxJsonWriter methodsFor: 'writing'!doBetweenSquareBrackets: aBlock	self << '['.	aBlock value. 	self << ']'! !!PhxJsonWriter methodsFor: 'writing'!identityIndexOf: anObject	knownObjects		doWithIndex: [ :obj :index | 			obj == anObject				ifTrue: [ ^ index ] ].	^ nil! !!PhxJsonWriter methodsFor: 'initialize-release'!initialize	stream := '' writeStream.	knownObjects := OrderedCollection new! !!PhxJsonWriter methodsFor: 'accessing'!string	^ stream contents! !!PhxJsonWriter methodsFor: 'writing'!writeKeyName: key andValue: anObject	self writeQuoted: key.	self << ':'.	anObject isBlock		ifTrue: [ anObject value ]		ifFalse: [ anObject				ifNil: [ self << 'null' ]				ifNotNil: [ self << anObject asJSON ] ]! !!PhxJsonWriter methodsFor: 'writing'!writeQuoted: aString	self << '"' << aString << '"'! !!PhxJsonWriter methodsFor: 'writing'!writeReferenceFor: anObject or: aBlock	(self identityIndexOf: anObject)		ifNotNil: [ :i | 			i isZero				ifFalse: [ self						doBetweenCurlyBraces: [ self writeKeyName: 'instRef' andValue: i ].					^ self ] ].	knownObjects add: anObject.	aBlock value! !!Collection methodsFor: '*PharoJs-Base-Serialization'!writePhxJsonRepresentationOn: w	w		doBetweenSquareBrackets: [ self				do: [ :each | each writePhxJsonOn: w ]				separatedBy: [ w comma ] ]! !!Date class methodsFor: '*PharoJs-Base-Serialization'!instantiateWithPhxJsonReader: reader instanceJsonObject: aString	^self readFrom: (aString ifNotNilOrEmpty: [aString first:10]) pattern: 'yyyy-mm-dd'! !!Date methodsFor: '*PharoJs-Base-Serialization'!writePhxJsonOn: w	self writePhxJsonObjectOn: w! !!Date methodsFor: '*PharoJs-Base-Serialization'!writePhxJsonRepresentationOn: w	w writeQuoted: self yyyymmdd! !!PjIdentityDictionary class methodsFor: '*PharoJs-Base-Serialization'!instantiateWithPhxJsonReader: reader instanceJsonObject: jsonObject	| obj |	obj := self new.	reader addKnownObject: obj.	jsonObject		keysAndValuesDo: [ :k :v | obj at: k put: (reader readFromJsObjectOrDictionary: v) ].	^ obj ! !!PjIdentityDictionary class methodsFor: '*PharoJs-Base-Serialization'!phxJsonClassName	^ 'IdentityDictionary'! !!True methodsFor: '*PharoJs-Base-Serialization'!writePhxJsonOn: w	w << 'true'! !!PjCollection methodsFor: '*PharoJs-Base-Serialization'!writePhxJsonRepresentationOn: w	w		doBetweenSquareBrackets: [ self				do: [ :each | each writePhxJsonOn: w ]				separatedBy: [ w comma ] ]! !!PjNumber methodsFor: '*PharoJs-Base-Serialization'!writePhxJsonOn: w	w << self asString! !!Object class methodsFor: '*PharoJs-Base-Serialization'!instantiateWithPhxJsonReader: reader instanceJsonObject: jsonObject	| obj |	obj := self new.	reader addKnownObject: obj.	jsonObject keys asSortedCollection do: [ : ivName | 		|ivValue|		ivValue := jsonObject at: ivName.		obj instVarNamed: ivName put: (reader readFromJsObjectOrDictionary: ivValue) ].	^ obj! !!Object class methodsFor: '*PharoJs-Base-Serialization'!newPhxJsonWriter	^PhxJsonWriter new! !!Object class methodsFor: '*PharoJs-Base-Serialization'!phxJsonClassName	^ self name! !!Object methodsFor: '*PharoJs-Base-Serialization'!allPhxJsonInstvarNames	^ self class allInstVarNames! !!Object methodsFor: '*PharoJs-Base-Serialization'!asPhxJsonString	| writer |	writer := self class newPhxJsonWriter.	self writePhxJsonOn: writer.	^ writer string! !!Object methodsFor: '*PharoJs-Base-Serialization'!writePhxJsonObjectOn: w	^ w		doBetweenCurlyBraces: [ w writeKeyName: 'class' andValue: self class phxJsonClassName.			w comma.			"usefull for debugging: 			w writeKeyName: 'instId' andValue: (w identityIndexOf: self).			w comma."			w				writeKeyName: 'instance'				andValue: [ self writePhxJsonRepresentationOn: w ] ]! !!Object methodsFor: '*PharoJs-Base-Serialization'!writePhxJsonOn: w	w		writeReferenceFor: self		or: [ self writePhxJsonObjectOn: w ]! !!Object methodsFor: '*PharoJs-Base-Serialization'!writePhxJsonRepresentationOn: w	w doBetweenCurlyBraces: [ 		self allPhxJsonInstvarNames asSortedCollection			do: [ :key | 				w					writeKeyName: key					andValue: [ (self instVarNamed: key) writePhxJsonOn: w ] ]			separatedBy: [ w comma ] ]! !!PjDateAndTime class methodsFor: '*PharoJs-Base-Serialization'!instantiateWithPhxJsonReader: reader instanceJsonObject: str	<javascript: 'return new Date(str);'>! !!PjDateAndTime class methodsFor: '*PharoJs-Base-Serialization'!phxJsonClassName	^ 'DateAndTime'! !!PjDateAndTime methodsFor: '*PharoJs-Base-Serialization'!writePhxJsonRepresentationOn: w	w writeQuoted: "self yyyymmdd" self toISOString "toString"! !!PjUndefinedObject methodsFor: '*PharoJs-Base-Serialization'!writePhxJsonOn: w	w << 'null'! !!String methodsFor: '*PharoJs-Base-Serialization'!writePhxJsonOn: w	w << (STONJSON toString: self)! !"PharoJs-Base-Serialization"!!PjApplication commentStamp: '' prior: 0!I am the class that all PharoJS applications should extend.I contain methods that DOM (Browser and PhoneGap) and NodeJS applications have in common.!!PjDOMApplication commentStamp: '' prior: 0!I am the abstract superclass that all client-side PharoJS applications should extend (directly or indirectly).I contain methods that Browser and PhoneGap applications have in common.!!PjWebApplication commentStamp: '' prior: 0!I am the abstract superclass that all web-based PharoJS applications should extend (directly or indirectly). Those are apps that rely on HTML and run in a web browser or a web view !!PjFileBasedWebApp commentStamp: '' prior: 0!I am a web app that rely on a HTML file. My JS code is exported to a JS file that should be referenced by the HTML file.!!PjNodeApplication commentStamp: '' prior: 0!I am the abstract superclass that all server-side PharoJS applications should extend (directly or indirectly)To open playground for concrete subclasses or run tests via PharoJS test framework, please ensure node package ws (https://www.npmjs.com/package/ws) is installed in your system.!!PjExpressApp commentStamp: '' prior: 0!I use [expressJS](https://expressjs.com) to make a web app.I assume that the target folder comply with the following :- The folder is an npm initialized folder, i.e you have run `npm init`- The express node modules is installed, i.e. you should run `npm install express` in the app's folder- The [body-parser](https://expressjs.com/en/resources/middleware/body-parser.html): Parse incoming request bodies in a middleware before your handlers, available under the req.body property.- Optional: [serve-static](https://expressjs.com/en/resources/middleware/serve-static.html): Create a new middleware function to serve files from within a given root directory. The file to serve will be determined by combining req.url with the provided root directory. When a file is not found, instead of sending a 404 response, this module will instead call next() to move on to the next middleware, allowing for stacking and fall-backs.!!PjTWebClientApp classTrait methodsFor: 'exporting'!defaultAppFolderName	<pharoJsSkip>	^ self serverAppClass staticFilesFolderName! !!PjTWebClientApp classTrait methodsFor: 'exporting'!defaultAppFolderParent	<pharoJsSkip>	^ self serverAppClass appFolder! !!PjTWebClientApp classTrait methodsFor: 'exporting'!serverAppClass	<pharoJsSkip>	^ self explicitRequirement ! !!PjApplication class methodsFor: 'accessing - description'!appClass	<pharoJsSkip>		^ self! !!PjApplication class methodsFor: 'accessing - description'!appClasses	<pharoJsSkip>	^ self appClass withAllSuperclasses! !!PjApplication class methodsFor: 'accessing - description'!appLaunchBlock	<pharoJsSkip>	| appClass |	appClass := self.	^[ appClass start ] asClosedBlock! !!PjApplication class methodsFor: 'accessing - description'!appPackages	<pharoJsSkip>		^ Set new! !!PjApplication class methodsFor: 'instance creation'!currentInstance	^ currentInstance! !!PjApplication class methodsFor: 'accessing'!headerLine	<pharoJsSkip>		^ nil! !!PjApplication class methodsFor: 'accessing'!pharoJsSelectorPrefix	<pharoJsSkip>		^ 'pj_'! !!PjApplication class methodsFor: 'instance creation'!resetCurrentInstance	<script>		currentInstance := nil! !!PjApplication class methodsFor: 'accessing - description'!setupCode	<pharoJsSkip>		^ ''! !!PjApplication class methodsFor: 'start-stop application'!start	<script>		self whenJsReady: [ self startInstance ]! !!PjApplication class methodsFor: 'private'!startInstance		self currentInstance ifNil: [ currentInstance := self new ].	self currentInstance start! !!PjApplication class methodsFor: 'start-stop application'!stop	<script>		self currentInstance ifNil: [ ^ self ].	self currentInstance stop! !!PjApplication class methodsFor: 'private'!whenJsReady: aBlock	self subclassResponsibility! !!PjApplication methodsFor: 'start-stop'!start! !!PjApplication methodsFor: 'start-stop'!stop! !!PjDOMApplication class methodsFor: 'accessing - description'!appClasses	<pharoJsSkip>		^ super appClasses, { PjHTMLCollection. PjNodeList}! !!PjDOMApplication class methodsFor: 'testing'!isAbstract	^ self = PjDOMApplication		  ifTrue: [ ^ true ]		  ifFalse: [ super isAbstract ]! !!PjDOMApplication class methodsFor: 'accessing - description'!setupCode	<pharoJsSkip>	^ super setupCode , 'var global=global??this'! !!PjDOMApplication methodsFor: 'accessing' prior: 33880466!document	^ document! !!PjDOMApplication methodsFor: 'start-stop'!start	super start.	self subscribeToDeviceEvents! !!PjDOMApplication methodsFor: 'initialize-release'!subscribeToDeviceEvents	^self! !!PjFileBasedWebApp class methodsFor: 'testing'!isAbstract	^ self = PjFileBasedWebApp 					ifTrue: [ ^ true ]		  			ifFalse: [ super isAbstract ]! !!PjWebApplication class methodsFor: 'testing'!isAbstract	^ self = PjWebApplication		  ifTrue: [ ^ true ]		  ifFalse: [ super isAbstract ]! !!PjWebApplication class methodsFor: 'private'!whenJsReady: aBlock	"The subscription to the load event is done in JS code only to allow running applications as pharo object. This is useful during development stages when all Pharo code runs on Pharo side, while a web browser provides JS objects."	<javascript: 'window.addEventListener("load", aBlock)'>		^ aBlock value! !!PjExpressApp class methodsFor: 'testing'!isAbstract	^ self = PjExpressApp 		  ifTrue: [ ^ true ]		  ifFalse: [ super isAbstract ]! !!PjExpressApp methodsFor: 'accessing'!bodyParser	^self moduleNamed: 'body-parser'! !!PjExpressApp methodsFor: 'initialization'!bodyParserMiddleware	"More options and alternatives such as json in body-parser module doc	https://expressjs.com/en/resources/middleware/body-parser.html"	^ self bodyParser text! !!PjExpressApp methodsFor: 'initialization'!defaultPort	^4321! !!PjExpressApp methodsFor: 'initialization'!initialize	super initialize.	server := self newServer.	self port: self defaultPort.	server use: self bodyParserMiddleware! !!PjExpressApp methodsFor: 'initialization'!newServer	^ (self moduleNamed: 'express') value! !!PjExpressApp methodsFor: 'accessing'!port	^ port! !!PjExpressApp methodsFor: 'accessing'!port: anObject	port := anObject! !!PjExpressApp methodsFor: 'initialization'!serveStaticFilesIn: localFolderName	| path serveStatic |	path := self fullPathFor: localFolderName.	serveStatic := self serveStaticFunction value: path.	server use: serveStatic.! !!PjExpressApp methodsFor: 'accessing'!serveStaticFunction	^ self moduleNamed: 'serve-static'! !!PjExpressApp methodsFor: 'start-stop'!start 	super start.	server listen: self port onStartDo: [ self startUpAction ]! !!PjExpressApp methodsFor: 'start-stop'!startUpAction	console log:		self className , ' web app started on port ' , self port asString! !!PjNodeApplication class methodsFor: 'accessing'!headerLine	<pharoJsSkip>		^ '#!! /usr/bin/env node'! !!PjNodeApplication class methodsFor: 'testing'!isAbstract	^ self = PjNodeApplication 					ifTrue: [ ^ true ]		 		   ifFalse: [ super isAbstract ]! !!PjNodeApplication class methodsFor: 'accessing'!modulesFolder	<pharoJsSkip>	^ (self appFolder / self modulesFolderName) ! !!PjNodeApplication class methodsFor: 'accessing'!modulesFolderName	^'node_modules'! !!PjNodeApplication class methodsFor: 'private'!whenJsReady: aBlock	aBlock value! !!PjNodeApplication methodsFor: 'accessing'!dirName"__dirname is an environment variable that tells you the absolute path of the directory containing the currently executing file."	<javascript: 'return __dirname'>	! !!PjNodeApplication methodsFor: 'accessing'!fullPathFor: relativePathName	^self pathFactory		        join: self dirName		        with: relativePathName! !!PjNodeApplication methodsFor: 'accessing'!moduleNamed: aString	^self modulesManager moduleNamed: aString! !!PjNodeApplication methodsFor: 'accessing'!modulesManager	^PjNodeModulesManager default! !!PjNodeApplication methodsFor: 'accessing'!pathFactory	^ self moduleNamed: 'path'! !!PjNodeModulesManager class methodsFor: 'accessing'!default	^default ifNil: [ default := self new ]! !!PjNodeModulesManager class methodsFor: 'accessing'!moduleNamed: aString	^self default moduleNamed: aString! !!PjNodeModulesManager class methodsFor: 'accessing'!resetDefault	default := nil! !!PjNodeModulesManager methodsFor: 'initialization'!initialize 	super initialize .	modulesDict := Dictionary new! !!PjNodeModulesManager methodsFor: 'accessing'!moduleNamed: aString	^ modulesDict		  at: aString asSymbol		  ifAbsentPut: [ self require: aString ]! !!PjNodeModulesManager methodsFor: 'accessing'!require: moduleName	^ Smalltalk require: moduleName! !"PharoJs-Base-App"!!PjExporter commentStamp: '' prior: 0!I use PjTranspiler to export a PharoJs application to a stream.!!PjFileExporter commentStamp: '' prior: 0!I use PjTranspiler to export a PharoJs application to a file.!!PjTestFileExporter commentStamp: '' prior: 0!I am used in tests.I use all the same mechanisms as PjFileExporter, except I don't output to a file, but rather remember it to be accessed by the contents method.!!ManifestPharoJsBaseExporter commentStamp: '' prior: 0!I store metadata for this package. These meta data are used by other tools such as the SmalllintManifestChecker and the critics Browser!!PjDependentTranspiler commentStamp: '' prior: 0!I am a PjTranspiler where convertAllClasses: automatically includes any classes required by the given classes!!PjExporter class methodsFor: 'accessing'!bootstrapClasses	^ {Object. Boolean. Number. String. UndefinedObject. BlockClosure. Error. Array. Class}! !!PjExporter class methodsFor: 'accessing'!coreClass	^ self transpilerClass coreClass! !!PjExporter class methodsFor: 'instance creation'!newWithAppClass: aClass	^self new		initializeWithAppClass: aClass;		yourself! !!PjExporter class methodsFor: 'accessing'!transpilerClass	^ PjDependentTranspiler! !!PjExporter methodsFor: 'writing low-level'!<< aString	jsStream << aString! !!PjExporter methodsFor: 'adding'!addAllClasses: someClasses	someClasses do: [ :each | self addClass: each ]! !!PjExporter methodsFor: 'adding'!addAllPackages: packageNames	packageNames do: [ :each | self addPackage: each ]! !!PjExporter methodsFor: 'adding'!addClass: aClass	(self isExportable: aClass) ifFalse: [ ^ self ].	self classes add: aClass! !!PjExporter methodsFor: 'adding'!addPackage: packageName	"gather all classes from the package with name packageName. This includes definedClasses	and extendedClasses. As there could be a Metaclass in the list we collect only the 	instanceSide of Metaclass"	self addAllClasses:		((self classesInPackageNamed: packageName) collect:			 #instanceSide) asSet! !!PjExporter methodsFor: 'accessing'!appClass	^ appClass! !!PjExporter methodsFor: 'accessing'!bootstrapClasses	^ self class bootstrapClasses! !!PjExporter methodsFor: 'accessing'!classes	^ classes! !!PjExporter methodsFor: 'adding'!classesInPackageNamed: packageName	| package tagName tag |	package := RPackage organizer packageMatchingExtensionName:		           packageName.	packageName == packageName ifTrue: [ ^ package classes ].tagName := packageName allButFirst:  package name size + 1.tag := package classTagNamed: tagName.^tag classes.! !!PjExporter methodsFor: 'loading'!convertAllClassesToJs: someClasses	someClasses do: [ :aClass | self invalidateClass: aClass ].	self addAllClasses: someClasses.	^ self transpiler onTempStreamDo: [ 		  self transpiler			  convertAllClasses: self nonBootstrapClasses			  writeDnu: true ]! !!PjExporter methodsFor: 'writing'!copyMethodsSelector	^ #copyMethods! !!PjExporter methodsFor: 'accessing'!coreClass	^ self class coreClass! !!PjExporter methodsFor: 'writing low-level'!cr	jsStream lf! !!PjExporter methodsFor: 'writing low-level'!crtab	jsStream cr; tab! !!PjExporter methodsFor: 'writing'!dnuHook	^ [ 	  self writeGlobalsPolyfills: nil.	  true ]! !!PjExporter methodsFor: 'writing core'!fixInheritanceLinkOfMethodDefinition	^'function(aClass) {    if (!!aClass.hasOwnProperty("subclasses")) {        aClass.subclasses = [];    }    let currentSuperclass;    if (aClass == Object) {        currentSuperclass = undefined;    } else {        currentSuperclass = aClass.__proto__;    }    if (currentSuperclass == undefined) { return this; }    if (!!currentSuperclass.hasOwnProperty("subclasses")) {        return currentSuperclass.subclasses = [aClass];    }    if (currentSuperclass.subclasses.includes(aClass)) { return; }    currentSuperclass.subclasses.push(aClass);}'! !!PjExporter methodsFor: 'writing core'!fixInheritanceLinkOfSelector	^ #fixInheritanceLinkOf! !!PjExporter methodsFor: 'writing core'!fixMetaclassOfMethodDefinition	^'function(aClass){  if (aClass === this) { return this; }  if (aClass === Object) {    return Object.setPrototypeOf(aClass, PjClass.prototype);  }  if (Object.getPrototypeOf(aClass) === Function.prototype){     return Object.setPrototypeOf(aClass, Object);  }}'! !!PjExporter methodsFor: 'writing core'!fixMetaclassOfSelector	^ #fixMetaclassOf! !!PjExporter methodsFor: 'accessing'!headerLine	^ self appClass headerLine! !!PjExporter methodsFor: 'initialize-release'!initialize	super initialize.	classes := Set new.	globalsPools := Set new.	self transpiler: self transpilerClass new.	self transpiler addAllOptionalConversions "Except: 0 to: 1/2".	self setUpForPolyfill! !!PjExporter methodsFor: 'accessing'!initializeWithAppClass: aClass	appClass := aClass.	transpiler pharoJsSelectorPrefix: aClass pharoJsSelectorPrefix.	self addAllClasses: appClass appClasses.	self addAllPackages: appClass appPackages! !!PjExporter methodsFor: 'writing'!installAllAliasesSelector	^PjTranspiler installAllAliasesSelector! !!PjExporter methodsFor: 'writing core'!installClassSelector	^self transpiler installClassSelector! !!PjExporter methodsFor: 'writing'!installJsClassPlaceholderSelector	^self transpiler installJsClassPlaceholderSelector! !!PjExporter methodsFor: 'testing'!isExportable: aClass	aClass ifNil: [ ^ false ].	aClass isTrait ifTrue: [ ^false ].	aClass isTestCase ifTrue: [ ^false ].	(aClass includesBehavior: TestResource) ifTrue: [ ^false ].	^ true! !!PjExporter methodsFor: 'test support'!javascriptCode	^ String streamContents: [: aStream | self writeJsCodeOn: aStream]! !!PjExporter methodsFor: 'writing low-level'!jsStream: aStream do: aBlock	| savedStream |	savedStream := jsStream.	jsStream := aStream.	[		aBlock value	] ensure: [ jsStream := savedStream ]! !!PjExporter methodsFor: 'accessing'!launchBlock	^ launchBlock ifNil: [ self appClass appLaunchBlock ]! !!PjExporter methodsFor: 'accessing'!launchBlock: aBlock	launchBlock := aBlock! !!PjExporter methodsFor: 'writing low-level'!nextPut: aCharacter	jsStream nextPut: aCharacter! !!PjExporter methodsFor: 'writing low-level'!nextPutAll: aString	jsStream nextPutAll: aString! !!PjExporter methodsFor: 'writing'!nonBootstrapClasses	| actualBootstrapClasses |	actualBootstrapClasses := self bootstrapClasses asSet collect: #classToUseForJsConversion.	^self classes reject: [ :setClass | 			actualBootstrapClasses includes: setClass classToUseForJsConversion]! !!PjExporter methodsFor: 'writing'!pharoJsSelectorPrefix	^ self transpiler pharoJsSelectorPrefix! !!PjExporter methodsFor: 'initialize-release'!setUpForPolyfill	self transpiler beforeCodeOutputHook: [: pools | self writeGlobalsPolyfills: pools]! !!PjExporter methodsFor: 'accessing'!setupCode	^ self appClass setupCode! !!PjExporter methodsFor: 'writing'!space	jsStream space! !!PjExporter methodsFor: 'accessing'!transpiler	^ transpiler! !!PjExporter methodsFor: 'accessing'!transpiler: aTranspiler	transpiler := aTranspiler.	transpiler onStream: self! !!PjExporter methodsFor: 'accessing'!transpilerClass	^ self class transpilerClass! !!PjExporter methodsFor: 'writing core'!writeCore	self writeCoreObject.	self writeCoreClass.	self transpiler		writeNameForClass: PjCore;		<< '.theClassClass=';		writeNameForClass: PjClass;		<< $;;		cr;		writeNameForClass: PjCore;		<< $.;		<< transpiler pharoJsSelectorPrefix;		<< 'initializeCore();';		cr! !!PjExporter methodsFor: 'writing core'!writeCoreClass	self transpiler		convertMethodAsts: PjClass newClasses: Set new;		writeClassDefinitionOf: PjClass! !!PjExporter methodsFor: 'writing core'!writeCoreObject	self writeCoreObjectCreation.	self writeCoreObjectBasicMethods.	self transpiler		convertMethodAsts: PjCore newClasses: Set new;		writeClassDefinitionOf: PjCore! !!PjExporter methodsFor: 'writing core'!writeCoreObjectBasicMethods	self		writeCoreObjectCopyMethods;		writeFixMetaclassOfMethod;		writeFixInheritanceLinkOfMethod;		writeCoreObjectInstallClassMethod;		writeCoreObjectInstallClassExtensionMethod;		writeCoreObjectInstallAliasesMethods! !!PjExporter methodsFor: 'writing core'!writeCoreObjectCopyMethods	self transpiler		cr;		writeNameForClass: PjCore;		<< $.;		<< self copyMethodsSelector;		<< '=function(source,target){    let propertyNames = Object.getOwnPropertyNames(source).filter((each)=>			/\b';		<< self pharoJsSelectorPrefix;		<< '/.test(each)	  );     propertyNames.forEach('.	self writePropertyDefinitionFunctionFrom: 'source' to: 'target'.	self transpiler		<< ');}';		cr! !!PjExporter methodsFor: 'writing core'!writeCoreObjectCreation	self transpiler		<< 'global.';		writeNameForClass: PjCore;		<< '=global.';		writeNameForClass: PjCore;		<< '??class extends Object{};'! !!PjExporter methodsFor: 'writing core'!writeCoreObjectInstallAliasesMethods	| coreClassName |	coreClassName := PjCore instanceSide nameToUseForJsConversion.	self transpiler		<< coreClassName;		<<			'.installSelectorAliases=function(aliases, selector, target){		aliases.forEach('.	self		writePropertyDefinitionFunctionFrom: 'target'		at: 'selector'		to: 'target'.	self transpiler		<< ');	}';		cr;		<< coreClassName;		<< '.installAliasesFromDict=function(aliasesDict, target){		for(let key of Object.getOwnPropertyNames(aliasesDict)){';		<< coreClassName;		<< '.installSelectorAliases(aliasesDict[key], key, target);	}}';		cr;		<< coreClassName;		<< $.;		<< self installAllAliasesSelector;		<<			'=function(instanceSideAliasesDict, classSideAliasesDict, targetClass){';		cr;		<< coreClassName;		<<			'.installAliasesFromDict(instanceSideAliasesDict, targetClass.prototype);';		cr;		<< coreClassName;		<< '.installAliasesFromDict(classSideAliasesDict, targetClass);	}';		cr! !!PjExporter methodsFor: 'writing core'!writeCoreObjectInstallClassExtensionMethod	self transpiler		writeNameForClass: PjCore;		<< $.;		<< self installJsClassPlaceholderSelector;		<<			'=function(extensionClass,targetClass,instanceSideAliasesDict,classSideAliasesDict){';		crtab;		<< 'this.';		<< self copyMethodsSelector;		<< '(extensionClass.prototype, targetClass.prototype);';		crtab;		<< 'this.';		<< self copyMethodsSelector;		<< '(extensionClass, targetClass);';		crtab;		<< 'targetClass.';		writeClassVarsPoolName;		<< '=';		<< 'targetClass.';		writeClassVarsPoolName;		<< '??{};';		crtab;		<< 'Object.assign(targetClass.';		writeClassVarsPoolName;		<< ', extensionClass.';		writeClassVarsPoolName;		<< ');';		crtab;		<< 'this.';		<< self installAllAliasesSelector;		<<			'(instanceSideAliasesDict, classSideAliasesDict, targetClass);';		crtab;		<< 'this.';		<< self fixMetaclassOfSelector;		<< '(targetClass);';		crtab;		<< 'this.';		<< self fixInheritanceLinkOfSelector;		<< '(targetClass);';		crtab;		<< 'this[targetClass.name]=targetClass;';		crtab;		<< 'global[targetClass.name]=targetClass;';		cr;		<< $};		cr! !!PjExporter methodsFor: 'writing core'!writeCoreObjectInstallClassMethod	self transpiler		writeNameForClass: PjCore;		<< $.;		<< self installClassSelector;		<<			'=function(newClass,instanceSideAliasesDict,classSideAliasesDict){';		crtab;		<< 'this.';		<< self installAllAliasesSelector;		<<			'(instanceSideAliasesDict, classSideAliasesDict, newClass, newClass);';		crtab;		<< 'this.';		<< self fixMetaclassOfSelector;		<< '(newClass);';		crtab;		<< 'this.';		<< self fixInheritanceLinkOfSelector;		<< '(newClass);';		crtab;		<< 'this[newClass.name]=newClass;';		crtab;		<< 'global[newClass.name]=newClass;';		cr;		<< $};		cr! !!PjExporter methodsFor: 'writing core'!writeFixInheritanceLinkOfMethod	self transpiler		writeNameForClass: PjCore;		<< $.;		<< self fixInheritanceLinkOfSelector;		<< $=;		<< self fixInheritanceLinkOfMethodDefinition;		<< $; ;		cr! !!PjExporter methodsFor: 'writing core'!writeFixMetaclassOfMethod	self transpiler		writeNameForClass: PjCore;		<< $.;		<< self fixMetaclassOfSelector;		<< $=;		<< self fixMetaclassOfMethodDefinition;		<< $; ;		cr! !!PjExporter methodsFor: 'writing'!writeGlobalsPolyfills: pools	pools do: [ :pool | 		self appClass			polyfill: pool			withTranspiler: self transpiler			unlessIn: globalsPools ]! !!PjExporter methodsFor: 'writing'!writeJsCode	self appClass beforeExportApp.	self writeJsCoreAndBootstrap.	self writeNonBootstrapClasses.	self writeLaunchCode.	self appClass afterExportApp! !!PjExporter methodsFor: 'writing'!writeJsCodeOn: aStream	self jsStream: aStream do: [ self writeJsCode ]! !!PjExporter methodsFor: 'writing'!writeJsCoreAndBootstrap	self nextPutAll: self setupCode; cr.	self writeCore.	self transpiler convertAllClasses: self bootstrapClasses writeDnu: false! !!PjExporter methodsFor: 'writing'!writeLaunchCode	self transpiler convertAndWriteClosedBlock: self launchBlock! !!PjExporter methodsFor: 'writing'!writeNonBootstrapClasses	self transpiler		convertAllClasses: self nonBootstrapClasses		writeDnu: true! !!PjExporter methodsFor: 'writing core'!writePropertyDefinitionFunctionFrom: sourceString at: sourceSelector to: targetString	self		writePropertyDefinitionFunctionFrom: sourceString		at: sourceSelector 		to: targetString		at: 'name'! !!PjExporter methodsFor: 'writing core'!writePropertyDefinitionFunctionFrom: sourceString at: sourceSelector to: targetString at: targetSelector	self transpiler		<< '(';		<< targetSelector;		<< ')=>Object.defineProperty(';		<< targetString;		<< ',';		<< targetSelector;		<< ',{value:';		<< sourceString;		<< '[';		<< sourceSelector;		<< '],configurable:true})'! !!PjExporter methodsFor: 'writing core'!writePropertyDefinitionFunctionFrom: sourceString to: targetString	self writePropertyDefinitionFunctionFrom: sourceString at: 'name' to: targetString at: 'name'! !!PjFileExporter class methodsFor: 'exporting'!exportApp: aClass	^ (self newWithAppClass: aClass) writeFiles! !!PjFileExporter methodsFor: 'files'!createFileNamed: someFileName startingWith: beginning and: string ifEditableDo: aBlock	| fileReference |	fileReference := self fileReferenceFrom: someFileName.	fileReference exists ifTrue: [ 		self delete: fileReference ifMatches: string ].	self		writeInto: fileReference		match: string		startingWith: beginning		do: aBlock! !!PjFileExporter methodsFor: 'files'!delete: fileReference ifMatches: string	| fileStream first100 match |	fileReference exists ifFalse: [ ^ self ].	fileStream := fileReference openForRead.	first100 := fileStream next: 100 into: (String new: 100).	fileStream close.	match := self matchFrom: string.	(first100 = '' or: [ 		 (first100 findString: match startingAt: 1 caseSensitive: true) > 0 ]) 		ifTrue: [ ^ self ].	Error signal:		fileReference pathString , ' exists and does not contain "' , string		, '" in the first 100 bytes'! !!PjFileExporter methodsFor: 'files'!fileName	^ self appClass appFullJsFileName! !!PjFileExporter methodsFor: 'files'!fileReferenceFrom: someFileName	^ someFileName asFileReference! !!PjFileExporter methodsFor: 'files'!matchFrom: string	^ string , ' *** DO NOT EDIT ***'! !!PjFileExporter methodsFor: 'files'!writeFiles	self writeJavascriptFileNamed: self fileName! !!PjFileExporter methodsFor: 'files'!writeInto: fileReference match: string startingWith: beginning  do: aBlock	| fileStream |	fileStream := fileReference writeStream.	self		jsStream: fileStream		do: [ beginning				ifNotNil: [ self						nextPutAll: beginning;						cr ].			self				nextPutAll: (self matchFrom: string);				nextPutAll: ' on ';				nextPutAll: DateAndTime now asString.			OSPlatform current environment at: 'LOGNAME' ifPresent: [: name |				self nextPutAll: ' by ';nextPutAll: name			] ifAbsent: [				OSPlatform current environment at: 'USER' ifPresent: [: name |					self nextPutAll: ' by ';nextPutAll: name				] ifAbsent: [					OSPlatform current environment at: 'USERNAME' ifPresent: [: name |						self nextPutAll: ' by ';nextPutAll: name]]].			self cr.			self nextPutAll: '''use strict'';';cr.			aBlock value: fileStream ].	fileStream close! !!PjFileExporter methodsFor: 'files'!writeJavascriptFileNamed: aFileName	"Delete file first, because Windows can't open it for writing later when the file is open."		aFileName ifNotNil: [aFileName resolve deleteIfAbsent: [ ]].	self		createFileNamed: aFileName		startingWith: self headerLine		and: '// generated by PharoJS'		ifEditableDo: [ :fileStream | self writeJsCodeOn: fileStream]! !!PjTestFileExporter methodsFor: 'accessing'!contents	^ self writeStream contents! !!PjTestFileExporter methodsFor: 'testing'!exists	^false! !!PjTestFileExporter methodsFor: 'files'!fileName	^ nil! !!PjTestFileExporter methodsFor: 'accessing'!fileReferenceFrom: someFileName	^ self! !!PjTestFileExporter methodsFor: 'accessing'!writeStream	^ writeStream ifNil: [ writeStream := WriteStream with: '' ]! !!PjApplication class methodsFor: '*PharoJs-Base-Exporter-App'!afterExportApp	<pharoJsSkip>	self inform: 'DONE exporting JS code for ' , self name! !!PjApplication class methodsFor: '*PharoJs-Base-Exporter-App'!appFolder	<pharoJsSkip>		appFolder ifNil: [ 		appFolder := [ self defaultAppFolder ]			             on: Exception			             do: [ nil ] ].	self ifInvalidFolder: appFolder do: [ self setUpAppFolder ].	^ appFolder! !!PjApplication class methodsFor: '*PharoJs-Base-Exporter-App'!appFolder: anObject	<pharoJsSkip>		appFolder := anObject! !!PjApplication class methodsFor: '*PharoJs-Base-Exporter-App'!appFullJsFileName	<pharoJsSkip>		^ self appFullJsFolderPath / self appJsFileName! !!PjApplication class methodsFor: '*PharoJs-Base-Exporter-App'!appFullJsFolderPath	<pharoJsSkip>		self appJsSubFolder ifNotNil: [: subfolder|		^self appFolder / subfolder 	].	^self appFolder! !!PjApplication class methodsFor: '*PharoJs-Base-Exporter-App'!appJsFileName	<pharoJsSkip>		^ 'index.js'! !!PjApplication class methodsFor: '*PharoJs-Base-Exporter-App'!appJsSubFolder	<pharoJsSkip>	"Subclass might return, e.g. 'js' if you want the javascript to be in the js sub-directory. 	Useful, when you need to access the app/project folder that is different from the JS folder as with PhoneGap."		^ nil! !!PjApplication class methodsFor: '*PharoJs-Base-Exporter-App'!beforeExportApp	<pharoJsSkip>	^self! !!PjApplication class methodsFor: '*PharoJs-Base-Exporter-App'!defaultAppFolder	<pharoJsSkip>	| defaultAppFolder |	defaultAppFolder := self defaultAppFolderPath.	defaultAppFolder ensureCreateDirectory.	^ defaultAppFolder! !!PjApplication class methodsFor: '*PharoJs-Base-Exporter-App'!defaultAppFolderName	<pharoJsSkip>		^ self name! !!PjApplication class methodsFor: '*PharoJs-Base-Exporter'!defaultAppFolderParent	<pharoJsSkip>		^ self repositoryPath / self defaultAppFolderParentName / self package name! !!PjApplication class methodsFor: '*PharoJs-Base-Exporter'!defaultAppFolderParentName	<pharoJsSkip>		^'HTML'! !!PjApplication class methodsFor: '*PharoJs-Base-Exporter-App'!defaultAppFolderPath	<pharoJsSkip>	^ self defaultAppFolderParent / self defaultAppFolderName! !!PjApplication class methodsFor: '*PharoJs-Base-Exporter-App'!exportApp	<pharoJsSkip>	self exporterClass exportApp: self appClass.! !!PjApplication class methodsFor: '*PharoJs-Base-Exporter-App'!exportApp: version	<pharoJsSkip>		exportVersion := version.	self exportApp! !!PjApplication class methodsFor: '*PharoJs-Base-Exporter-App'!exportVersion	<pharoJsSkip>		self error: 'Override this in your application with the code:exportVersion	<jsLiteralGenerator>	^ exportVersion'! !!PjApplication class methodsFor: '*PharoJs-Base-Exporter-App'!exporterClass	<pharoJsSkip>		^ PjFileExporter! !!PjApplication class methodsFor: '*PharoJs-Base-Exporter-App'!globalsPools	<pharoJsSkip>		^ self allSharedPoolsRecursive select: #isJavascriptGlobalsPool! !!PjApplication class methodsFor: '*PharoJs-Base-Exporter-App'!ifInvalidFolder: folder do: aBlock	<pharoJsSkip>		(folder isNil or: [folder exists not]) ifTrue: aBlock! !!PjApplication class methodsFor: '*PharoJs-Base-Exporter-App'!polyfill: aPolyfillClass withTranspiler: aTranspiler unlessIn: aSet	<pharoJsSkip>		(aSet includes: aPolyfillClass) ifFalse: [		aSet add: aPolyfillClass.		aPolyfillClass requiredPolyfills do: [ : pool |			self polyfill: pool withTranspiler: aTranspiler unlessIn: aSet		].		^ true	].	^ false! !!PjApplication class methodsFor: '*PharoJs-Base-Exporter'!repository	<pharoJsSkip>		| packageName |	packageName := self package name.	^IceRepository registry  detect: [: repo | repo includesPackageNamed: packageName].! !!PjApplication class methodsFor: '*PharoJs-Base-Exporter'!repositoryPath	<pharoJsSkip>		^self repository location! !!PjApplication class methodsFor: '*PharoJs-Base-Exporter'!resetAppFolder	<pharoJsSkip>	self appFolder: nil! !!PjApplication class methodsFor: '*PharoJs-Base-Exporter-App'!setUpAppFolder	<pharoJsSkip>		| folder |	folder := UIManager default chooseDirectory: self setUpAppFolderPrompt.	self ifInvalidFolder: folder do: [  		^self error: 'PharoJS: Invalid folder for app ', self name].	self appFolder: folder.! !!PjApplication class methodsFor: '*PharoJs-Base-Exporter-App'!setUpAppFolderPrompt	<pharoJsSkip>	^ 'PharoJS: Folder for app ' , self name , ' please?'! !!PjExpressApp class methodsFor: '*PharoJs-Base-Exporter'!afterExportApp	<pharoJsSkip>	super afterExportApp.	self clientAppClasses do: #exportApp! !!PjExpressApp class methodsFor: '*PharoJs-Base-Exporter'!clientAppClasses	<pharoJsSkip>	^ #(  ) ! !!ManifestPharoJsBaseExporter class methodsFor: 'code-critics'!ruleGRGuradGuardClauseRuleV1FalsePositive	^ #(#(#(#RGMethodDefinition #(#PjDependentTranspiler #addClassToConvert: #false)) #'2020-02-14T08:19:48.428313-05:00') )! !!ManifestPharoJsBaseExporter class methodsFor: 'code-critics'!ruleRBGuardingClauseRuleV1FalsePositive	^ #(#(#(#RGMethodDefinition #(#PjDependentTranspiler #addClassToConvert: #false)) #'2020-02-14T08:19:35.789312-05:00') )! !!ManifestPharoJsBaseExporter class methodsFor: 'code-critics'!ruleRBLongMethodsRuleV1FalsePositive	^ #(#(#(#RGMethodDefinition #(#PjFileExporter #createFileNamed:startingWith:and:ifEditableDo: #false)) #'2020-03-24T09:25:20.198093-04:00') )! !!PjDependentTranspiler class methodsFor: 'accessing'!lineEnding	^Character lf! !!PjDependentTranspiler methodsFor: 'accessing'!addAlreadyDefinedClasses: classes	alreadyDefinedClasses addAll: classes! !!PjDependentTranspiler methodsFor: 'transpiling'!addClassToConvert: aClass	| addClass |	aClass javascriptIsExportableClass ifFalse: [ 		^ converter transpilationError:			  'non-exportable class ' , aClass name , ' referenced' ].	addClass := aClass classToUseForJsConversion.	(classesToConvert includes: addClass) ifFalse: [ " redundant test allows setting breakpoint for adding classes "		addClass == PjTranspiler ifTrue: [ self halt ].		addClass == Random ifTrue: [ self halt ].		classesToConvert add: addClass ]! !!PjDependentTranspiler methodsFor: 'transpiling'!addClassesToConvert: classes	classes do: [ :aClass | self addClassToConvert: aClass ]! !!PjDependentTranspiler methodsFor: 'loading'!alreadyConvertedClasses: classes	convertedClasses addAll: classes! !!PjDependentTranspiler methodsFor: 'accessing'!beforeCodeOutputHook: aBlock	super beforeCodeOutputHook: [ aBlock value: globalPools ]! !!PjDependentTranspiler methodsFor: 'transpiling'!convertAllClasses: classes	| newClasses |	self		addClassesToConvert: (classes select: #javascriptIsExportableClass).	newClasses := OrderedCollection new.	[ classesToConvert isEmpty ]		whileFalse: [ | theseClasses |			theseClasses := classesToConvert.			classesToConvert := Set new.			theseClasses				do:					[ :aClass | self convertMethodAsts: aClass instanceSide newClasses: newClasses ] ].	super convertAllClasses: newClasses! !!PjDependentTranspiler methodsFor: 'transpiling'!convertAndWriteClosedBlock: valuedBlock	self convertAndWriteClosedBlock: valuedBlock with: [		self convertAllClasses: #() writeDnu: self shouldWriteDnu	]! !!PjDependentTranspiler methodsFor: 'transpiling'!convertClass: aClass	self convertAllClasses: { aClass } writeDnu: self shouldWriteDnu! !!PjDependentTranspiler methodsFor: 'transpiling'!convertMethodAst: aMethod	(self shouldSkipMethodNode: aMethod) ifTrue: [ ^self ].	^convertedMethods at: aMethod ifAbsentPut: [		converter			classForConversion: aMethod methodClass classToUseForJsConversion;			convertAst: aMethod ast withPrimitive: aMethod primitive]! !!PjDependentTranspiler methodsFor: 'transpiling'!convertMethodAsts: aClass newClasses: newClasses	(convertedClasses includes: aClass)		ifFalse: [ aClass superclass				ifNotNil: [ self addClassToConvert: aClass superclass ].			self				addClassesToConvert: (aClass instanceSide sharedPools reject: #isJavascriptGlobalsPool).			convertedClasses add: aClass.			newClasses add: aClass ].	self		withMethodsOf: aClass		do: [ :aMethod | self convertMethodAst: aMethod ].	self		withMethodsOf: aClass class		do: [ :aMethod | self convertMethodAst: aMethod ]! !!PjDependentTranspiler methodsFor: 'loading'!discoveredGlobalsPool: aClass	globalPools add: aClass! !!PjDependentTranspiler methodsFor: 'loading'!discoveredReferenceToClass: aClass	^ self addClassToConvert: aClass! !!PjDependentTranspiler methodsFor: 'transpiling'!generateCodeStringFrom: jsAst	self convertAllClasses: classesToConvert.	super generateCodeStringFrom: jsAst! !!PjDependentTranspiler methodsFor: 'transpiling'!importMethodsAll: aCollection forClass: aClass	| importMethods |	importMethods := Dictionary new.	aCollection		do: [ :aSymbol | 			(aClass instanceSide hasClassMethod: aSymbol)				ifTrue: [ (aClass instanceSide perform: aSymbol)						associationsDo: [ :assoc | 							importMethods								at: assoc key								ifPresent: [ :im | im value addAll: assoc value ]								ifAbsent: [ importMethods at: assoc key put: assoc value asSet ] ] ] ].	^ importMethods! !!PjDependentTranspiler methodsFor: 'initialization'!initialize	super initialize.	convertedMethods := IdentityDictionary new.	classesToConvert := Set new.	convertedClasses := Set new.	alreadyDefinedClasses := Set new.	alreadyInitializedClasses := Set new.	alreadyVariablesDeclaredClasses := Set new.	globalPools := Set new.! !!PjDependentTranspiler methodsFor: 'invalidating'!invalidateClass: aClass	convertedClasses remove: aClass ifAbsent: [  ].	alreadyDefinedClasses remove: aClass ifAbsent: [  ].	self invalidateMethods:		aClass classToUseForJsConversion instanceSide methods.	self invalidateMethods:		aClass classToUseForJsConversion classSide methods! !!PjDependentTranspiler methodsFor: 'invalidating'!invalidateMethod: aMethod	convertedMethods removeKey: aMethod ifAbsent: [].! !!PjDependentTranspiler methodsFor: 'invalidating'!invalidateMethods: aCollection	aCollection do: [ : method | self invalidateMethod: method ]! !!PjDependentTranspiler methodsFor: 'statistics'!numberOfClasses	^ convertedClasses size! !!PjDependentTranspiler methodsFor: 'statistics'!numberOfMethods	^ convertedMethods size! !!PjDependentTranspiler methodsFor: 'transpiling'!transpileMethod: aMethod	| jsAst |	jsAst := self convertMethodAst: aMethod.	generator asString: jsAst on: self jsStream! !!PjDependentTranspiler methodsFor: 'transpiling'!withMethodsOf: aClass do: aBlock	| nonOverriddenSelectors importMethods methodsToOutput |	methodsToOutput := OrderedCollection new.	super withMethodsOf: aClass do: [: method | methodsToOutput add: method].	importMethods := self		importMethodsAll: #(jsTranspilationImportMethods jsTranspilationImportMethodsNonstandard)		forClass: aClass.	importMethods keysAndValuesDo: [ : class : selectors |		class isMeta = aClass isMeta ifTrue: [			nonOverriddenSelectors := selectors copyWithoutAll: aClass selectors.			nonOverriddenSelectors do: [ : aSymbol |				methodsToOutput add: (class compiledMethodAt: aSymbol) ]]].	methodsToOutput sort: [: l : r | l selector < r selector ].	methodsToOutput do: aBlock.! !!PjDependentTranspiler methodsFor: 'transpiling'!writeClassDefinitionOf: aClass	alreadyDefinedClasses addIfNotPresent: aClass ifPresentDo: [ ^ self ].	super writeClassDefinitionOf: aClass! !!PjDependentTranspiler methodsFor: 'transpiling'!writeClassInitializeOf: aClass	alreadyInitializedClasses addIfNotPresent: aClass ifPresentDo: [ ^ self ].	super writeClassInitializeOf: aClass! !!PjDependentTranspiler methodsFor: 'transpiling'!writeClassVariableDeclarationsOf: aClass	alreadyVariablesDeclaredClasses addIfNotPresent: aClass ifPresentDo: [ ^ self ].	super writeClassVariableDeclarationsOf: aClass! !!Class methodsFor: '*PharoJs-Base-Exporter-App'!allSharedPoolsRecursive	"Answer a set of the pools the receiver shares, including those defined  in the superclasses of the receiver."		^ self allSharedPoolsRecursiveInto: Set new! !!Class methodsFor: '*PharoJs-Base-Exporter-App'!allSharedPoolsRecursiveInto: aCollection	"Add to the collection all of the pools the receiver shares, including those defined  in the superclasses of the receiver."		self inheritedSharedPools do: [ : each |		(aCollection includes: each) ifFalse: [			aCollection add: each.			each allSharedPoolsRecursiveInto: aCollection		]	].	^ aCollection! !!Class methodsFor: '*PharoJs-Base-Exporter-App'!inheritedSharedPools	^ self allSharedPools! !!Class methodsFor: '*PharoJs-Base-Exporter'!javascriptIsExportableClass	^ true! !!Class methodsFor: '*PharoJs-Base-Exporter-App'!sharedPoolOfVarNamedRecursive: aString	"Returns the SharedPool or nil from which the pool variable named aString is coming from."		 ^ self allSharedPoolsRecursive 			detect: [:each | each usesClassVarNamed: aString ]			ifNone: [ nil ]! !!PjNodeApplication class methodsFor: '*PharoJs-Base-Exporter'!beforeExportApp	<pharoJsSkip>	super beforeExportApp.	self ensureRequiredModulesInstalled.! !!PjNodeApplication class methodsFor: '*PharoJs-Base-Exporter'!ensureRequiredModulesInstalled	<pharoJsSkip>	self modulesFolder exists ifTrue: [ ^ self ].	(self appFolder / 'package-lock.json') exists ifFalse: [ ^ self ].	self inform: 'Installing NPM modules for ' , self name.	LibC runCommand: self installNpmModulesCommandLine! !!PjNodeApplication class methodsFor: '*PharoJs-Base-Exporter'!installNpmModulesCommandLine	<pharoJsSkip>	^String streamContents: [ : str |		str << 		'cd';		space ; << self appFolder absolutePath pathString; << $; ;		<< 'npm install']! !!PjNodeApplication class methodsFor: '*PharoJs-Base-Exporter'!polyfill: aPolyfillClass withTranspiler: aTranspiler unlessIn: aSet	<pharoJsSkip>		^ (super polyfill: aPolyfillClass withTranspiler: aTranspiler unlessIn: aSet) and: [		aPolyfillClass nodePolyfill: aTranspiler.		true	]! !!PjWebApplication class methodsFor: '*PharoJs-Base-Exporter-App'!appHtmlUrlString	<pharoJsSkip>		^ 'file:' , self appFullHtmlFileName pathString asUrl asString! !!PjWebApplication class methodsFor: '*PharoJs-Base-Exporter'!polyfill: aPolyfillClass withTranspiler: aTranspiler unlessIn: aSet	<pharoJsSkip>		^ (super		   polyfill: aPolyfillClass		   withTranspiler: aTranspiler		   unlessIn: aSet) and: [ 		  aPolyfillClass browserPolyfill: aTranspiler.		  true ]! !!SharedPool class methodsFor: '*PharoJs-Base-Exporter-App'!inheritedSharedPools	^ self sharedPools! !!PjDOMApplication class methodsFor: '*PharoJs-Base-Exporter-App'!appFullHtmlFileName	<pharoJsSkip>		^self appFullHtmlFolderPath / self appHtmlFileName! !!PjDOMApplication class methodsFor: '*PharoJs-Base-Exporter-App'!appFullHtmlFolderPath	<pharoJsSkip>	self appHtmlSubFolder ifNotNil: [ :subfolder | 		^ self appFolder / subfolder ].	^ self appFolder! !!PjDOMApplication class methodsFor: '*PharoJs-Base-Exporter-App'!appFullJsFolderPath	<pharoJsSkip>		self appJsSubFolder ifNotNil: [ :subfolder | 		^ self appFullHtmlFolderPath / subfolder ].	^ self appFullHtmlFolderPath! !!PjDOMApplication class methodsFor: '*PharoJs-Base-Exporter-App'!appHtmlFileName	<pharoJsSkip>	^ 'index.html'! !!PjDOMApplication class methodsFor: '*PharoJs-Base-Exporter-App'!appHtmlSubFolder	<pharoJsSkip>	"Subclass might return, e.g. 'www' if you want the html to be in the www sub-directory. 	Useful, when you need to access the app/project folder that is different from the JS folder as with PhoneGap."	^ nil! !!PjDOMApplication class methodsFor: '*PharoJs-Base-Exporter'!polyfill: aPolyfillClass withTranspiler: aTranspiler unlessIn: aSet	<pharoJsSkip>	^ (super polyfill: aPolyfillClass withTranspiler: aTranspiler unlessIn: aSet) and: [		aPolyfillClass domPolyfill: aTranspiler.		true	]! !"PharoJs-Base-Exporter"!!PjTWebBridgeClient commentStamp: '' prior: 0!Utility trait to control the webbrowser!!PjBridge commentStamp: '' prior: 0!A PjBridge is the facade that allows interacting (i.e. evaluting code) with a javascript interpreter. Example: "1) Start a bridge in a workspace"bridge := PjBridge startOn: 12345 title: 'Example'."2) Open a web browser on http://localhost:12345""3) Perform in the workspace the following expressions one at a time. Use 'printIt' to display results. Watch the log on the web browser to see the  javascript code actually peformed."bridge eval: '1+2'.bridge eval: 'x := 6 * 7'.bridge eval: 'x - 5'.bridge loadClass: PjCounter.bridge eval: 'counter := PjCounter new.counter increment.counter increment.counter increment.counter count.'. "4) Once done, don't forget to stop the bridge"bridge stop.Instance Variables	clientClassName:		<String>	communicationTrialsCount:		<Integer>	converter:		<PjSmalltalkToJavaScriptConverer>	server:		<PjServer>clientClassName	- Name of the class of the socket wrapper running on the JavaScript client (e.g. PjEvaluatorWebSocketDelegate)communicationTrialsCount	- Number of attempts to send/receive data through the webSocketconverter	- Smalltalk to JavaScript converter. Used to translate Smalltalk code to JavaScript before evaluating it on the client (see #eval: and #loadClass:)server	- Manages client connections including the websocket!!PjBridgeClient commentStamp: '' prior: 0!I represent a bridge client i.e. javascript interpreter and code that talks to a bridge.!!PjBrowserBridgeClient commentStamp: '' prior: 0!I represent a web bridge client i.e. an interactive interpreter is launched upon start!!PjFileBasedBridgeClient commentStamp: '' prior: 0!I am the super class for bridge clients that need to write out the javascript file.  This includes NodeJS apps and browsers that have more resources than the CSS and HTML files.!!PjFileBasedBrowserBridgeClient commentStamp: '' prior: 0!I am for browsers that have more resources than the CSS and HTML files that need to be loaded.!!PjNodeBridgeClient commentStamp: '' prior: 0!I am the bridge client for applications to run on NodeJS!!PjNullBridgeClient commentStamp: '' prior: 0!I represent a null bridge client i.e. no interpreter is actually launched upon start!!PjClientCodeGenerator commentStamp: '' prior: 0!A PjClientCodeGenerator generates the HTML that includes javascript code made available through the server to the client (typically on the browser).Instance Variables	converter:		<PjSmalltalkToJavaScriptBasicConverer>converter	- translates Smalltalk code into JavaScript!!PjLoggingClientCodeGenerator commentStamp: '' prior: 0!A PjLoggingClientCodeGenerator is a generator for HTML/Javascript client code that logs websocket activity on the HTML page.!!PjHtmlGenerator commentStamp: '' prior: 0!A PjHtmlGenerator is a facility to build a html pages (strings).Instance Variables	bodyStream:		<WriteStream on String>	headerStream:		<WriteStream on String>	scriptsStream:		<WriteStream on String>bodyStream	- Dedicated to the content of the bodyheaderStream	- Dedicated to the content of the headerscriptsStream	- Dedicated to JavaScript scripts. They are typically inserted at the end of the resulting HTML page (a string)!!PjParametrizableServerDelegate commentStamp: '' prior: 0!A PjParametrizableServerDelegate is a delegate for the server that simply stores a HTML page that is sent as a response to any client request.Instance Variables	html:		<String>html	- HTML page sent to clients!!PjProxy commentStamp: '' prior: 0!I am PjBrowserProxy and I provide a Pharo-side proxy for browser-side Javascript objects.I provide access to Javascript and DOM objects on the browser.Messages sent to my instances will evaluate on the browser allowing creation and manipulation of Javascript and DOM objects.This allows development and debugging of programs on Pharo (using the browser as the UI) for subsequent deployment on the browser.I should become a subclass of ProtoObject, but there are things to be done first, such as implement isNil, the ifNil:s, class, inspect, Nautilus support methods, etc.  In the meantime, if there is a method that should go to the browser, define it like #confirm:My class has a reference to a PjBrowserBridge which has a connection to the browser so that I can execute code on the browser.Example: 1) highlight and do: " PjProxy startOn: 12345 "2) now in a browser open localhost:123453) in a Playground, you can now access "window", "document" (but you cannot do it in the same playground as the startOn:)4) When you are finished do: " PjProxy stop "Public API and Key Messages- startOn: - class method to create a port for connection from a browser - stop - class method to end the connectionThe values window and document are pre-defined PjBrowserProxy  objects.Any message sent to a PjBrowserProxy object will execute on the browser and return a Smalltalk value - either a primitive value or a PjBrowserProxy object.  Internal Representation and Key Implementation Points.    Class Variables	bridge:		<PjBrowserBridge> - connection to the browser    Instance Variables	jsName:		<String> - browser-side name of the value    Implementation Points- finalization of the Smalltalk object deletes the cached value on the browser!!PjProxyForGlobal commentStamp: '' prior: 0!I am a proxy for a Javascript named global, such as document, Math, console!!PjProxyFinalizationHandler commentStamp: '' prior: 0!I am the finilizer for temporary proxy values so they can be removed from the Javascript engine side when no longer referenced by the Pharo side!!PjSinkObject commentStamp: '' prior: 0!A PjSinkObject is an object that accepts any message. The response is always itself. This is usefull as a placeholder of missing objects, such as javascript globals. It allows partially testing code that relies on Javascript libraries. !!ManifestPharoJsBaseBridge commentStamp: '' prior: 0!Please describe the package using the class comment of the included manifest class. The manifest class also includes other additional metadata for the package. These meta data are used by other tools such as the SmalllintManifestChecker and the critics Browser!!PjSocketLogEvent commentStamp: '' prior: 0!I am a log event subclassed from ZnLogEvent that is used to log webSocket I/OI am usually used at an extended loglevel of 4!!PjProxyLocalBridge commentStamp: '' prior: 0!I am a ProcessLocalVariable that contains the PjBridge in use by this process.This allows us to simultaneously debug multiple applications (for example a client and a server.)This is used by PjProxy.!!PjProxyManager commentStamp: '' prior: 0!Utility class to managed proxies!!PjWebsocketDelegate commentStamp: '' prior: 0!A PjWebSocketDelegate is a wrapper for a JavaScript websocket. It provides entry points for subclasses to perform some actions during the websocket lifecycle In production, the code of this class is translated to javascript and run on the client side.Instance Variables	webSocket:		<JavaScript WebSocket>webSocket	- WebSocket created at the JavaScript client side!!PjEvaluatorWebsocketDelegate commentStamp: '' prior: 0!A PjEvaluatorWebSocketDelegate is a wrapper for websocket that evaluates received JavaScript code (see onMessage: ). It allows the bridge to control the client (see PjBridge>>#eval:).In production, the code of this class is translated to javascript and run on the client side.!!PjLoggingEvaluatorWebsocketDelegate commentStamp: '' prior: 0!A PjLoggingEvaluatorWebSocketDelegate is websocket wrapper that logs the web socket activity. It is run on the client side typically for debug and test purpose.In production, the code of this class is translated to javascript and run on the client side.Instance Variables	logElementId:		<String>logElementId	- ID of the element in which logs are written!!PjJavascriptError commentStamp: '' prior: 0!A PjJavaScriptError is an exception raised when the execution at the JavaScript side leads to an exception.!!PjServer commentStamp: '' prior: 0!A PjServer is a server that manages a websocket used by the bridge to run/control javascript code on the clientInstance Variables	timing:		<Object>	webSocket:		<ZnWebSocket>!!PjSTONReader commentStamp: '' prior: 0!I extend STONReader to include Infinity -Infinity and NaN!!PjJavascriptMessage commentStamp: '' prior: 0!I represent a message to be evaluated on the Javascript side.I extend the standard Message class, with a receiver.The transpiler converts me to Javascript in a special way.!!PjTWebBridgeClient methodsFor: 'actions'!openBrowserInBackground	^ openBrowserInBackground ifNil: [ false ]! !!PjTWebBridgeClient methodsFor: 'actions'!openBrowserInBackground: aBoolean	openBrowserInBackground := aBoolean! !!PjTWebBridgeClient methodsFor: 'actions'!openWebBrowserOn: urlString	WebBrowser		openOn: urlString 		inBackground: self openBrowserInBackground! !!PjTWebBridgeClient methodsFor: 'initialization'!reset	self sendMessage: PjMessageReload new.	self resetProxiesImmediately.	super reset! !!PjTWebBridgeClient methodsFor: 'actions'!sendMessage: aMessage	self bridge sendMessage: aMessage! !!PjTWebBridgeClient methodsFor: 'actions'!startJsInterpreter	WebBrowser		openOn: self urlString		inBackground: self openBrowserInBackground! !!PjTWebBridgeClient methodsFor: 'accessing'!urlString	self explicitRequirement! !!Object methodsFor: '*PharoJs-Base-Bridge'!asLocalObject	^ self! !!PjBridge class methodsFor: 'instance creation'!bridgeForAppClass: appClass	^ self bridgeForAppClass: appClass client: appClass newBridgeClient! !!PjBridge class methodsFor: 'instance creation'!bridgeForAppClass: appClass client: bridgeClient	^ self new		  initializeWithClient: bridgeClient;		  initializeWithAppClass: appClass;		  yourself! !!PjBridge class methodsFor: 'accessing'!debugClass	^ self! !!PjBridge class methodsFor: 'accessing'!defaultApp	^ PjWebApplication! !!PjBridge class methodsFor: 'accessing'!defaultClientClass	^ self defaultApp bridgeClientClass! !!PjBridge class methodsFor: 'instance creation'!openOn: portNumber title: title	^ self new		  openOn: portNumber title: title;		  yourself! !!PjBridge class methodsFor: 'bridge handling'!soleBridge	^ PjProxyLocalBridge value	" the following is a hack to make debugging workable if there is only 1 bridge in existence "		ifNil: [ | instances |			instances := self allInstances select: #isServerStarted.			instances size = 1 ifTrue: [ instances first ] ifFalse: [ nil ]		]! !!PjBridge class methodsFor: 'bridge handling'!soleBridge: aBridge	PjProxyLocalBridge value: aBridge! !!PjBridge class methodsFor: 'instance creation'!startOn: portNumber title: title	^ (self bridgeForAppClass: self defaultApp)		  startOn: portNumber title: title;		  yourself! !!PjBridge class methodsFor: 'bridge handling'!stop	<script>		self soleBridge ifNotNil: [ 		self soleBridge stop.		self soleBridge: nil.		Smalltalk garbageCollect ]! !!PjBridge methodsFor: 'actions'!acceptIncomingMessageFromClient: aMessage	aMessage shouldEvaluateImmediately		ifTrue: [ aMessage processWithBridge: self.			monitor critical: [ monitor signal ].			^ self ].	monitor		critical: [ self incomingMessages add: aMessage.			monitor signal ]! !!PjBridge methodsFor: 'closure handling'!blockClosures	^ blockClosures ifNil: [ blockClosures := IdentityDictionary new ]! !!PjBridge methodsFor: 'accessing'!client	^ client! !!PjBridge methodsFor: 'initialization'!clientTitle	^ self client title! !!PjBridge methodsFor: 'public'!convertToJs: anObject	^ self exporter convertToJs: anObject! !!PjBridge methodsFor: 'accessing'!defaultClientClass	^ self class defaultClientClass! !!PjBridge methodsFor: 'closure handling'!deleteBlockClosure: aBlockClosure	self blockClosures removeKey: aBlockClosure ifAbsent: [  ]! !!PjBridge methodsFor: 'bridge handling'!deleteJsValue: jsName	"Called by proxy finalizer see methode PjProxy>>jsName:onBridge:"	<PjTodo: 'should use PjProxyInfo'>		self proxies removeKey: jsName ifAbsent: [  ].	self isServerStopped ifTrue: [ ^ self ].	self sendMessage: (PjMessageDeleteGlobalVar newForVarName: jsName).	^ proxies! !!PjBridge methodsFor: 'evaluating'!disableWriteDnuDuring: aBlockClosure	^ self transpiler disableWriteDnuDuring: aBlockClosure! !!PjBridge methodsFor: 'evaluating'!dnuJsString	^ self transpiler dnuJsString! !!PjBridge methodsFor: 'initialization'!doInNewFrame: aBlock	incomingMessageFrames add: OrderedCollection new.	aBlock value.	incomingMessageFrames removeLast! !!PjBridge methodsFor: 'public'!enableClientLogging	self initializeWithClient: self client withClientLogging! !!PjBridge methodsFor: 'closure handling'!ensureProxyForEventListenerBlock: aBlockClosure	^ self blockClosures		at: aBlockClosure		ifAbsentPut: [ | thisArg includeEventTarget msg proxy |			(aBlockClosure isKindOf: BlockClosure)				ifFalse: [ ^ PjJavascriptError signal: 'Must be a BlockClosure' ].			aBlockClosure hasMethodReturn				ifTrue: [ ^ PjJavascriptError signal: 'Block cannot have return' ].			thisArg := aBlockClosure argumentNames				findFirst: [ :name | name = 'this' ].			includeEventTarget := thisArg > 0.			msg := PjMessageMakeBlockClosureProxy newWithId.			msg includeEventTarget: includeEventTarget.			msg stopPropagation: true.			proxy := self sendMessageAndWaitForResponse: msg.			proxy closure: aBlockClosure.			proxy ]! !!PjBridge methodsFor: 'public'!evalBlock: aBlock	^ self evalJavascript: (self convertToJs: aBlock asValuedBlock)! !!PjBridge methodsFor: 'public'!evalJavascript: javaScriptString	| msg |	self isConnected ifFalse: [ ^ nil ].	msg := PjMessageEvaluateJavascript newWithContents: javaScriptString.	^ self sendMessageAndWaitForResponse: msg! !!PjBridge methodsFor: 'public'!evalJavascriptWithDnuFrom: aBlock	| jsBlockCode jsDnuCode |	jsBlockCode := self disableWriteDnuDuring: aBlock.	jsDnuCode := self dnuJsString.	^ self evalJavascript: jsDnuCode , jsBlockCode! !!PjBridge methodsFor: 'public'!evalMessage: jsMessage	^ self evalJavascriptWithDnuFrom: [ self convertToJs: jsMessage ]! !!PjBridge methodsFor: 'public'!evalMessage: aMessage sentTo: receiverJsID	^self evalSelector: aMessage selector sentTo: receiverJsID args: aMessage arguments! !!PjBridge methodsFor: 'public'!evalSelector: aSymbol sentTo: receiverJsID	^self evalSelector: aSymbol sentTo: receiverJsID args: #()! !!PjBridge methodsFor: 'public'!evalSelector: aSymbol sentTo: receiverJsID args: args	| jsMessage |	jsMessage := PjJavascriptMessage		             receiverId: receiverJsID		             selector: aSymbol		             arguments: args.	^ self evalMessage: jsMessage! !!PjBridge methodsFor: 'actions'!executeCallbacksUntilDepletion	[ 	self takeNextCallbackFromIncomingMessages		ifNil: [ ^ self ]		ifNotNil: [ :cb | 		self doInNewFrame: [ cb processCallbackWithBridge: self ] ] ] repeat! !!PjBridge methodsFor: 'accessing'!exporter	^ self client exporter! !!PjBridge methodsFor: 'accessing'!incomingMessages	^ incomingMessageFrames last! !!PjBridge methodsFor: 'evaluating'!incomingResponseMessageForSentMessage: aMsg	^ self incomingMessages		  detect: [ :msg | 		  msg inResponseToId = aMsg id and: [ msg isCallback not ] ]		  ifNone: [ nil ]! !!PjBridge methodsFor: 'initialization'!initialize	super initialize.	incomingMessageFrames := OrderedCollection with:		                         OrderedCollection new.	shouldStartJsInterpreter := true.	self server: self serverClass new.	self finalizationRegistry add: self executor: (ObjectFinalizer new			 receiver: self server;			 selector: #stop;			 yourself).	monitor := Monitor new! !!PjBridge methodsFor: 'accessing'!initializeWithAppClass: aPharoJsAppClass	self client initializeWithAppClass: aPharoJsAppClass.	self client initializeWithBridge: self! !!PjBridge methodsFor: 'accessing'!initializeWithClient: aClient	client := aClient.	client initializeWithBridge: self! !!PjBridge methodsFor: 'actions'!isClientIdReceived	^ self client clientId notNil! !!PjBridge methodsFor: 'public'!isConnected	self webSocket ifNil: [ ^ false ].	^ self webSocket isConnected! !!PjBridge methodsFor: 'public'!isListening	^ self server isListening! !!PjBridge methodsFor: 'public'!isServerStarted	^ self server ifNil: [ false ] ifNotNil: [ :s | s isStarted ]! !!PjBridge methodsFor: 'public'!isServerStopped	^ self server ifNil: [ true ] ifNotNil: [ self server isStarted not ]! !!PjBridge methodsFor: 'public'!jsGlobalAt: globalID	^ self evalJavascript: globalID! !!PjBridge methodsFor: 'public'!loadAllClasses: classes	| javaScriptClassesDefinition |	javaScriptClassesDefinition := self exporter convertAllClassesToJs:		                               classes.	self evalJavascript: javaScriptClassesDefinition.	^ classes! !!PjBridge methodsFor: 'public'!loadClass: aClass	self loadAllClasses: { aClass }.	^ aClass! !!PjBridge methodsFor: 'actions'!minimumStepDuration	^ 25 milliSeconds! !!PjBridge methodsFor: 'actions'!openOn: portNumber	self openOn: portNumber title: 'PharoJS'! !!PjBridge methodsFor: 'actions'!openOn: portNumber test: aTestCase	^ self openOn: portNumber title: (self titleForTest: aTestCase)! !!PjBridge methodsFor: 'actions'!openOn: portNumber title: title	| clientGenerator |	clientGenerator := self client codeGenerator.	title ifNotNil: [ clientGenerator titleString: title ].	self port: portNumber! !!PjBridge methodsFor: 'accessing'!port	^ self server port! !!PjBridge methodsFor: 'initialization'!port: portNumber	self server port: portNumber! !!PjBridge methodsFor: 'accessing'!proxies	^ proxies ifNil: [ proxies := WeakValueDictionary new ]! !!PjBridge methodsFor: 'public'!resetClient	| oldWebSocket |	oldWebSocket := self webSocket.	self client reset.	self		when: [ self webSocket ~~ oldWebSocket ]		do: [ oldWebSocket isConnected				ifTrue: [ oldWebSocket close ] ]		onTimeOutDo: [ self error: 'Client did NOT reconnect!!' ]		timeOutDuration: self client startTimeout.	self waitForClientToStart! !!PjBridge methodsFor: 'initialization'!resetProxiesImmediately	"Leaving this to garbage collection leads to inpredictable results,	because finalizations might occur in a next (reloaded) client JS session"	self proxies do: [ :v | 		(self finalizationRegistry remove: v ifAbsent: [ nil ]) ifNotNil: [ 			:finalizerItem | "finalizerItem finalizeValues""For now, NOT executing the finalizations (which sends delete proxy messages to the client), because of unknown problems.					This should be made synchronous anyway by waiting for acknowledgement from client.					For now, removing them (inactivating) is enough, we only execute this method when we no further need the client."			 ].		true ].	proxies := nil	"Smalltalk garbageCollect. "! !!PjBridge methodsFor: 'public'!restart	self		stop;		start! !!PjBridge methodsFor: 'actions'!sendMessage: aMessage	[ 	self webSocket ifNotNil: [ :ws | 		ws sendMessage: aMessage asPhxJsonString.		self server logSocketWritten: aMessage logDescription ] ]		on: Error		do: [ :ex | ex return ]! !!PjBridge methodsFor: 'public'!sendMessageAndWaitForResponse: msg	| responseMsg resultForSentMessage |	self sendMessage: msg.	monitor critical: [ 		monitor waitUntil: [ 			responseMsg := self incomingResponseMessageForSentMessage: msg.			responseMsg notNil ] ].	resultForSentMessage := self valueFromResponseMessage: responseMsg.	self executeCallbacksUntilDepletion.	^ resultForSentMessage! !!PjBridge methodsFor: 'accessing'!server	^ server! !!PjBridge methodsFor: 'accessing'!server: aServer	server := aServer.	aServer ifNotNil: [ aServer bridge: self ]! !!PjBridge methodsFor: 'accessing'!serverAddress	self shouldBeImplemented! !!PjBridge methodsFor: 'initialization'!serverClass	^ PjBridgeServer! !!PjBridge methodsFor: 'accessing'!serverUrl	^ self server url! !!PjBridge methodsFor: 'accessing'!serverUrl: aString	^ self server serverUrl: aString! !!PjBridge methodsFor: 'public'!setExtraBindings: aDictionary	^ self exporter setExtraBindings: aDictionary! !!PjBridge methodsFor: 'accessing'!shouldStartJsInterpreter	^ shouldStartJsInterpreter! !!PjBridge methodsFor: 'accessing'!shouldStartJsInterpreter: aBoolean	shouldStartJsInterpreter := aBoolean! !!PjBridge methodsFor: 'public'!start	self		startWithoutWaitingForClient;		waitForClientToStart! !!PjBridge methodsFor: 'public'!startJsInterpreter	self client startJsInterpreter.	self waitForClientToStart! !!PjBridge methodsFor: 'actions'!startOn: portNumber title: title	self		openOn: portNumber title: title;		start! !!PjBridge methodsFor: 'public'!startWithoutWaitingForClient	self server start.	self client start! !!PjBridge methodsFor: 'public'!stop	self client stop.	self server ifNotNil: [ self server stop ]! !!PjBridge methodsFor: 'actions'!takeNextCallbackFromIncomingMessages	self incomingMessages		detect: [ :msg | msg isCallback ]		ifFound: [ :cb | 			self incomingMessages remove: cb.			^ cb ]		ifNone: [ ^ nil ]! !!PjBridge methodsFor: 'public'!tearDown	self stop.	self server ifNotNil: [ 		self server tearDown.		self server: nil ]! !!PjBridge methodsFor: 'public'!terminateClient	self isConnected ifFalse: [ ^ self ].	self client stop.	self webSocket close! !!PjBridge methodsFor: 'evaluating'!timeout	^ timeout ifNil: [ 10 seconds ]! !!PjBridge methodsFor: 'evaluating'!timeout: aDuration	timeout := (aDuration isKindOf: Duration)		           ifTrue: [ aDuration ]		           ifFalse: [ aDuration seconds ]! !!PjBridge methodsFor: 'initialization'!titleForTest: aTest	^ aTest className , '>>#' , aTest selector! !!PjBridge methodsFor: 'accessing'!transpiler	^ self exporter transpiler! !!PjBridge methodsFor: 'actions'!valueFromResponseMessage: responseMsg	| result |	self incomingMessages remove: responseMsg.	result := responseMsg getValueWithBridge: self.	result := result isClosure		          ifTrue: [ result value ]		          ifFalse: [ result ].	^ result! !!PjBridge methodsFor: 'actions'!waitForClientToStart	self waitForClientToStartFor: self client startTimeout! !!PjBridge methodsFor: 'actions'!waitForClientToStartFor: time	monitor critical: [ 		monitor			waitUntil: [ self isClientIdReceived ]			maxMilliseconds: time asMilliSeconds ].	self isClientIdReceived ifFalse: [ 		self error: 'Javascript interpreter NOT available' ]! !!PjBridge methodsFor: 'actions'!waitForClientToStartFor: time doing: aBlock	self		when: [ 			aBlock value.			self isConnected ]		do: [ ^ self ]		onTimeOutDo: [ self error: 'Javascript interpreter NOT available' ]		timeOutDuration: time! !!PjBridge methodsFor: 'accessing'!webSocket	^ self server webSocket! !!PjBridge methodsFor: 'accessing'!webSocketUrlTag	^ self server webSocketUrlTag! !!PjBridge methodsFor: 'initialization'!websocketDelegateClass	^ self client websocketDelegateClass! !!PjBridge methodsFor: 'initialization'!websocketDelegateClassName	^ self client websocketDelegateClassName! !!PjBridge methodsFor: 'actions'!when: conditionBlock do: actionBlock onTimeOutDo: failureBlock timeOutDuration: maxWaitDuration	| waitTime |	waitTime := maxWaitDuration / 100.	waitTime < self minimumStepDuration ifTrue: [ 		waitTime := self minimumStepDuration ].	100 timesRepeat: [ 		conditionBlock value ifTrue: [ ^ actionBlock value ].		waitTime wait ].	^ failureBlock value! !!PjBridgeAppClassDecorator class methodsFor: 'instance creation'!rawAppClass: anAppClass	^ self new		  rawAppClass: anAppClass;		  yourself! !!PjBridgeAppClassDecorator class methodsFor: 'accessing'!websocketDelegateClass	^ PjEvaluatorWebsocketDelegate! !!PjBridgeAppClassDecorator methodsFor: 'exporting'!afterExportApp	rawAppClass afterExportApp! !!PjBridgeAppClassDecorator methodsFor: 'accessing'!appClasses	^ self rawAppClass appClasses , self classesForBridgeClient! !!PjBridgeAppClassDecorator methodsFor: 'accessing'!appLaunchBlock	| appClass webSocketDelegateClass url |	appClass := self rawAppClass.	webSocketDelegateClass := self websocketDelegateClass.	url := self bridgeWebSocketUrl.	^ [ 	  appClass start.	  webSocketDelegateClass connectDefaultToUrl: url ] asClosedBlock! !!PjBridgeAppClassDecorator methodsFor: 'accessing'!appPackages	^ self rawAppClass appPackages! !!PjBridgeAppClassDecorator methodsFor: 'exporting'!beforeExportApp 	rawAppClass beforeExportApp! !!PjBridgeAppClassDecorator methodsFor: 'accessing'!bridge	^ bridge! !!PjBridgeAppClassDecorator methodsFor: 'accessing'!bridge: anObject	bridge := anObject! !!PjBridgeAppClassDecorator methodsFor: 'accessing'!bridgeUrl	^ self bridge serverUrl! !!PjBridgeAppClassDecorator methodsFor: 'accessing'!bridgeWebSocketUrl	| rawUrl |	rawUrl := self bridgeUrl / self webSocketUrlTag.	^ 'ws:' , (rawUrl asString copyAfter: $:)! !!PjBridgeAppClassDecorator methodsFor: 'accessing'!classesForBridgeClient	^ self websocketDelegateClass allSuperclasses! !!PjBridgeAppClassDecorator methodsFor: 'polyfill'!globalsPools	^ self rawAppClass globalsPools! !!PjBridgeAppClassDecorator methodsFor: 'accessing'!headerLine	^ self rawAppClass headerLine! !!PjBridgeAppClassDecorator methodsFor: 'accessing'!pharoJsSelectorPrefix	<pharoJsSkip>		^ rawAppClass pharoJsSelectorPrefix! !!PjBridgeAppClassDecorator methodsFor: 'polyfill'!polyfill: aPolyfillClass withTranspiler: aTranspiler unlessIn: aSet	self rawAppClass		polyfill: aPolyfillClass		withTranspiler: aTranspiler		unlessIn: aSet! !!PjBridgeAppClassDecorator methodsFor: 'accessing'!rawAppClass	^ rawAppClass! !!PjBridgeAppClassDecorator methodsFor: 'accessing'!rawAppClass: anObject	rawAppClass := anObject! !!PjBridgeAppClassDecorator methodsFor: 'accessing'!setupCode	^ self rawAppClass setupCode! !!PjBridgeAppClassDecorator methodsFor: 'accessing'!webSocketUrlTag	^ self bridge webSocketUrlTag! !!PjBridgeAppClassDecorator methodsFor: 'accessing'!websocketDelegateClass	^ self class websocketDelegateClass! !!PjLoggingClientBridgeAppClassDecorator class methodsFor: 'accessing'!websocketDelegateClass	^ PjLoggingEvaluatorWebsocketDelegate! !!PjBridgeClient class methodsFor: 'instance creation'!newWithAppClass: pjAppClass	^ self new		  initializeWithAppClass: pjAppClass;		  yourself! !!PjBridgeClient methodsFor: 'accessing'!appClass	^ appClass ifNil: [ self defaultAppClass ]! !!PjBridgeClient methodsFor: 'accessing'!bridge	^ bridge! !!PjBridgeClient methodsFor: 'accessing'!clientId	^ clientId! !!PjBridgeClient methodsFor: 'accessing'!clientId: anObject	clientId := anObject! !!PjBridgeClient methodsFor: 'accessing'!codeGenerator	^ codeGenerator! !!PjBridgeClient methodsFor: 'accessing'!codeGenerator: aCodeGenerator	| decoratedAppClass |	codeGenerator := aCodeGenerator.	decoratedAppClass := codeGenerator decorateAppClass: appClass.	exporter initializeWithAppClass: decoratedAppClass! !!PjBridgeClient methodsFor: 'accessing'!codeGeneratorClass	self codeGenerator ifNil: [ ^ PjClientCodeGenerator ].	^ self codeGenerator species	"Allows keeping the behavior upon reseting the client in the bridge. See PjBridge>>#resetClient"! !!PjBridgeClient methodsFor: 'accessing - defaults'!defaultAppClass	self subclassResponsibility! !!PjBridgeClient methodsFor: 'accessing'!exporter	^ exporter! !!PjBridgeClient methodsFor: 'accessing'!exporterClass	self subclassResponsibility! !!PjBridgeClient methodsFor: 'accessing'!initializeWithAppClass: aPharoJsAppClass	appClass := aPharoJsAppClass.	exporter := self exporterClass new.	self codeGenerator: self codeGeneratorClass new! !!PjBridgeClient methodsFor: 'accessing'!initializeWithBridge: aBridge	bridge := aBridge.	self codeGenerator bridge: self bridge! !!PjBridgeClient methodsFor: 'accessing'!jsGlobalNames	^ (self appClass allSharedPoolsRecursive select:		   #isJavascriptGlobalsPool) flatCollectAsSet: #classVarNames! !!PjBridgeClient methodsFor: 'accessing'!openBrowserInBackground: aBoolean	"Useful only for Browser apps"	^ self! !!PjBridgeClient methodsFor: 'accessing'!pharoJsSelectorPrefix	^ exporter transpiler pharoJsSelectorPrefix! !!PjBridgeClient methodsFor: 'initialization'!reset	self initializeWithAppClass: self appClass.	self initializeWithBridge:  self bridge.	self clientId: nil.	"Ensure transpiler is reset correctly.	Transpiler is driven by exporter"	String streamContents: [ :aStream | self exporter writeJsCodeOn: aStream ]! !!PjBridgeClient methodsFor: 'initialization'!resetProxiesImmediately	self bridge resetProxiesImmediately! !!PjBridgeClient methodsFor: 'accessing'!server	^ self bridge server! !!PjBridgeClient methodsFor: 'accessing'!shouldStartJsInterpreter	^ self bridge shouldStartJsInterpreter! !!PjBridgeClient methodsFor: 'actions'!start	self shouldStartJsInterpreter ifTrue: [ self startJsInterpreter ]! !!PjBridgeClient methodsFor: 'actions'!startJsInterpreter	"start javascript interpreter"	self subclassResponsibility! !!PjBridgeClient methodsFor: 'actions'!startTimeout	^ 2 seconds! !!PjBridgeClient methodsFor: 'actions'!stop	"stop javascript interpreter"	self server ifNil: [ ^ self ].	self server isWebSocketConnected ifFalse: [ ^ self ].	self bridge websocketDelegateClassName ifNil: [ ^ self ].	[ self bridge sendMessage: PjMessageTerminate new ]		on: ConnectionTimedOut		do: [ " nothing: the socket's gone away " ]! !!PjBridgeClient methodsFor: 'accessing'!title	^ self appClass title! !!PjBridgeClient methodsFor: 'accessing'!websocketDelegateClass	^ self codeGenerator websocketDelegateClass! !!PjBridgeClient methodsFor: 'accessing'!websocketDelegateClassName	^ self codeGenerator websocketDelegateClassName! !!PjBridgeClient methodsFor: 'accessing'!withClientLogging	self codeGenerator: self codeGenerator withClientLogging! !!PjBrowserBridgeClient class methodsFor: 'accessing - defaults'!defaultWebBrowserName	^ defaultWebBrowserName ifNil: [ 'default' ]! !!PjBrowserBridgeClient class methodsFor: 'accessing - defaults'!defaultWebBrowserName: aString	defaultWebBrowserName := aString! !!PjBrowserBridgeClient class methodsFor: 'accessing'!firefox	^ #firefox! !!PjBrowserBridgeClient class methodsFor: 'utilities'!makeFirefoxDefaultWebBrowser	<script>		self defaultWebBrowserName: self firefox! !!PjBrowserBridgeClient class methodsFor: 'utilities'!makeSafariDefaultWebBrowser	<script>		self defaultWebBrowserName: self safari! !!PjBrowserBridgeClient class methodsFor: 'accessing'!safari	^ #safari! !!PjBrowserBridgeClient methodsFor: 'initialization-release'!defaultAppClass	^ PjMinimalWebApplication! !!PjBrowserBridgeClient methodsFor: 'accessing'!exporterClass	^ PjExporter! !!PjBrowserBridgeClient methodsFor: 'accessing'!initializeWithBridge: aBridge	super initializeWithBridge: aBridge.	self codeGenerator resetHtmlGenerator.	self server css: self codeGenerator css.	self server favicon: self codeGenerator favicon.	self server html: self codeGenerator html.! !!PjBrowserBridgeClient methodsFor: 'accessing'!serverUrl	^self server url! !!PjBrowserBridgeClient methodsFor: 'actions'!start	self bridge server		javascript:			(String				streamContents: [ :aStream | self exporter writeJsCodeOn: aStream ]).	super start! !!PjBrowserBridgeClient methodsFor: 'accessing'!urlString	^self server urlString! !!PjFileBasedBridgeClient methodsFor: 'accessing - files'!appFolder	^ self appClass appFolder! !!PjFileBasedBridgeClient methodsFor: 'accessing'!exporterClass	^ PjFileExporter! !!PjFileBasedBridgeClient methodsFor: 'accessing - files'!fileName	^ self appClass appFullJsFileName! !!PjFileBasedBridgeClient methodsFor: 'actions'!start	self writeFiles.	super start! !!PjFileBasedBridgeClient methodsFor: 'accessing - files'!writeFiles	exporter writeJavascriptFileNamed: self fileName! !!PjBridgeServedFileBasedBrowserBridgeClient methodsFor: 'actions'!appUrlPrefixString	^self appClass name! !!PjBridgeServedFileBasedBrowserBridgeClient methodsFor: 'accessing'!initializeWithBridge: aBridge	| staticFileDelegate |	super initializeWithBridge: aBridge.	staticFileDelegate := ZnStaticFileServerDelegate new.	staticFileDelegate		prefixFromString: self appUrlPrefixString;		directory: self appClass appFullHtmlFolderPath asFileReference.	self server delegate map: self appUrlPrefixString to: staticFileDelegate! !!PjBridgeServedFileBasedBrowserBridgeClient methodsFor: 'actions'!url	^ self server url / self appUrlPrefixString ! !!PjBridgeServedFileBasedBrowserBridgeClient methodsFor: 'accessing'!urlString	^ self url asString! !!PjFileBasedBrowserBridgeClient methodsFor: 'accessing - defaults'!defaultAppClass	^ PjMinimalFileBasedWebApp! !!PjFileBasedBrowserBridgeClient methodsFor: 'accessing'!urlString	^ self appClass appHtmlUrlString! !!PjNodeBridgeClient methodsFor: 'accessing - defaults'!defaultAppClass	^ PjMinimalNodeApplication ! !!PjNodeBridgeClient methodsFor: 'initialization'!reset 	self stop.	self resetProxiesImmediately.	super reset.	self startJsInterpreter! !!PjNodeBridgeClient methodsFor: 'actions'!runNodeOn: aFileName inFolder: aFolder	WebBrowser openTerminalWithNodeOn: aFileName inFolder: aFolder! !!PjNodeBridgeClient methodsFor: 'actions'!startJsInterpreter	self		runNodeOn: self fileName fullName		inFolder: self appFolder fullName! !!PjWebServedBridgeClient methodsFor: 'accessing - defaults'!defaultAppClass	^ PjMinimalWebApplication! !!PjWebServedBridgeClient methodsFor: 'accessing'!urlString	^ urlString! !!PjWebServedBridgeClient methodsFor: 'accessing'!urlString: anObject	urlString := anObject! !!PjNullBridgeClient methodsFor: 'actions'!start	"start interpreter"	^ self! !!PjNullBridgeClient methodsFor: 'actions'!stop	^ self! !!PjBridgeServer class methodsFor: 'accessing'!currentUsablePortNumber	CurrentUsablePortNumber ifNil: [ 		CurrentUsablePortNumber := self minPortNumber ].	^ CurrentUsablePortNumber! !!PjBridgeServer class methodsFor: 'accessing'!currentUsablePortNumber: aNumber	CurrentUsablePortNumber := aNumber! !!PjBridgeServer class methodsFor: 'accessing'!incrementCurrentUsablePortNumber	| p |	p := self currentUsablePortNumber		     ifNotNil: [ :cp | cp + 1 ]		     ifNil: [ self minPortNumber ].	p > self maxPortNumber ifTrue: [ p := self minPortNumber ].	self currentUsablePortNumber: p! !!PjBridgeServer class methodsFor: 'accessing'!maxPortNumber	^ 65535! !!PjBridgeServer class methodsFor: 'accessing'!minPortNumber	^ 1024! !!PjBridgeServer class methodsFor: 'accessing'!webSocketUrlTag	^ 'javascript-bridge'! !!PjBridgeServer methodsFor: 'accessing'!bridge	^ bridge! !!PjBridgeServer methodsFor: 'accessing'!bridge: anObject	bridge := anObject! !!PjBridgeServer methodsFor: 'accessing'!css	^ css ifNil: [ '' ]! !!PjBridgeServer methodsFor: 'accessing'!css: anObject	css := anObject! !!PjBridgeServer methodsFor: 'accessing'!defaultHTML	^'<!!DOCTYPE html><html><head>    <title>PharoJS - Develop in Pharo, Run on JavaScript</title>    <style>        html, body {            height: 100%;            margin: 0;            display: flex;            align-items: center;            justify-content: center;            font-family: Arial, sans-serif;            background-color: #f5f5f5;        }        .container {            text-align: center;            padding: 20px;            background-color: #ffffff;            border-radius: 5px;            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);        }        h1 {            font-size: 28px;            color: #333333;        }        p {            font-size: 16px;            color: #666666;            margin-bottom: 20px;        }        a {            color: #0066cc;            text-decoration: none;        }    </style></head><body>    <div class="container">        <h1>PharoJS - Develop in Pharo, Run on JavaScript</h1>        <p>Thank you for being a part of the PharoJS community. We appreciate your dedication to developing in Pharo and running your applications on JavaScript.</p>        <p>PharoJS is open-source under the MIT License. You can find the source code on <a href="https://github.com/PharoJS/PharoJS" target="_blank">GitHub</a>.</p>        <p>Visit <a href="https://pharojs.org" target="_blank">PharoJS.org</a> to learn more and get started.</p>    </div></body></html>'! !!PjBridgeServer methodsFor: 'accessing'!delegate	^ znServer delegate! !!PjBridgeServer methodsFor: 'accessing'!delegate: znServerDelegate 	znServer delegate: znServerDelegate ! !!PjBridgeServer methodsFor: 'accessing'!favicon	^ favicon! !!PjBridgeServer methodsFor: 'accessing'!favicon: anObject	favicon := anObject! !!PjBridgeServer methodsFor: 'accessing'!fingerPrint	^ fingerPrint! !!PjBridgeServer methodsFor: 'accessing'!fingerPrint: anObject	fingerPrint := anObject! !!PjBridgeServer methodsFor: 'websocket'!handleMessage: rawSocketMessage forSocket: aWebSocket	| msg |	msg := PhxJsonReader readFromString: rawSocketMessage.	self bridge acceptIncomingMessageFromClient: msg.	self logSocketRead: msg logDescription! !!PjBridgeServer methodsFor: 'accessing'!html	^ html ifNil: [ self defaultHTML]! !!PjBridgeServer methodsFor: 'accessing'!html: anObject	html := anObject! !!PjBridgeServer methodsFor: 'initialization'!indexHtmlResponse	^ ZnResponse ok: (ZnEntity html: self html)! !!PjBridgeServer methodsFor: 'initialization'!initialize	super initialize.	znServer := self newZincServer.	fingerPrint := UUIDGenerator next asString.! !!PjBridgeServer methodsFor: 'testing'!isStarted	^ self znServer isRunning and: [ self isStartedCheckExternally ]! !!PjBridgeServer methodsFor: 'testing'!isStartedCheckExternally	^ (ZnClient new		timeout: 1;		ifFail: [ String new ];		get:			'http://localhost:' , self znServer port asString				, '/serverFingerPrint') = self fingerPrint! !!PjBridgeServer methodsFor: 'start'!isStartedWithinTimeout	| attempts |	attempts := 1.	[ self isStarted		ifTrue: [ ^ true ].	attempts >= 10 ]		whileFalse: [ 20 milliSeconds wait.			attempts := attempts + 1 ].	^ false! !!PjBridgeServer methodsFor: 'websocket'!isWebSocketConnected	^self webSocket notNil! !!PjBridgeServer methodsFor: 'accessing'!javascript	^ javascript! !!PjBridgeServer methodsFor: 'accessing'!javascript: anObject	javascript := anObject! !!PjBridgeServer methodsFor: 'logging'!logSocketRead: aString	(self znServer newLogEvent: PjSocketLogEvent)		direction: 'read';		contents: aString;		emit! !!PjBridgeServer methodsFor: 'logging'!logSocketWritten: aString	(self znServer newLogEvent: PjSocketLogEvent)		direction: 'wrote';		contents: aString;		emit! !!PjBridgeServer methodsFor: 'initialization'!newServerDelegate	| newDelegate |	newDelegate := PjBridgeServerDelegate empty.	newDelegate map: '/' to: 'index.html'.	newDelegate		map: 'index.html'		to: [ :request | ZnResponse ok: (ZnEntity html: self html) ].	newDelegate		map: 'index.js'		to: [ :request | 		ZnResponse ok: (ZnEntity javascript: self javascript) ].	newDelegate		map: 'index.css'		to: [ :request | ZnResponse ok: (ZnEntity css: self css) ].	newDelegate map: 'favicon.ico' to: [ :request | 		self favicon			ifNil: [ ZnResponse notFound: request uri ]			ifNotNil: [ ZnResponse ok: (ZnEntity favicon: self favicon) ] ].	newDelegate		map: 'serverFingerPrint'		to: [ :request | ZnResponse ok: (ZnEntity text: self fingerPrint) ].	newDelegate		map: self webSocketUrlTag		to: (ZnWebSocketDelegate map: self webSocketUrlTag to: self).	^ newDelegate! !!PjBridgeServer methodsFor: 'initialization'!newZincServer	| srv |	srv := ZnMultiThreadedServer new.	srv delegate: self newServerDelegate.	^ srv! !!PjBridgeServer methodsFor: 'accessing'!port	^ self znServer port! !!PjBridgeServer methodsFor: 'public'!port: aPortNumber	self znServer port: aPortNumber! !!PjBridgeServer methodsFor: 'printing'!printOn: ws	super printOn: ws.	ws << ' --> '.	self znServer		ifNil: [ 'znServer missing???' ]		ifNotNil: [ :znSrv | znSrv printOn: ws ]! !!PjBridgeServer methodsFor: 'websocket'!safelyHandleMessage: aMessage forSocket: aWebSocket	[ self handleMessage: aMessage forSocket: aWebSocket ]		on: Error		do: [ :ex | 			self halt.			ex return ]! !!PjBridgeServer methodsFor: 'start'!start	| attempts |	self isStarted ifTrue: [ ^ self ].	attempts := 1.	[ 	self startOnCurrentUsablePortNumber.	self isStartedWithinTimeout ] whileFalse: [ 		attempts := attempts + 1.		self class incrementCurrentUsablePortNumber ]! !!PjBridgeServer methodsFor: 'start'!startOnCurrentUsablePortNumber	self startOnPort: self class currentUsablePortNumber! !!PjBridgeServer methodsFor: 'start'!startOnPort: aPort	self isStarted ifTrue: [ ^ self ].	self stop.	self znServer		port: aPort;		start! !!PjBridgeServer methodsFor: 'stop'!stop	self znServer ifNotNil: [ :srv | srv stop ]! !!PjBridgeServer methodsFor: 'accessing'!tearDown	self stop.	self bridge: nil! !!PjBridgeServer methodsFor: 'accessing'!timing	self halt.	^ timing! !!PjBridgeServer methodsFor: 'accessing'!timing: anObject	self halt.	timing := anObject! !!PjBridgeServer methodsFor: 'accessing'!url	^ self znServer url! !!PjBridgeServer methodsFor: 'accessing'!urlString	^ self url asString! !!PjBridgeServer methodsFor: 'accessing'!value: aWebSocket	[ 	self webSocket: aWebSocket.	aWebSocket runWith: [ :aMessage | 		self safelyHandleMessage: aMessage forSocket: aWebSocket ] ]		on: Error		do: [ ]! !!PjBridgeServer methodsFor: 'accessing'!webSocket	^ webSocket! !!PjBridgeServer methodsFor: 'accessing'!webSocket: anObject	webSocket := anObject! !!PjBridgeServer methodsFor: 'accessing'!webSocketUrlTag	^ self class webSocketUrlTag! !!PjBridgeServer methodsFor: 'accessing'!znServer	^ znServer! !!PjBridgeServer methodsFor: 'accessing'!znServer: anObject	znServer := anObject! !!PjClientCodeGenerator class methodsFor: 'accessing'!bridgeAppClassDecoratorClass	^ PjBridgeAppClassDecorator! !!PjClientCodeGenerator class methodsFor: 'public'!html	^self new html! !!PjClientCodeGenerator class methodsFor: 'generating'!websocketDelegateClass	^self bridgeAppClassDecoratorClass websocketDelegateClass! !!PjClientCodeGenerator methodsFor: 'accessing'!appClass	^ appClass! !!PjClientCodeGenerator methodsFor: 'accessing'!appClassDecorator	^ appClassDecorator! !!PjClientCodeGenerator methodsFor: 'accessing'!bridge: aBridge	appClassDecorator bridge: aBridge! !!PjClientCodeGenerator methodsFor: 'accessing'!bridgeAppClassDecoratorClass	^ self class bridgeAppClassDecoratorClass! !!PjClientCodeGenerator methodsFor: 'public'!css	^ self cssUsing: self htmlGenerator! !!PjClientCodeGenerator methodsFor: 'generating'!cssUsing: aHtmlGenerator	^ self appClass css ifNotNil: [ :css | 		  aHtmlGenerator addCssLink: 'index.css'.		  css ]! !!PjClientCodeGenerator methodsFor: 'generating'!decorateAppClass: anAppClass	appClass := anAppClass.	appClassDecorator := self bridgeAppClassDecoratorClass rawAppClass: anAppClass.	^ appClassDecorator! !!PjClientCodeGenerator methodsFor: 'generating'!favicon	^ self appClass favicon! !!PjClientCodeGenerator methodsFor: 'generating'!generateHtmlUsing: aHtmlGenerator	(self appClass generateHtmlUsing: aHtmlGenerator) ifFalse: [ 		aHtmlGenerator title: 'PharoJS:' , self titleString.		aHtmlGenerator			add: 'h1'			contents: 'PharoJS: Develop in Pharo, run in JavaScript'.		aHtmlGenerator add: 'h2' contents: self titleString ].	aHtmlGenerator addScriptUrl: 'index.js'! !!PjClientCodeGenerator methodsFor: 'public'!html	self generateHtmlUsing: self htmlGenerator.	^ self htmlGenerator html! !!PjClientCodeGenerator methodsFor: 'generating'!htmlGenerator	^ htmlGenerator ifNil: [ htmlGenerator := PjHtmlGenerator new ]! !!PjClientCodeGenerator methodsFor: 'generating'!resetHtmlGenerator	htmlGenerator := nil! !!PjClientCodeGenerator methodsFor: 'accessing'!titleString	^ titleString ifNil: [ '' ]! !!PjClientCodeGenerator methodsFor: 'accessing'!titleString: aString	titleString := aString! !!PjClientCodeGenerator methodsFor: 'accessing'!websocketDelegateClass	^ self class websocketDelegateClass! !!PjClientCodeGenerator methodsFor: 'accessing'!websocketDelegateClassName	^ self websocketDelegateClass name! !!PjClientCodeGenerator methodsFor: 'public'!withClientLogging	^ PjLoggingClientCodeGenerator new! !!PjLoggingClientCodeGenerator class methodsFor: 'accessing'!bridgeAppClassDecoratorClass	^ PjLoggingClientBridgeAppClassDecorator! !!PjLoggingClientCodeGenerator methodsFor: 'generating'!generateHtmlUsing: aHtmlGenerator	super generateHtmlUsing: aHtmlGenerator.	aHtmlGenerator addHtmlToBody: self logoHtmlString.	aHtmlGenerator cr! !!PjLoggingClientCodeGenerator methodsFor: 'generating'!htmlLogElementId	^ PjLoggingEvaluatorWebsocketDelegate logElementId! !!PjLoggingClientCodeGenerator methodsFor: 'generating'!logoHtmlString	^ '<div style="position:relative;width:100%;max-width:471px;"><img src="' , self logoUrlString	  , '" alt="JavaScript Pharo Bridge" style="width:100%;"/><br/></div>'! !!PjLoggingClientCodeGenerator methodsFor: 'generating'!logoUrlString	^ 'http://car.mines-douai.fr/wp-content/uploads/2015/07/pharoJsLogo2015-07-14.png'! !!PjLoggingClientCodeGenerator methodsFor: 'generating'!printClientSmalltalkLaunchStringOn: smalltalkWriteStream	smalltalkWriteStream		nextPutAll: self websocketDelegateClass name;		nextPutAll: ' logElementId: ';		print: self htmlLogElementId;		nextPutAll: ' . '.	super printClientSmalltalkLaunchStringOn: smalltalkWriteStream! !!PjHtmlGenerator methodsFor: 'public'!add: tag contents: aString	self add: tag do: [ bodyStream nextPutAll: aString ]! !!PjHtmlGenerator methodsFor: 'public'!add: tag do: aBlock	bodyStream		cr;		nextPut: $<;		nextPutAll: tag;		nextPut: $>.	aBlock value.	bodyStream		nextPutAll: '</';		nextPutAll: tag;		nextPut: $>! !!PjHtmlGenerator methodsFor: 'public'!add: tag id: id class: class contents: aString	self		add: tag		id: id		class: class		do: [ bodyStream nextPutAll: aString ]! !!PjHtmlGenerator methodsFor: 'public'!add: tag id: id class: class do: aBlock	bodyStream		cr; 		nextPut: $<;		nextPutAll: tag.	id ifNotNil: [ bodyStream nextPutAll: ' id="'; nextPutAll: id;nextPut:$"].	class ifNotNil: [ bodyStream nextPutAll: ' class="'; nextPutAll: class;nextPut:$"].	bodyStream		nextPut: $>.	aBlock value.	bodyStream		nextPutAll: '</';		nextPutAll: tag;		nextPut: $>! !!PjHtmlGenerator methodsFor: 'public'!add: tag id: id contents: aString	self 		add: tag		id: id		do: [ bodyStream nextPutAll: aString ]! !!PjHtmlGenerator methodsFor: 'public'!add: tag id: id do: aBlock	self add: tag id: id class: nil do: aBlock! !!PjHtmlGenerator methodsFor: 'public'!addButton: buttonLabel onClickDo: javaScript	bodyStream 		nextPutAll: '<input type="button" value="';		nextPutAll: buttonLabel;		nextPutAll: '" onclick="';		nextPutAll: javaScript;		nextPutAll: '" />'! !!PjHtmlGenerator methodsFor: 'public'!addCssLink: aString	headerStream 		nextPutAll: '<link rel="stylesheet" type="text/css" href="',aString,'">'! !!PjHtmlGenerator methodsFor: 'public'!addDiv: id contents: aString	self add: 'div' id: id contents: aString! !!PjHtmlGenerator methodsFor: 'public'!addDiv: id do: aBlock	self add: 'div' id: id do: aBlock! !!PjHtmlGenerator methodsFor: 'public'!addHtmlToBody: htmlString	bodyStream nextPutAll: htmlString! !!PjHtmlGenerator methodsFor: 'public'!addImage: imageUrl	bodyStream		cr; 		nextPutAll: '<img src="';		nextPutAll: imageUrl;		nextPutAll: '" style="width:window.width%;"/>'! !!PjHtmlGenerator methodsFor: 'public'!addScriptString: aString	scriptsStream		nextPutAll: '<script language="javascript" type="text/javascript">';		nextPutAll: aString;		nextPutAll: '</script>'! !!PjHtmlGenerator methodsFor: 'public'!addScriptUrl: aString	scriptsStream		nextPutAll: '<script language="javascript" type="text/javascript" src="';		nextPutAll: aString;		nextPutAll: '"></script>'! !!PjHtmlGenerator methodsFor: 'public'!addSpan: id contents: aString	self add: 'span' id: id contents: aString! !!PjHtmlGenerator methodsFor: 'public'!addSpan: id do: aBlock	self add: 'span' id: id do: aBlock! !!PjHtmlGenerator methodsFor: 'public'!addStyle: aString	headerStream		nextPutAll: '<style type="text/css">';		nextPutAll: aString;		nextPutAll: '</style>'! !!PjHtmlGenerator methodsFor: 'public'!addTextInput: id hint: hintString on: eventName do: javaScript	"eventName can take one of three values: keydown, keypress, keyup"	"Not keypress event is sent for actual characters and not when keys such as CTL or ALT are pressed"		bodyStream 		nextPutAll: '<input type="text" id="';		nextPutAll: id;		nextPutAll: '" placeholder="';		nextPutAll: hintString;		nextPutAll: '" on';		nextPutAll: eventName;		nextPutAll: '="';		nextPutAll: javaScript;		nextPutAll: '" />'! !!PjHtmlGenerator methodsFor: 'public'!addTextInput: id hint: hintString onKeyDownDo: javaScript	self addTextInput: id hint: hintString on: 'keydown' do: javaScript! !!PjHtmlGenerator methodsFor: 'public'!addTextInput: id hint: hintString onKeyPressDo: javaScript	self addTextInput: id hint: hintString on: 'keypress' do: javaScript! !!PjHtmlGenerator methodsFor: 'public'!addTextInput: id hint: hintString onKeyUpDo: javaScript	self addTextInput: id hint: hintString on: 'keyup' do: javaScript! !!PjHtmlGenerator methodsFor: 'public'!cr	bodyStream nextPutAll: '<br/>'! !!PjHtmlGenerator methodsFor: 'public'!html	| htmlStream |	htmlStream := String new writeStream.	htmlStream		nextPutAll: '<!!DOCTYPE html>';		cr;		nextPutAll: '<meta charset="utf-8" />';		cr;		nextPutAll: '<head>';		cr;		nextPutAll: headerStream contents;		cr;		nextPutAll: '</head>';		cr;		nextPutAll: '<body';		nextPutAll: bodyAttributes contents;		nextPut: $>;		cr;		nextPutAll: bodyStream contents;		cr;		nextPutAll: scriptsStream contents;		cr;		nextPutAll: '</body>';		cr;		nextPutAll: '</html>'.			^htmlStream contents! !!PjHtmlGenerator methodsFor: 'initialization'!initialize	super initialize.	headerStream := String new writeStream.	bodyStream := String new writeStream.	bodyAttributes := String new writeStream.	scriptsStream := String new writeStream! !!PjHtmlGenerator methodsFor: 'public'!loadFrom: aString	| hStart hEnd bStart bAngle bEnd |	hStart := aString indexOfSubCollection: '<head>'.	hEnd := aString indexOfSubCollection: '</head>'.	(hStart>0 and: [hEnd>hStart]) ifFalse: [		headerStream nextPutAll: '<!!-- no head tag in file -->'	] ifTrue: [		headerStream nextPutAll: (aString copyFrom: hStart+6 to: hEnd-1)].	bStart := aString indexOfSubCollection: '<body'.	bAngle := aString findString: '>' startingAt: bStart.	bEnd := aString indexOfSubCollection: '</body>'.	(bAngle>0 and: [(aString at: bStart+5)=$ ]) ifTrue: [ bodyAttributes nextPutAll: (aString copyFrom: bStart+5 to: bAngle-1)].	(bAngle>0 and: [bEnd>bAngle]) ifFalse: [		bodyStream nextPutAll: '<!!-- no body tag in file -->'	] ifTrue: [		bodyStream nextPutAll: (aString copyFrom: bAngle+1 to: bEnd-1)]! !!PjHtmlGenerator methodsFor: 'public'!title: aString	headerStream 		nextPutAll: '<title>';		nextPutAll: aString;		nextPutAll: '</title>'! !!PjMessageContext methodsFor: 'accessing'!websocketDelegate	^ websocketDelegate! !!PjMessageContext methodsFor: 'accessing'!websocketDelegate: anObject	websocketDelegate := anObject! !!PjParametrizableServerDelegate class methodsFor: 'instance-creation'!new	^ super new		initialize;		yourself! !!PjParametrizableServerDelegate methodsFor: 'accessing'!css	^ css! !!PjParametrizableServerDelegate methodsFor: 'accessing'!css: anObject	css := anObject! !!PjParametrizableServerDelegate methodsFor: 'accessing'!favicon	^ favicon! !!PjParametrizableServerDelegate methodsFor: 'accessing'!favicon: anObject	favicon := anObject! !!PjParametrizableServerDelegate methodsFor: 'accessing'!fingerPrint	^ fingerPrint! !!PjParametrizableServerDelegate methodsFor: 'accessing'!fingerPrint: anObject	fingerPrint := anObject! !!PjParametrizableServerDelegate methodsFor: 'handling'!handleRequest: request	| entity prefix |	prefix := request uri isSlash		          ifTrue: [ 'index.html' ]		          ifFalse: [ request uri firstPathSegment ].	('index.html' = prefix and: self html isEmptyOrNil not) ifTrue: [ 		entity := ZnEntity html: self html ].	('index.js' = prefix and: self javascript isEmptyOrNil not) ifTrue: [ 		entity := ZnEntity javascript: self javascript ].	('index.css' = prefix and: self css isEmptyOrNil not) ifTrue: [ 		entity := ZnEntity css: self css ].	('favicon.ico' = prefix and: self favicon isEmptyOrNil not) ifTrue: [ 		entity := ZnEntity favicon: self favicon ].	'serverFingerPrint' = prefix ifTrue: [ 		entity := ZnEntity html: self fingerPrint ].	entity ifNotNil: [ ^ ZnResponse ok: entity ].	^ ZnResponse notFound: request uri! !!PjParametrizableServerDelegate methodsFor: 'accessing'!html	^ html! !!PjParametrizableServerDelegate methodsFor: 'accessing'!html: aString	html := aString! !!PjParametrizableServerDelegate methodsFor: 'initialization'!initialize	super initialize.	fingerPrint := UUIDGenerator next asString! !!PjParametrizableServerDelegate methodsFor: 'accessing'!javascript	^ javascript! !!PjParametrizableServerDelegate methodsFor: 'accessing'!javascript: anObject	javascript := anObject! !!PjProxy class methodsFor: 'instance creation'!newProxyNamed: proxyName onBridge: aBridge oid: anOid	^ ((proxyName beginsWith: '$_')		ifTrue: [ PjProxy ]		ifFalse: [ PjProxyForGlobal ]) new		jsName: proxyName onBridge: aBridge oid: anOid;		yourself! !!PjProxy class methodsFor: 'instance creation'!proxyNamed: proxyName onBridge: aBridge	"Useful for building proxies on JS globals"	^ self proxyNamed: proxyName onBridge: aBridge oid: proxyName! !!PjProxy class methodsFor: 'instance creation'!proxyNamed: proxyName onBridge: aBridge oid: anOid	| proxy |	aBridge		ifNotNil: [ proxy := aBridge proxies				detect: [ :p | p oid = anOid ]				ifNone: [ nil ].			proxy ifNotNil: [ ^ proxy ].			proxy := aBridge proxies at: proxyName ifAbsent: [ nil ].			proxy ifNotNil: [ ^ proxy ].			proxy := PjProxy				newProxyNamed: proxyName				onBridge: aBridge				oid: anOid.			^ aBridge proxies at: proxyName put: proxy ]! !!PjProxy methodsFor: 'comparing'!= anObject	| equalMessage |	super == anObject ifTrue: [ ^ true ].	(anObject isKindOf: PjProxy) ifFalse: [ ^ false ].	proxySpecificBridge = anObject jsBridge ifFalse: [ ^ false ].	equalMessage := Message selector: #= argument: anObject.	^ self jsBridge: [ :bridge | 		  bridge evalMessage: equalMessage sentTo: jsName ]! !!PjProxy methodsFor: 'reflective operations'!addEventListener: type block: aBlock	^ self jsBridge: [ :bridge | 		  | bcProxyInfo msg |		  bcProxyInfo := aBlock ifNotNil: [ 			                 (bridge ensureProxyForEventListenerBlock: aBlock)				                 asProxyInfo ].		  msg := PjMessageSetEventListener newWithId.		  msg targetProxyInfo: self asProxyInfo.		  msg listenerProxyInfo: bcProxyInfo.		  msg eventName: type.		  bridge sendMessageAndWaitForResponse: msg ]! !!PjProxy methodsFor: 'converting'!asJSON	^ jsName! !!PjProxy methodsFor: 'converting'!asJsObjectUsing: converter	^ self! !!PjProxy methodsFor: 'converting'!asLocalObject	| size |	size := self size.	^ Array		  new: size		  streamContents: [ :s | 		  1 to: size do: [ :index | s nextPut: (self at: index) ] ]! !!PjProxy methodsFor: 'converting'!asRawJSONString	^ self jsBridge: [ :bridge | 		  bridge evalJavascript: 'JSON.stringify(' , jsName , ')' ]! !!PjProxy methodsFor: 'force proxy'!at: index	^ self doesNotUnderstand: (Message selector: #at: argument: index)! !!PjProxy methodsFor: 'force proxy'!at: index put: anObject	^ self doesNotUnderstand: (Message selector: #at:put: arguments: { 				   index.				   anObject })! !!PjProxy methodsFor: 'closure handling'!closure: aBlockClosure	closure ifNotNil: [ 		self jsBridge: [ :bridge | bridge deleteBlockClosure: closure ] ].	closure := aBlockClosure! !!PjProxy methodsFor: 'force proxy'!confirm: aString	^ self doesNotUnderstand:		  (Message selector: #confirm: argument: aString)! !!PjProxy methodsFor: 'reflective operations'!convertToJavascriptAstUsing: aPjAstConverter	^ PjGlobalNode identifier: jsName! !!PjProxy methodsFor: 'reflective operations'!doesNotUnderstand: aMessage	^ self jsBridge: [ :bridge | 		  bridge evalMessage: aMessage sentTo: jsName ]! !!PjProxy methodsFor: 'force proxy'!head	^ self doesNotUnderstand: (Message selector: #head)! !!PjProxy methodsFor: 'introspection'!instVarNamed: aString	^ self jsBridge: [ :bridge | 		  | selector |		  selector := jsName , '.' , aString.		  bridge evalJavascript: selector ]! !!PjProxy methodsFor: 'introspection'!instVarNamed: aString put: aValue	^ self jsBridge: [ :bridge | 		  bridge evalJavascriptWithDnuFrom: [ 			  jsName , '.' , aString , '=' , (bridge convertToJs: aValue) ] ]! !!PjProxy methodsFor: 'testing'!isLiteralJavascriptValue	^ true! !!PjProxy methodsFor: 'testing'!isPjProxyNil	jsName = 'undefined' ifTrue: [ ^ true ].	jsName = 'null' ifTrue: [ ^ true ].	^ false! !!PjProxy methodsFor: 'testing'!isPjProxyOrNil	^ true! !!PjProxy methodsFor: 'javascript generation'!javascriptName	^ jsName! !!PjProxy methodsFor: 'javascript generation'!javascriptValid	^ true! !!PjProxy methodsFor: 'force proxy'!join: aCollection	^ self doesNotUnderstand:		  (Message selector: #join: argument: aCollection)! !!PjProxy methodsFor: 'accessing'!jsBridge	^ proxySpecificBridge! !!PjProxy methodsFor: 'accessing'!jsBridge: aBlock	proxySpecificBridge ifNotNil: [ :bridge | ^ aBlock value: bridge ].	PjBridge soleBridge ifNotNil: [ :bridge | ^ aBlock value: bridge ].	self error: 'no bridge for proxy: ' , jsName! !!PjProxy methodsFor: 'initialize-release'!jsName: aString onBridge: aBridge oid: anOid	jsName := aString asSymbol.	oid := anOid asSymbol.	aBridge ifNotNil: [ 		| finalizer |		finalizer := PjProxyFinalizationHandler			             finalizerForProxyNamed: jsName			             onBridge: aBridge.		self finalizationRegistry add: self executor: finalizer ].	proxySpecificBridge := aBridge! !!PjProxy methodsFor: 'force proxy'!log: aString	^ self doesNotUnderstand: (Message selector: #log: argument: aString)! !!PjProxy methodsFor: 'force proxy'!name	^ self doesNotUnderstand: (Message selector: #name)! !!PjProxy methodsFor: 'accessing'!oid	^ oid! !!PjProxy methodsFor: 'accessing'!oid: anObject	oid := anObject! !!PjProxy methodsFor: 'javascript generation'!printJsOn: aStream	aStream nextPutAll: jsName! !!PjProxy methodsFor: 'printing'!printOn: ws	super printOn: ws.	ws << ' (oid: '.	self oid ifNil: [ ws << '-' ] ifNotNil: [ ws << self oid ].	ws << ')'! !!PjProxy methodsFor: 'reflective operations'!removeEventListener: type	^ self addEventListener: type block: nil! !!PjProxy methodsFor: 'closure handling'!runBlockClosure: ev with: this	closure ifNotNil: [ closure cull: ev cull: this ]! !!PjProxy methodsFor: 'force proxy'!size	^ self doesNotUnderstand: (Message selector: #size)! !!PjProxy methodsFor: 'force proxy'!value	^ self doesNotUnderstand: (Message selector: #value)! !!PjProxy methodsFor: 'force proxy'!value: anObject	^ self doesNotUnderstand:		  (Message selector: #value: argument: anObject)! !!PjProxyForGlobal class methodsFor: 'accessing'!allJavascriptGlobals	^ self withAllSubclasses flatCollectAsSet: [: class |		class allInstances collect: #asJSON]! !!PjProxyForGlobal class methodsFor: 'instance creation'!newProxyNamed: globalName	^ self newProxyNamed: globalName onBridge: nil oid: globalName! !!PjProxyForGlobal methodsFor: 'printing'!printOn: aStream	aStream		nextPutAll: 'a Proxy for ';		nextPutAll: jsName! !!PjProxyFinalizationHandler class methodsFor: 'finalization support'!finalizerForProxyNamed: aString onBridge: aBridge	| instance |	instance := self new		proxyJsName: aString;		bridge: aBridge;		yourself.	^ instance finalizer! !!PjProxyFinalizationHandler methodsFor: 'accessing'!bridge	^ weakBridgeArray at: 1! !!PjProxyFinalizationHandler methodsFor: 'accessing'!bridge: aBridge	weakBridgeArray at: 1 put: aBridge! !!PjProxyFinalizationHandler methodsFor: 'finalization'!cleanUpJsSide	self bridge ifNotNil: [ :br | 		br isServerStopped ifFalse: [ br deleteJsValue: self proxyJsName ] ]! !!PjProxyFinalizationHandler methodsFor: 'accessing'!finalizer	^ ObjectFinalizer new		  receiver: self;		  selector: #cleanUpJsSide yourself! !!PjProxyFinalizationHandler methodsFor: 'initialize-release'!initialize	super initialize.	weakBridgeArray := WeakArray new: 1! !!PjProxyFinalizationHandler methodsFor: 'accessing'!proxyJsName	^ proxyJsName! !!PjProxyFinalizationHandler methodsFor: 'accessing'!proxyJsName: anObject	proxyJsName := anObject! !!PjSinkObject class methodsFor: 'default instance'!default	^default ifNil: [ default := self new ]! !!PjSinkObject class methodsFor: 'reflective operations'!doesNotUnderstand: aMessage	^self! !!PjSinkObject class methodsFor: 'default instance'!resetDefault	"self resetDefault"	default := nil! !!PjSinkObject methodsFor: 'reflective operations'!doesNotUnderstand: aMessage	^ self! !!ZnEntity class methodsFor: '*PharoJs-Base-Bridge-Exporter'!css: css	^ self stringEntityClass css: css! !!ZnEntity class methodsFor: '*PharoJs-Base-Bridge-Exporter'!favicon: favicon	^ ZnByteArrayEntity favicon: favicon! !!ZnEntity class methodsFor: '*PharoJs-Base-Bridge-Exporter'!javascript: javascript	^ self stringEntityClass javascript: javascript! !!ManifestPharoJsBaseBridge class methodsFor: 'code-critics'!ruleBadMessageRule2V1FalsePositive	^ #(#(#(#RGMethodDefinition #(#PjBridge #timeout: #false)) #'2022-02-02T08:50:25.026526+01:00') )! !!PjAstConverter methodsFor: '*PharoJs-Base-Bridge'!convertJavascriptMessage: aJavascriptMessage	| args |	args := aJavascriptMessage arguments collect: [ :each | 		        each asJsAstUsing: self ].	self discoveredMessage: aJavascriptMessage selector.	^ PjApplyNode		  func: (PjFieldNode				   target:				   (PjGlobalNode identifier: aJavascriptMessage receiverId)				   selectorNode:				   (PjMessageSelectorNode identifier: aJavascriptMessage selector)				   isNonNil: true)		  args: args! !!PjExporter methodsFor: '*PharoJs-Base-Bridge'!convertToJs: anObject	self transpiler enableWriteDnuDuring: [ 		^ self transpiler convertToJs: anObject ]! !!PjExporter methodsFor: '*PharoJs-Base-Bridge'!invalidateClass: aClass	self transpiler invalidateClass: aClass! !!PjExporter methodsFor: '*PharoJs-Base-Bridge'!setExtraBindings: aDictionary	^ self transpiler setExtraBindings: aDictionary! !!ZnStringEntity class methodsFor: '*PharoJs-Base-Bridge-Exporter'!css: string	^ (self type: ZnMimeType textCss)		  string: string;		  yourself! !!ZnStringEntity class methodsFor: '*PharoJs-Base-Bridge-Exporter'!javascript: string	^ (self type: ZnMimeType textJavascript)		  string: string;		  yourself! !!WBMacWebBrowser class methodsFor: '*PharoJs-Base-Bridge'!openBrowser: browserName on: urlString inBackground: backgroundFlag	"Open the webbrowser on the given URL	self openBrowser: 'Firefox' on: 'http://pharojs.org' inBackground: false.	if the browserName is nil, open the default browser.	self openBrowser: nil on: 'http://pharojs.org' inBackground: false.	The backgroundFlag is true when the window of the browser should open behind the Pharo window.	"	| openScriptPath backgroundCommand browserCommandName command |	backgroundCommand := backgroundFlag		                     ifTrue: [ 'background' ]		                     ifFalse: [ '' ].	browserCommandName := browserName ifNil: [ 'default' ].	openScriptPath := PjApplication repositoryPath / 'Tools' / 'MacOsX'	                  / 'openUrl'.	command := String streamContents: [ :str | 		           str			           << openScriptPath pathString;			           space;						<<$";			           << urlString;						<<$";			           space;			           << browserCommandName;			           space;			           << backgroundCommand ].	self system: command! !!WBMacWebBrowser class methodsFor: '*PharoJs-Base-Bridge'!openTerminalWithNodeOn: theFileName inFolder: theFolder	| cd |	cd := theFolder ifNil: [ '' ] ifNotNil: [ 'cd ' , theFolder , '; ' ].	self system: 'osascript -e ''  tell application "Terminal"    activate    set newTab to do script("' , cd , 'exec node ' , theFileName		, '")    set current settings of selected tab of window 1 to settings set "PharoNode"  end tell'''! !!ZnByteArrayEntity class methodsFor: '*PharoJs-Base-Bridge-Exporter'!favicon: byteArray	^ (self type: (ZnMimeType main: 'image' sub: 'vnd.microsoft.icon'))		  bytes: byteArray;		  yourself! !!PjSocketLogEvent methodsFor: 'accessing'!contents: anObject	contents := anObject! !!PjSocketLogEvent methodsFor: 'accessing'!direction: anObject	direction := anObject! !!PjSocketLogEvent methodsFor: 'printing'!printContentsOn: stream	| limitedString |	limitedString := String		                 streamContents: [ :s | s nextPutAll: contents ]		                 limitedTo: 20.	stream		nextPutAll: ' socket ';		nextPutAll: direction asString;		nextPut: $:;		space;		nextPutAll: limitedString.	limitedString size < contents size ifTrue: [ 		stream			nextPutAll: '... ';			print: contents size;			nextPut: $B ]! !!PjWebApplication class methodsFor: '*PharoJs-Base-Bridge-App'!bridgeClientClass	<pharoJsSkip>	^ PjBrowserBridgeClient! !!PjNodeApplication class methodsFor: '*PharoJs-Base-Bridge-App'!bridgeClientClass	<pharoJsSkip>		^ PjNodeBridgeClient! !!PjProxyInfo methodsFor: 'public'!getJsObject	^ global instVarNamed: self globalName! !!PjProxyInfo methodsFor: 'accessing'!globalName	^ globalName! !!PjProxyInfo methodsFor: 'accessing'!globalName: anObject	globalName := anObject! !!PjProxyInfo methodsFor: 'printing'!logDescription	^ String streamContents: [ :ws | 		  ws nextPutAll: 'Proxy '.		  ws nextPutAll: ' oid: '.		  ws nextPutAll: self oid.		  ws nextPutAll: ' globalName: '.		  ws nextPutAll: self globalName.		  ws nextPutAll: ' remove: '.		  ws nextPutAll: (self remove == true				   ifTrue: [ 'true' ]				   ifFalse: [ 'false' ]) ]! !!PjProxyInfo methodsFor: 'accessing'!oid	^ oid! !!PjProxyInfo methodsFor: 'accessing'!oid: anObject	oid := anObject! !!PjProxyInfo methodsFor: 'public'!proxyForBridge: aBridge	"jsName globalRef"	<pharoJsSkip>	| proxy |	self globalName = #undefined ifTrue: [ ^ nil ].	self globalName = #null ifTrue: [ ^ nil ].	self remove == true ifTrue: [ 		aBridge proxies detect: [ :p | p oid = self oid ] ifFound: [ :p | 			p closure: nil.			^ true ].		aBridge proxies			detect: [ :p | p jsName = self globalName ]			ifFound: [ :p | 				p closure: nil.				^ true ].		self error: 'proxy to be removed not found' ].	proxy := PjProxy		         proxyNamed: self globalName asSymbol		         onBridge: aBridge		         oid: self oid asSymbol.	^ proxy! !!PjProxyInfo methodsFor: 'accessing'!remove	^ remove! !!PjProxyInfo methodsFor: 'accessing'!remove: anObject	remove := anObject! !!PjProxyManager class methodsFor: 'instance creation'!atGlobalVarName: globalId put: anObject	global at: globalId put: anObject! !!PjProxyManager class methodsFor: 'default instance'!deleteGlobalVarNamed: globalId	globalId ifNil: [ ^ self ].	globalId isEmpty ifTrue: [ ^ self ].	(global instVarNamed: globalId) ifNotNil: [ :obj | 		obj ifNotNil: [ global removeKey: globalId ] ]! !!PjProxyManager class methodsFor: 'instance creation'!ensureObjectRegistered: anObject	| oid globalId |	oid := self ensureOidOnObject: anObject.	globalId := PjProxyManager nextGlobalVarName.	self atGlobalVarName: globalId put: anObject.	^ oid -> globalId! !!PjProxyManager class methodsFor: 'instance creation'!ensureOidOnObject: anObject	^ (self getOidFrom: anObject) ifNil: [ 		  | oid |		  oid := PjProxyManager nextOid.		  self setOid: oid on: anObject.		  oid ]! !!PjProxyManager class methodsFor: 'instance creation'!getOidFrom: anObject	^ anObject instVarNamed: self oidInstVarName! !!PjProxyManager class methodsFor: 'instance creation'!makeBlockClosureProxy: withThis stopPropagation: stop for: webSocketDelegate	| blockClosure oid |	oid := PjProxyManager nextOid.	blockClosure := [ :ev | 	| target msg |	stop		ifTrue: [ ev stopPropagation ].	target := withThis		ifFalse: [ nil ]		ifTrue: [ ev target ifNil: [ ev sourceElement ] ].	msg := PjMessageCallback newWithId.	msg receiverProxyInfo: blockClosure proxyResponse.	msg eventProxyInfo: ev proxyResponse.	msg eventTargetProxyInfo: target proxyResponse.	webSocketDelegate tryToSendMessage: msg.	true ].	blockClosure instVarNamed: '$PjRefCount' put: 0.	self setOid: oid on: blockClosure.	self atGlobalVarName: oid put: blockClosure.	^ blockClosure proxyResponse! !!PjProxyManager class methodsFor: 'instance creation'!nextGlobalVarName	^ '$_' , self nextIdNumber asString! !!PjProxyManager class methodsFor: 'instance creation'!nextIdNumber	currentId := currentId ifNil: [ 1 ] ifNotNil: [ :id | id + 1 ].	^ currentId! !!PjProxyManager class methodsFor: 'instance creation'!nextOid	^ '$_' , self nextIdNumber asString! !!PjProxyManager class methodsFor: 'default instance'!oidInstVarName	^ '$_oid'! !!PjProxyManager class methodsFor: 'instance creation'!setOid: anOid on: anObject	anObject instVarNamed: self oidInstVarName putHidden: anOid! !!PjEvaluatorWebsocketDelegate class methodsFor: 'defaut instance'!closeDefault	self default close! !!PjEvaluatorWebsocketDelegate class methodsFor: 'defaut instance'!connectDefaultToTag: tagString	| newInstance |	newInstance := self connectToTag: tagString.	self default: newInstance! !!PjEvaluatorWebsocketDelegate class methodsFor: 'defaut instance'!connectDefaultToUrl: urlString	| newInstance |	newInstance := self connectToUrl: urlString.	self default: newInstance! !!PjEvaluatorWebsocketDelegate class methodsFor: 'defaut instance'!default	^ default! !!PjEvaluatorWebsocketDelegate class methodsFor: 'defaut instance'!default: newInstance	default := newInstance! !!PjEvaluatorWebsocketDelegate class methodsFor: 'constants'!includeClasses	^ { 		  PhxJsonReader.		  PjMessageDeleteGlobalVar.		  PjMessageEvaluateJavascript.		  PjMessageGetKeys.		  PjMessageReload.		  PjMessageTerminate.		  PjMessageSetEventListener.		  PjMessageMakeBlockClosureProxy }! !!PjEvaluatorWebsocketDelegate class methodsFor: 'class initialization'!initialize	Smalltalk at: #PjBridge ifPresent: [ ^ self ].	#( JSON Math WebSocket console global document history location	   navigator screen window localStorage module process require ) do: [ 		:each | 		(global at: each) ifNotNil: [ :obj | 			obj instVarNamed: PjProxyManager oidInstVarName putHidden: each ] ]! !!PjEvaluatorWebsocketDelegate class methodsFor: 'class initialization'!initializePrivate	#( JSON Math WebSocket console global document history location	   navigator screen window localStorage module process require ) do: [ 		:each | 		(global at: each) ifNotNil: [ :obj | 			obj instVarNamed: PjProxyManager oidInstVarName putHidden: each ] ]! !!PjEvaluatorWebsocketDelegate class methodsFor: 'defaut instance'!reload	self reload: true! !!PjEvaluatorWebsocketDelegate class methodsFor: 'defaut instance'!reload: aBoolean	self closeDefault.	"Reload parameter specifies the type of reloading:false - Default. Reloads the current page from the cache.true - Reloads the current page from the server."	location reload: aBoolean.! !!PjEvaluatorWebsocketDelegate class methodsFor: 'defaut instance'!terminate	[ self closeDefault ]		on: Error		do: [  ].	[ process exit ]		on: Error		do: [  ]! !!PjEvaluatorWebsocketDelegate methodsFor: 'connecting'!close	shouldRetryToConnectToServer := false.	super close! !!PjEvaluatorWebsocketDelegate methodsFor: 'connecting'!connectTo: urlString	shouldRetryToConnectToServer := true.	bridgeUrlString := urlString.	super connectTo: urlString! !!PjEvaluatorWebsocketDelegate methodsFor: 'initialize-release'!initialize	super initialize.	Object prototype instVarNamed: PjCore pharoJsSelectorPrefix, 'inspect' putHidden: self makeInspect.! !!PjEvaluatorWebsocketDelegate methodsFor: 'socket behavior'!logReceived: aString	console log: 'Received: ',aString! !!PjEvaluatorWebsocketDelegate methodsFor: 'socket behavior'!logSent: aString	console log: 'Sent: ',aString! !!PjEvaluatorWebsocketDelegate methodsFor: 'initialize-release'!makeInspect	^ self		passJsThisArgumentToBlock: [ :this | 			self				tryToSendMessage:					(PjMessageInspect newWithId						subjectProxyInfo: this proxyResponse;						yourself) ]! !!PjEvaluatorWebsocketDelegate methodsFor: 'connecting'!onClose: event	self reconnect! !!PjEvaluatorWebsocketDelegate methodsFor: 'connecting'!onError: event	self reconnect! !!PjEvaluatorWebsocketDelegate methodsFor: 'socket behavior'!onMessage: event	| jsonString msg |	jsonString := event data.	msg := PhxJsonReader readFromString: jsonString.	self logReceived: msg logDescription.	msg evaluateInContext: self newMessageContext! !!PjEvaluatorWebsocketDelegate methodsFor: 'socket behavior'!onOpen: event	super onOpen: event.	self		tryToSendMessage:			(PjMessageSetClientId newWithId				clientId: self id;				yourself)! !!PjEvaluatorWebsocketDelegate methodsFor: 'initialize-release'!passJsThisArgumentToBlock: aBlock	<PjTodo: 'Maybe this method should be moved to PjCore?'>	<javascript: 'return function(){aBlock(this)}'>! !!PjEvaluatorWebsocketDelegate methodsFor: 'connecting'!reconnect	shouldRetryToConnectToServer ifFalse: [^ self ].	super connectTo: bridgeUrlString! !!PjEvaluatorWebsocketDelegate methodsFor: 'socket behavior'!tryToSendMessage: aMessage	self isClosed		ifTrue: [ self logSent: 'Failed to send (websocket closed): ' , aMessage logDescription ]		ifFalse: [ webSocket send: aMessage asPhxJsonString.			self logSent: aMessage logDescription ]! !!PjLoggingEvaluatorWebsocketDelegate class methodsFor: 'accessing'!logElementId	^ logElementId ifNil: [ 'webSocketLog' ]! !!PjLoggingEvaluatorWebsocketDelegate class methodsFor: 'accessing'!logElementId: aString	logElementId := aString! !!PjLoggingEvaluatorWebsocketDelegate methodsFor: 'logging'!log: aString	| logElement br text | 	[		br := document createElement: 'BR'.		text := document createTextNode: aString.		logElement := self logElement.		logElement				insertBefore: br node: logElement firstChild;				insertBefore: text node: logElement firstChild	] on: Error do: [		console log: aString	]! !!PjLoggingEvaluatorWebsocketDelegate methodsFor: 'logging'!logElement	| logElement |	logElement := document getElementById: self logElementId.	logElement ifNil: [		| enclosing |		logElement := document createElement: 'DIV'.		logElement			appendChild: (document createElement: 'BR');			id: self logElementId.		enclosing := document createElement: 'DIV'.		enclosing style			backgroundColor: '#EEF';			border: 'thin solid';			padding: '1em'.		enclosing			appendChild: ((document createElement: 'H1')									appendChild: (document createTextNode: 'Log of communications');									yourself);			appendChild: logElement.		document body appendChild: enclosing	].	^ logElement! !!PjLoggingEvaluatorWebsocketDelegate methodsFor: 'logging'!logElementId	^ logElementId ifNil: [ logElementId := self class logElementId ]! !!PjLoggingEvaluatorWebsocketDelegate methodsFor: 'logging'!logElementId: anObject	logElementId := anObject! !!PjLoggingEvaluatorWebsocketDelegate methodsFor: 'socket - behavior'!logReceived: aString	self log: 'Received: ', aString! !!PjLoggingEvaluatorWebsocketDelegate methodsFor: 'socket - behavior'!logSent: aString	self log: 'Sent: ', aString.	^ aString! !!PjLoggingEvaluatorWebsocketDelegate methodsFor: 'socket - event handling'!onClose: event	super onClose: event.	self log: 'Closed.'! !!PjLoggingEvaluatorWebsocketDelegate methodsFor: 'socket - event handling'!onError: event	super onError: event.	self log: 'Error: ' , event message! !!PjLoggingEvaluatorWebsocketDelegate methodsFor: 'socket - event handling'!onOpen: event	super onOpen: event.	self log: 'Open (id: ' , self id , ')'! !!PjWebsocketDelegate class methodsFor: 'instance creation'!connectToTag: tagString	^ self connectToUrl: 'ws://' , location host , '/' , tagString! !!PjWebsocketDelegate class methodsFor: 'instance creation'!connectToUrl: urlString	| newInstance |	newInstance := self new.	newInstance connectTo: urlString.	^ newInstance! !!PjWebsocketDelegate class methodsFor: 'instance creation'!new	^ super new		  id: self randomIdForNewInstance;		  yourself! !!PjWebsocketDelegate class methodsFor: 'instance creation'!randomIdForNewInstance	| charPool id size |	charPool := 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789'.	size := charPool size.	id := ''.	10 timesRepeat: [ 		| rndIdx |		rndIdx := (Math floor: Math random * size) + 1.		id := id , (charPool at: rndIdx) ].	^ id! !!PjWebsocketDelegate methodsFor: 'connecting'!close	webSocket close! !!PjWebsocketDelegate methodsFor: 'connecting'!connectTo: urlString	webSocket := WebSocket new: urlString.	self initWebSocket! !!PjWebsocketDelegate methodsFor: 'accessing'!id	^ id! !!PjWebsocketDelegate methodsFor: 'accessing'!id: anObject	id := anObject! !!PjWebsocketDelegate methodsFor: 'connecting'!initWebSocket	webSocket instVarNamed:#onopen put: [: event | self onOpen: event].	webSocket instVarNamed:#onmessage put: [: event | self onMessage: event]..	webSocket instVarNamed:#onclose put: [: event | self onClose: event].	webSocket instVarNamed:#onerror put: [: event | self onError: event].! !!PjWebsocketDelegate methodsFor: 'initialize-release'!initialize	super initialize.	id := self class randomIdForNewInstance.! !!PjWebsocketDelegate methodsFor: 'testing'!isClosed	webSocket ifNil: [ ^true ].	^ webSocket readyState == WebSocket CLOSED! !!PjWebsocketDelegate methodsFor: 'testing'!isConnected	webSocket ifNil: [ ^false ].	^webSocket readyState == WebSocket OPEN! !!PjWebsocketDelegate methodsFor: 'private'!newMessageContext	| mc |	mc := PjMessageContext new.	mc websocketDelegate: self.	^mc! !!PjWebsocketDelegate methodsFor: 'socket behavior'!onClose: event	^self! !!PjWebsocketDelegate methodsFor: 'socket behavior'!onError: event	^self! !!PjWebsocketDelegate methodsFor: 'socket behavior'!onMessage: event	^self! !!PjWebsocketDelegate methodsFor: 'socket behavior'!onOpen: event	^self! !!PjMessage class methodsFor: 'instance creation'!newWithContents: contents	^ self newWithId		  contents: contents;		  yourself! !!PjMessage class methodsFor: 'instance creation'!newWithId	^ self new		  id: self nextMessageId;		  yourself! !!PjMessage class methodsFor: 'instance creation'!nextMessageId	currentId := currentId ifNil: [ 1 ] ifNotNil: [ :id | id + 1 ].	^ currentId! !!PjMessage methodsFor: 'accessing'!contents	^ contents! !!PjMessage methodsFor: 'accessing'!contents: anObject	contents := anObject! !!PjMessage methodsFor: 'accessing'!id	^ id! !!PjMessage methodsFor: 'accessing'!id: anObject	id := anObject! !!PjMessage methodsFor: 'initialization'!initialize	super initialize! !!PjMessage methodsFor: 'printing'!logDescription	^ String		streamContents: [ :ws | 			ws nextPutAll: self class name.			ws nextPutAll: ' id: '.			ws nextPutAll: self id printString.			self contents				ifNotNil: [ :c | 					ws nextPutAll: ' contents: '.					ws nextPutAll: c ] ]! !!PjMessage methodsFor: 'testing'!needsToBeQueued	^ true! !!PjMessage methodsFor: 'printing'!printOn: ws	<pharoJsSkip>	super printOn: ws.	ws space.	ws << 'id:'.	ws << self id! !!PjMessageC2s methodsFor: 'public'!evaluateInContext: aMessageContext	"self subclassResponsibility "! !!PjMessageC2s methodsFor: 'accessing'!inResponseToId	^ nil! !!PjMessageC2s methodsFor: 'testing'!isCallback	^ false! !!PjMessageC2s methodsFor: 'testing'!shouldEvaluateImmediately	^ false! !!PjMessageC2sInResponseTo methodsFor: 'accessing'!inResponseToId	^ inResponseToId! !!PjMessageC2sInResponseTo methodsFor: 'accessing'!inResponseToId: anObject	inResponseToId := anObject! !!PjMessageErrorResponse methodsFor: 'accessing'!getValueWithBridge: aBridge	PjJavascriptError signal: self contents! !!PjMessageEvaluationResponse methodsFor: 'printing'!contentsDescription	<javascript: 'return JSON.stringify(this.contents)'>		^ contents displayString! !!PjMessageEvaluationResponse methodsFor: 'public'!contentsObject	<pharoJsSkip>		^ self contents isString		  ifTrue: [ PjSTONReader from: self contents ]		  ifFalse: [ self contents ]! !!PjMessageEvaluationResponse methodsFor: 'public'!getValueWithBridge: aBridge	<PjTodo: 'Too much testing going here, further refactoring needed'>		| value |	value := self contentsObject.	value isLiteral ifTrue: [ ^ value ].	value isNumber ifTrue: [ ^ value ].	value isDictionary ifTrue: [ value isEmpty ifTrue: [ ^ nil ] ].	(value isKindOf: PjProxyInfo) ifTrue: [ 		^ value proxyForBridge: aBridge ].	Error signal: 'unrecognized response from browser:' , contents! !!PjMessageEvaluationResponse methodsFor: 'printing'!logDescription	^ String streamContents: [ :ws | 		  ws nextPutAll: self class name.		  ws nextPutAll: ' id: '.		  ws nextPutAll: self id asString.		  ws nextPutAll: ' inResponseToId: '.		  ws nextPutAll: (self inResponseToId				   ifNotNil: [ :aNumber | aNumber asString ]				   ifNil: [ '-' ]).		  ws nextPutAll: ' contents: '.		  ws nextPutAll: self contentsDescription ]! !!PjMessageEvaluationResponse methodsFor: 'printing'!printOn: ws	<pharoJsSkip>		super printOn: ws.	ws space.	ws << 'ir2id: '.	ws << (self inResponseToId ifNil: [ '-' ]).	ws << 'contents: '.	ws << self contentsDescription! !!PjMessageGetKeysResponse methodsFor: 'public'!getValueWithBridge: aBridge	^ self contents! !!PjMessageGetKeysResponse methodsFor: 'printing'!logDescription	^ String streamContents: [ :ws | 		  ws			  nextPutAll: self class name;			  nextPutAll: ' id: ';			  nextPutAll: self id asString;			  nextPutAll: ' inResponseToId: ';			  nextPutAll: (self inResponseToId					   ifNotNil: [ :aNumber | aNumber asString ]					   ifNil: [ '-' ]);			  nextPutAll: ' contents: ';			  nextPutAll: self contents size asString;			  nextPutAll: ' key-value pairs' ]! !!PjMessageGetKeysResponse methodsFor: 'printing'!printOn: ws	<pharoJsSkip>		super printOn: ws.	ws space.	ws << 'ir2id: '.	ws << (self inResponseToId ifNil: [ '-' ]).	ws space.	ws << self contents! !!PjMessageCallback methodsFor: 'accessing'!eventProxyInfo	^ eventProxyInfo! !!PjMessageCallback methodsFor: 'accessing'!eventProxyInfo: anObject	eventProxyInfo := anObject! !!PjMessageCallback methodsFor: 'accessing'!eventTargetProxyInfo	^ eventTargetProxyInfo! !!PjMessageCallback methodsFor: 'accessing'!eventTargetProxyInfo: anObject	eventTargetProxyInfo := anObject! !!PjMessageCallback methodsFor: 'testing'!isCallback	^ true! !!PjMessageCallback methodsFor: 'printing'!logDescription	^ String streamContents: [ :ws | 		  ws nextPutAll: self class name.		  ws nextPutAll: ' id: '.		  ws nextPutAll: self id asString.		  ws nextPutAll: ' '.		  self printDetailsOn: ws ]! !!PjMessageCallback methodsFor: 'printing'!printDetailsOn: ws	ws nextPutAll: ' rcvr: '.	ws nextPutAll: (self receiverProxyInfo			 ifNotNil: [ :pi | pi logDescription ]			 ifNil: [ '-' ]).	ws nextPutAll: ' event: '.	ws nextPutAll: (self eventProxyInfo			 ifNotNil: [ :pi | pi logDescription ]			 ifNil: [ '-' ])! !!PjMessageCallback methodsFor: 'printing'!printOn: ws	<pharoJsSkip>		super printOn: ws.	ws space.	self printDetailsOn: ws! !!PjMessageCallback methodsFor: 'public'!processCallbackWithBridge: aBridge	<pharoJsSkip>		| proxy eventProxy eventTargetProxy |	proxy := self receiverProxyInfo proxyForBridge: aBridge.	eventProxy := self eventProxyInfo proxyForBridge: aBridge.	eventTargetProxy := self eventTargetProxyInfo ifNotNil: [ :pi | 		                    pi proxyForBridge: aBridge ].	proxy runBlockClosure: eventProxy with: eventTargetProxy! !!PjMessageCallback methodsFor: 'accessing'!receiverProxyInfo	^ receiverProxyInfo! !!PjMessageCallback methodsFor: 'accessing'!receiverProxyInfo: anObject	receiverProxyInfo := anObject! !!PjMessageInspect methodsFor: 'testing'!isCallback	^ true! !!PjMessageInspect methodsFor: 'public'!processCallbackWithBridge: aBridge	<pharoJsSkip>		(self serverObjectForSubjectWithBridge: aBridge) inspect! !!PjMessageInspect methodsFor: 'public'!serverObjectForSubjectWithBridge: aBridge	<pharoJsSkip>		subjectProxyInfo isLiteral ifTrue: [ ^ subjectProxyInfo ].	subjectProxyInfo isNumber ifTrue: [ ^ subjectProxyInfo ].	^ subjectProxyInfo proxyForBridge: aBridge! !!PjMessageInspect methodsFor: 'accessing'!subjectProxyInfo	^ subjectProxyInfo! !!PjMessageInspect methodsFor: 'accessing'!subjectProxyInfo: anObject	subjectProxyInfo := anObject! !!PjMessageSetClientId methodsFor: 'accessing'!clientId	^ clientId! !!PjMessageSetClientId methodsFor: 'accessing'!clientId: anObject	clientId := anObject! !!PjMessageSetClientId methodsFor: 'testing'!isCallback	^ false! !!PjMessageSetClientId methodsFor: 'printing'!logDescription	^ String streamContents: [ :ws | 		  ws nextPutAll: self class name.		  ws nextPutAll: ' id: '.		  ws nextPutAll: self id asString.		  ws nextPutAll: ' clientId: '.		  ws nextPutAll: self clientId ]! !!PjMessageSetClientId methodsFor: 'testing'!needsToBeQueued	^ false! !!PjMessageSetClientId methodsFor: 'testing'!processWithBridge: aBridge	aBridge client clientId: self clientId! !!PjMessageSetClientId methodsFor: 'testing'!shouldEvaluateImmediately	^ true! !!PjMessageDeleteGlobalVar class methodsFor: 'instance creation'!newForVarName: jsName	^ self new		  varName: jsName;		  yourself! !!PjMessageDeleteGlobalVar methodsFor: 'public'!evaluateInContext: aMessageContext	<PjTodo: 'should use PjProxyInfo'>		PjProxyManager deleteGlobalVarNamed: self varName! !!PjMessageDeleteGlobalVar methodsFor: 'public'!logDescription	^ String streamContents: [ :ws | 		  ws nextPutAll: self class name.		  ws nextPutAll: ' id: '.		  ws nextPutAll:			  (self id ifNil: [ '-' ] ifNotNil: [ self id printString ]).		  ws nextPutAll: ' varName: '.		  ws nextPutAll: self varName ]! !!PjMessageDeleteGlobalVar methodsFor: 'accessing'!varName	^ varName! !!PjMessageDeleteGlobalVar methodsFor: 'accessing'!varName: anObject	varName := anObject! !!PjMessageEvaluateJavascript methodsFor: 'public'!evaluateInContext: aMessageContext	self		setTimeout: [ self evaluateInContextPrivate: aMessageContext ]		afterMilliseconds: 0! !!PjMessageEvaluateJavascript methodsFor: 'private'!evaluateInContextPrivate: aMessageContext	| responseMsg |	responseMsg := [ 	               PjMessageEvaluationResponse newWithContents:		               (self evaluateJsString: contents) ]		               on: Error		               do: [ :ex | 		               PjMessageErrorResponse newWithContents: ex message ].	responseMsg inResponseToId: self id.	aMessageContext websocketDelegate tryToSendMessage: responseMsg! !!PjMessageEvaluateJavascript methodsFor: 'public'!evaluateJsString: aString	| resultObject resultString |	resultObject := (global eval: aString) ifNotNil: [ :result | 		                result proxyResponse ].	resultObject class == PjProxyInfo ifTrue: [ ^ resultObject ].	resultString := JSON stringify: resultObject.	resultObject ifNotNil: [ 		resultString = 'null' ifTrue: [ 			resultString := resultObject toString ] ].	resultString ifNil: [ resultString := 'null' ].	^ resultString! !!PjMessageGetKeys methodsFor: 'public'!evaluateInContext: aMessageContext	| wsd responseMsg jsObject assocs |	wsd := aMessageContext websocketDelegate.	responseMsg := PjMessageGetKeysResponse newWithId.	jsObject := global instVarNamed: self proxyInfo globalName.	console log: 'get keys object:' with: jsObject.	assocs := self keyValuePairsOf: jsObject.	console log: 'get keys assocs:' with: assocs.	responseMsg contents: assocs.	responseMsg inResponseToId: self id.	wsd tryToSendMessage: responseMsg! !!PjMessageGetKeys methodsFor: 'public'!keyValuePairsOf: anObject	| results |	results := OrderedCollection new.	anObject allEnumeratableKeysDo: [ :key | 		| value |		value := anObject instVarNamed: key.		results add: key -> (JSON stringify: value) ].	^ results! !!PjMessageGetKeys methodsFor: 'printing'!logDescription	^ String streamContents: [ :ws | 		  ws nextPutAll: self class name.		  ws nextPutAll: ' id: '.		  ws nextPutAll: self id printString.		  self proxyInfo ifNotNil: [ :pi | 			  ws nextPutAll: ' proxyInfo: '.			  ws nextPutAll: pi logDescription ] ]! !!PjMessageGetKeys methodsFor: 'accessing'!proxyInfo	^ proxyInfo! !!PjMessageGetKeys methodsFor: 'accessing'!proxyInfo: anObject	proxyInfo := anObject! !!PjMessageMakeBlockClosureProxy methodsFor: 'public'!evaluateInContext: aMessageContext	| aProxyInfo responseMsg |	aProxyInfo := PjProxyManager		              makeBlockClosureProxy: self includeEventTarget		              stopPropagation: self stopPropagation		              for: aMessageContext websocketDelegate.	responseMsg := PjMessageEvaluationResponse newWithContents:		               aProxyInfo.	responseMsg inResponseToId: self id.	aMessageContext websocketDelegate tryToSendMessage: responseMsg! !!PjMessageMakeBlockClosureProxy methodsFor: 'accessing'!includeEventTarget	^ includeEventTarget! !!PjMessageMakeBlockClosureProxy methodsFor: 'accessing'!includeEventTarget: anObject	includeEventTarget := anObject! !!PjMessageMakeBlockClosureProxy methodsFor: 'initialization'!initialize	super initialize.	stopPropagation := true.	includeEventTarget := false! !!PjMessageMakeBlockClosureProxy methodsFor: 'accessing'!stopPropagation	^ stopPropagation! !!PjMessageMakeBlockClosureProxy methodsFor: 'accessing'!stopPropagation: anObject	stopPropagation := anObject! !!PjMessageReload methodsFor: 'public'!evaluateInContext: aMessageContext	aMessageContext websocketDelegate class reload! !!PjMessageS2c methodsFor: 'public'!evaluateInContext: aMessageContext	self subclassResponsibility! !!PjMessageSetEventListener methodsFor: 'public'!evaluateInContext: aMessageContext	| result responseMsg |	result := self evaluateInContextPrivate: aMessageContext.	responseMsg := PjMessageEvaluationResponse newWithContents:		               result proxyResponse.	responseMsg inResponseToId: self id.	aMessageContext websocketDelegate tryToSendMessage: responseMsg! !!PjMessageSetEventListener methodsFor: 'public'!evaluateInContextPrivate: aMessageContext	| targetObject listener fullTriggerName oldlistener |	fullTriggerName := 'on' , self eventName.	targetObject := self targetProxyInfo getJsObject.	listener := self listenerProxyInfo ifNotNil: [ :pi | pi getJsObject ].	oldlistener := targetObject instVarNamed: fullTriggerName.	targetObject instVarNamed: fullTriggerName put: listener.	listener ifNotNil: [ 		(listener hasOwnProperty: '$PjRefCount') ifTrue: [ 			| currRefCnt |			currRefCnt := listener instVarNamed: '$PjRefCount'.			listener instVarNamed: '$PjRefCount' put: currRefCnt + 1 ] ].	oldlistener ifNotNil: [ 		| currRefCnt |		currRefCnt := oldlistener instVarNamed: '$PjRefCount'.		currRefCnt > 0 ifTrue: [ 			oldlistener instVarNamed: '$PjRefCount' put: currRefCnt - 1.			(oldlistener instVarNamed: '$PjRefCount') == 0 ifTrue: [ 				oldlistener instVarNamed: '$PjProxyRemove' put: true.				^ oldlistener ] ] ].	^ 'true'! !!PjMessageSetEventListener methodsFor: 'accessing'!eventName	^ eventName! !!PjMessageSetEventListener methodsFor: 'accessing'!eventName: anObject	eventName := anObject! !!PjMessageSetEventListener methodsFor: 'accessing'!listenerProxyInfo	^ listenerProxyInfo! !!PjMessageSetEventListener methodsFor: 'accessing'!listenerProxyInfo: anObject	listenerProxyInfo := anObject! !!PjMessageSetEventListener methodsFor: 'accessing'!targetProxyInfo	^ targetProxyInfo! !!PjMessageSetEventListener methodsFor: 'accessing'!targetProxyInfo: anObject	targetProxyInfo := anObject! !!PjMessageTerminate methodsFor: 'public'!evaluateInContext: aMessageContext	aMessageContext websocketDelegate class terminate! !!WBWindowsWebBrowser class methodsFor: '*PharoJs-Base-Bridge'!openBrowser: browserName on: anURLString inBackground: backgroundFlag	"Open the webbrowser on the given URL	self openBrowser: 'Firefox' on: 'http://pharojs.org' inBackground: false.	if the browserName is nil, open the default browser.	self openBrowser: nil on: 'http://pharojs.org' inBackground: false.	The backgroundFlag is true when the window of the browser should open behind the Pharo window.	"	(browserName isNil or: [ backgroundFlag not ]) ifTrue: [ 		^ WebBrowser openOn: anURLString ].	^ self		  shellExecute: 'open'		  file: browserName asLowercase		  parameters: anURLString		  directory: ''		  show: 5 "SW_SHOW"! !!WBWindowsWebBrowser class methodsFor: '*PharoJs-Base-Bridge'!openTerminalWithNodeOn: theFileName inFolder: anObject	self		shellExecute: 'open'		file: 'node'		parameters: theFileName		directory: ''		show: 5 "SW_SHOW"! !!PjApplication class methodsFor: '*PharoJs-Base-Bridge-App'!bridge	<pharoJsSkip>	^ PjBridge bridgeForAppClass: self! !!PjApplication class methodsFor: '*PharoJs-Base-Bridge-App'!bridgeAddress	<pharoJsSkip>	^ '127.0.0.1'! !!PjApplication class methodsFor: '*PharoJs-Base-Bridge-App'!bridgeClass	<pharoJsSkip>	^ PjBridge! !!PjApplication class methodsFor: '*PharoJs-Base-Bridge-App'!bridgeClientClass	<pharoJsSkip>	self subclassResponsibility! !!PjApplication class methodsFor: '*PharoJs-Base-Bridge-App'!bridgeForDebug	<pharoJsSkip>	^ self bridge enableClientLogging! !!PjApplication class methodsFor: '*PharoJs-Base-Bridge-App'!newBridgeClient	<pharoJsSkip>	^self bridgeClientClass newWithAppClass: self! !!PjServer class methodsFor: 'accessing'!portsCurrentlyInUse	^(self allInstances select: #isRunning thenCollect: #port) asSet! !!PjServer class methodsFor: 'accessing'!webSocketUrlTag	^'javascript-bridge'! !!PjServer methodsFor: 'request handling'!basicExecutePlainRequest: request sendResponseThrough: stream	| response |	ZnCurrentServer value: self during: [ 		response := self handleRequest: request timing: timing.		response setConnectionClose.		self writeResponse: response on: stream timing: timing ]! !!PjServer methodsFor: 'accessing'!css	^self delegate css! !!PjServer methodsFor: 'accessing'!css: jsString	self delegate css: jsString! !!PjServer methodsFor: 'initialization'!delegateClass	^ PjParametrizableServerDelegate! !!PjServer methodsFor: 'public'!ensureProcessAlive	self isProcessDead ifFalse: [ ^ self ].	super start! !!PjServer methodsFor: 'request handling'!executePlainRequest: request sendReponseThrough: stream and: socket	[ 	[ self basicExecutePlainRequest: request sendResponseThrough: stream ] 		ensure: [ 			self logConnectionClosed: stream.			stream close ] ] ifCurtailed: [ 		self logServerGeneric: 'Destroying socket'.		socket destroy ]! !!PjServer methodsFor: 'accessing'!favicon	^self delegate favicon! !!PjServer methodsFor: 'accessing'!favicon: jsString	self delegate favicon: jsString! !!PjServer methodsFor: 'accessing'!fingerPrint	^self delegate fingerPrint! !!PjServer methodsFor: 'request handling'!handleRequest: request forWebSocketOn: stream	| acceptKey response |	acceptKey := ZnWebSocketUtils handshake:		             (request headers at: 'Sec-WebSocket-Key').	response := ZnWebSocketResponse new		            statusLine: (ZnStatusLine code: 101);		            headers: (self responseHeadersForKey: acceptKey);		            continuation: [ :aWebSocket | webSocket := aWebSocket ].	self augmentResponse: response forRequest: request.	self writeResponse: response on: stream timing: timing.	response useConnection: stream! !!PjServer methodsFor: 'accessing'!html	^self delegate html! !!PjServer methodsFor: 'accessing'!html: htmlString	self delegate html: htmlString! !!PjServer methodsFor: 'initialization'!initialize	super initialize.	self delegate: self delegateClass new! !!PjServer methodsFor: 'testing'!isProcessDead	^ self process isNil or: [ 		  self process isTerminating or: [ self process isTerminated ] ]! !!PjServer methodsFor: 'initialization'!isWebSocketConnected	self webSocket ifNil: [ ^ false ].	^ self webSocket isConnected! !!PjServer methodsFor: 'accessing'!javascript	^self delegate javascript! !!PjServer methodsFor: 'accessing'!javascript: jsString	self delegate javascript: jsString! !!PjServer methodsFor: 'logging'!logSocketRead: aString	logLevel < 4 ifTrue: [ ^ self ].	(self newLogEvent: PjSocketLogEvent)		direction: 'read';		contents: aString;		emit! !!PjServer methodsFor: 'logging'!logSocketWritten: aString	logLevel < 4 ifTrue: [ ^ self ].	(self newLogEvent: PjSocketLogEvent)		direction: 'wrote';		contents: aString;		emit! !!PjServer methodsFor: 'logging'!loggingOn	logLevel := 4 " extended for websocket tracking "! !!PjServer methodsFor: 'accessing'!maxPortNumber	^65535! !!PjServer methodsFor: 'accessing'!minPortNumber	^1024! !!PjServer methodsFor: 'accessing'!nextPortNumber	LastUsedPort ifNil: [ ^LastUsedPort := self minPortNumber ].	LastUsedPort = self maxPortNumber ifTrue: [^LastUsedPort := self minPortNumber].	LastUsedPort := LastUsedPort + 1.	^LastUsedPort! !!PjServer methodsFor: 'request handling'!responseHeadersForKey: key	"Return the headers for a WebSocket setup response, given key"	^ ZnHeaders defaultResponseHeaders		  at: 'Upgrade' put: 'websocket';		  at: 'Connection' put: 'Upgrade';		  at: 'Sec-WebSocket-Accept' put: key;		  yourself! !!PjServer methodsFor: 'request handling'!serveConnectionOn: listeningSocket	"We wait up to acceptWaitTimeout seconds for an incoming connection.	If we get one we wrap it in a SocketStream and #executeOneRequestResponseOn: on it.	We do not fork a worker thread/process but stay in the current one for just one request/response cycle."	| socket stream request |	socket := listeningSocket waitForAcceptFor: self acceptWaitTimeout.	socket ifNil: [ ^ self noteAcceptWaitTimedOut ].	stream := self socketStreamOn: socket.	timing := ZnServerTransactionTiming new.	request := self readRequest: stream timing: timing.	(request relativeUrl path endsWith: self webSocketUrlTag) ifTrue: [ 		^ self handleRequest: request forWebSocketOn: stream ].	self		executePlainRequest: request		sendReponseThrough: stream		and: socket! !!PjServer methodsFor: 'public'!start	| candidatePort usedPorts |	usedPorts := self class portsCurrentlyInUse.	[ 	candidatePort := self nextPortNumber.	usedPorts includes: candidatePort ] whileTrue.	self startOnPort: candidatePort! !!PjServer methodsFor: 'public'!startOnPort: aPort	self port: aPort.	super start! !!PjServer methodsFor: 'public'!stop	self stopWebSocket.	super stop! !!PjServer methodsFor: 'initialization'!stopWebSocket	self webSocket ifNil: [ ^ self ].	self webSocket isConnected ifFalse: [ ^ self ].	[ self webSocket close ]		on: ConnectionTimedOut		do: [ " nothing: the socket's gone away " ]! !!PjServer methodsFor: 'accessing'!urlString	^self url asString! !!PjServer methodsFor: 'accessing'!webSocket	^webSocket! !!PjServer methodsFor: 'accessing'!webSocketUrlTag	^self class webSocketUrlTag! !!PjSTONReader class methodsFor: 'instance creation'!from: readStreamOrString	^ self new		  on: readStreamOrString readStream;		  next! !!PjSTONReader methodsFor: 'private'!isClassStartChar: char	^ false! !!PjSTONReader methodsFor: 'parsing-internal'!parseConstantDo: block	readStream peek = $I ifTrue: [ 		^ self match: 'Infinity' do: [ block value: Float infinity ] ].	readStream peek = $- ifTrue: [ 		^ self			  match: '-Infinity'			  do: [ block value: Float infinity negated ] ].	readStream peek = $N ifTrue: [ 		^ self match: 'NaN' do: [ block value: Float nan ] ].	super parseConstantDo: block! !!PjSTONReader methodsFor: 'parsing-internal'!parseNumberInteger	readStream peek = $I ifTrue: [ 		self parseConstantDo: [ :val | ^ val ] ].	^ super parseNumberInteger! !!WBUnixWebBrowser class methodsFor: '*PharoJs-Base-Bridge'!openBrowser: browserName on: anURLString inBackground: backgroundFlag	"Open the webbrowser on the given URL	self openBrowser: 'Firefox' on: 'http://pharojs.org' inBackground: false.	if the browserName is nil, open the default browser.	self openBrowser: nil on: 'http://pharojs.org' inBackground: false.	The backgroundFlag is true when the window of the browser should open behind the Pharo window.	"	| openCommand |	(browserName isNil or: [ backgroundFlag not ])		ifTrue: [ ^ WebBrowser openOn: anURLString ].	openCommand := '{1} {2} &'		format:			{browserName asLowercase.			anURLString}.	self system: openCommand! !!WBUnixWebBrowser class methodsFor: '*PharoJs-Base-Bridge'!openTerminalWithNodeOn: theFileName inFolder: anObject	self system: ('node {1} &' format: { theFileName })! !!WebBrowser class methodsFor: '*PharoJs-Base-Bridge'!openBrowser: browserName on: anURLString inBackground: backgroundFlag	"Open the webbrowser on the given URL	self openBrowser: 'Firefox' on: 'http://pharojs.org' inBackground: false.	if the browserName is nil, open the default browser.	self openBrowser: nil on: 'http://pharojs.org' inBackground: false.	The backgroundFlag is true when the window of the browser should open behind the Pharo window.	"	^ self webbrowserClassForPlatform		openBrowser: browserName		on: anURLString		inBackground: backgroundFlag! !!WebBrowser class methodsFor: '*PharoJs-Base-Bridge'!openInBackgroundUrl: anURLString	^ self openOn: anURLString inBackground: true! !!WebBrowser class methodsFor: '*PharoJs-Base-Bridge'!openOn: anURLString inBackground: backgroundFlag	"Open the webbrowser on the given URL	self openOn: 'http://pharojs.org' inBackground: false.	The backgroundFlag is true when the window of the browser should open behind the Pharo window.	"	self openBrowser: nil on: anURLString inBackground: backgroundFlag! !!WebBrowser class methodsFor: '*PharoJs-Base-Bridge'!openTerminalWithNodeOn: theFileName inFolder: theFolder	"Open a terminal with node running on the given file"	^ self webbrowserClassForPlatform		openTerminalWithNodeOn: theFileName		inFolder: theFolder! !!PjDOMApplication class methodsFor: '*PharoJs-Base-Bridge-App'!css		" might want to override with:	^ self cssFromFile	"	<pharoJsSkip>		^ nil! !!PjDOMApplication class methodsFor: '*PharoJs-Base-Bridge-App'!cssFile: anObject	<pharoJsSkip>		cssFile := anObject! !!PjDOMApplication class methodsFor: '*PharoJs-Base-Bridge-App'!favicon	<pharoJsSkip>		^ nil! !!PjDOMApplication class methodsFor: '*PharoJs-Base-Bridge-App'!generateHtmlUsing: aPjHtmlGenerator	<pharoJsSkip>		^ false	" consider overriding with '^ self generateHtmlFromFileUsing: aPjHtmlGenerator' "! !!PjDOMApplication class methodsFor: '*PharoJs-Base-Bridge-App'!htmlFile: anObject	<pharoJsSkip>		htmlFile := anObject! !!PjJavascriptMessage class methodsFor: 'instance creation'!receiverId: receiverId selector: selector arguments: arguments	^ (self selector: selector arguments: arguments)		  receiverId: receiverId;		  yourself! !!PjJavascriptMessage methodsFor: 'converting'!asJsAstUsing: aConverter	^ aConverter convertJavascriptMessage: self! !!PjJavascriptMessage methodsFor: 'converting'!convertToJsUsing: aTranspiler	aTranspiler convertJavascriptMessage: self! !!PjJavascriptMessage methodsFor: 'accessing'!receiverId	^ receiverId! !!PjJavascriptMessage methodsFor: 'accessing'!receiverId: anObject	receiverId := anObject! !!PjJavascriptGlobals class methodsFor: '*PharoJs-Base-Bridge'!ensureProxyForGlobal: varName	| binding |	binding := super localBindingOf: varName.	binding value ifNotNil: [ ^ binding ].	self initProxyForGlobal: varName! !!PjJavascriptGlobals class methodsFor: '*PharoJs-Base-Bridge'!initProxyForGlobal: varName	| newProxy |	(self classVarNames includes: varName) ifFalse: [ ^ self ].	newProxy := PjProxyForGlobal newProxyNamed: varName.	self classVarNamed: varName put: newProxy! !!PjJavascriptGlobals class methodsFor: '*PharoJs-Base-Bridge'!localBindingOf: varName	self ensureProxyForGlobal: varName.	^ super localBindingOf: varName! !!PjTranspiler methodsFor: '*PharoJs-Base-Bridge'!convertJavascriptMessage: aJavascriptMessage	| jsAst |	jsAst := converter convertJavascriptMessage: aJavascriptMessage.	self generateCodeStringFrom: jsAst! !!PjFileBasedWebApp class methodsFor: '*PharoJs-Base-Bridge-App'!bridgeClientClass	<pharoJsSkip>		^ PjFileBasedBrowserBridgeClient! !!String methodsFor: '*PharoJs-Base-Bridge'!asRawJSONString	^ self! !"PharoJs-Base-Bridge"!!PjTAppFolderSharingSubclass commentStamp: '' prior: 0!This trait is useful when defining a hierarchy of classes that rely on the same HTML and related files (CSS, third party JS, ...). The JS is exported in the same folder as its superclass.This is useful for example for  test purpose. A subclass  can be defined for enabling tests using mocks,Another use is when defining variants of  the  same app, typically for experiment purpose.!!PjTAppRunsInJS commentStamp: '' prior: 0!This trait makes a test case export the app under test to JS and control it remotely on the JS interpreter.!!PjTAppRunsInPharo commentStamp: '' prior: 0!This trait makes a test case run the app under test on the Pharo VM. Only third party JS code and DOM objects are run on the JS interpreter!!PjAppWrapperForRunningInPharo commentStamp: '' prior: 0!It is important to have the behavior at the class side because the transpiler relies on the AST global node for classes.!!PjTAppFolderSharingSubclass classTrait methodsFor: 'exporting'!appFolder	<pharoJsSkip>	^self superclass appFolder! !!PjTAppRunsInJS methodsFor: 'accessing'!appClassToExport	^self appClass! !!PjTAppRunsInJS methodsFor: 'accessing'!currentApp	^ self bridge		  evalSelector: #currentInstance		  sentTo: self appClass name! !!PjTAppRunsInPharo methodsFor: 'accessing'!appClassToExport	^PjAppWrapperForRunningInPharo on: self appClass! !!PjTAppRunsInPharo methodsFor: 'accessing'!currentApp	^self appClass		start; 		currentInstance.! !!PjTWaitUntilReady methodsFor: 'waiting'!defaultTimeOutActionBlock	^[ self fail ]! !!PjTWaitUntilReady methodsFor: 'waiting'!defaultWaitTimeOutDuration 	^2 seconds! !!PjTWaitUntilReady methodsFor: 'waiting'!stepDuration	^100 milliSeconds! !!PjTWaitUntilReady methodsFor: 'waiting'!waitUntil: conditionBlock	self waitUntil: conditionBlock timeOut: self defaultWaitTimeOutDuration! !!PjTWaitUntilReady methodsFor: 'waiting'!waitUntil: conditionBlock timeOut: maxToWait 	self		waitUntil: conditionBlock 		timeOut: maxToWait 		ifTimeOutDo: self defaultTimeOutActionBlock! !!PjTWaitUntilReady methodsFor: 'waiting'!waitUntil: conditionBlock timeOut: maxToWait ifTimeOutDo: timeOutBlock	self		waitWhile: [conditionBlock value not] 		timeOut: maxToWait 		ifTimeOutDo: timeOutBlock! !!PjTWaitUntilReady methodsFor: 'waiting'!waitWhile: conditionBlock	self waitWhile: conditionBlock timeOut: self defaultWaitTimeOutDuration! !!PjTWaitUntilReady methodsFor: 'waiting'!waitWhile: conditionBlock timeOut: maxToWait 	self		waitWhile: conditionBlock 		timeOut: maxToWait 		ifTimeOutDo: self defaultTimeOutActionBlock! !!PjTWaitUntilReady methodsFor: 'waiting'!waitWhile: conditionBlock timeOut: maxToWait ifTimeOutDo: timeOutBlock	| totalWaited |	totalWaited := 0 second.	[totalWaited < maxToWait and: conditionBlock] whileTrue: [		self stepDuration wait.		totalWaited := totalWaited + self stepDuration].	totalWaited >= maxToWait ifTrue: timeOutBlock! !!PjTWebAppTestCase methodsFor: 'asserting'!assertInnerHtmlOfElement: domElement equals: expectedValue	self assert: domElement innerHTML equals: expectedValue! !!PjTWebAppTestCase methodsFor: 'asserting'!assertInnerHtmlOfElementById: id equals: expectedValue	self		assertInnerHtmlOfElement: (self document getElementById: id)		equals: expectedValue! !!PjTWebAppTestCase methodsFor: 'asserting'!assertValueOfElement: domElement equals: expectedValue	self assert: domElement value equals: expectedValue! !!PjTWebAppTestCase methodsFor: 'asserting'!assertValueOfElementById: id equals: expectedValue	self		assertValueOfElement: (self document getElementById: id)		equals: expectedValue! !!PjTWebAppTestCase methodsFor: 'UI handling'!changeElement: domElement value: newValue	domElement value: newValue.	self dispatchEvent: #change to: domElement.! !!PjTWebAppTestCase methodsFor: 'UI handling'!changeElementById: anId value: newValue	self changeElement: (self document getElementById: anId) value: newValue! !!PjTWebAppTestCase methodsFor: 'UI handling'!clickElement: domElement 	self dispatchEvent: #click to: domElement.! !!PjTWebAppTestCase methodsFor: 'UI handling'!clickElementById: aString	self clickElement: (self document getElementById: aString)! !!PjTWebAppTestCase methodsFor: 'UI handling'!dispatchEvent: eventName to: htmlElement	htmlElement dispatchEvent: (self newEvent: eventName)! !!PjTWebAppTestCase methodsFor: 'accessing'!document	self explicitRequirement ! !!PjTWebAppTestCase methodsFor: 'UI handling'!newEvent: eventName	| event |	event := self document createEvent: #HTMLEvents.	event initEvent: eventName with: true with: true.	^ event! !!PjTWebClientAppTestCase methodsFor: 'running'!debugBridgeResourceClass	^ self	defaultBridgeResourceClass! !!PjTWebClientAppTestCase methodsFor: 'accessing'!defaultBridgeResourceClass	^ PjWebClientAppBridgeTestResource! !!PjTWebClientAppTestCase methodsFor: 'initialization'!serverAppClass	^ self appClass serverAppClass! !!PjTWebClientAppTestCase methodsFor: 'initialization'!urlPathString	self explicitRequirement ! !!PjTWebServerApiTestCase methodsFor: 'tests'!get: pathString	^ ZnEasy get: self rootUrlString , pathString! !!PjTWebServerApiTestCase methodsFor: 'tests'!port	^self app port! !!PjTWebServerApiTestCase methodsFor: 'tests'!post: pathString text: aString	^ ZnEasy		  post: self rootUrlString , pathString		  data: (ZnEntity text: aString)! !!PjTWebServerApiTestCase methodsFor: 'tests'!rootUrlString	^rootUrlString ifNil: [rootUrlString := 'http://localhost:' , self port asString]! !!PjAppTestCaseTest methodsFor: 'assertions'!assertHasArrayAPI: jsArrayLikeClass	self assert: (jsArrayLikeClass prototype js_hasOwnProperty: '_first')! !!PjAppTestCaseTest methodsFor: 'private'!resetBridgeTestResources	{PjBridgeTestResource. PjDebugBridgeTestResource} do: [ : resourceClass |		resourceClass reset.		resourceClass allInstancesDo: [: subInstance | subInstance tearDown]	]! !!PjAppTestCaseTest methodsFor: 'running'!setUp	super setUp.	self resetBridgeTestResources! !!PjAppTestCaseTest methodsFor: 'running'!tearDown	super tearDown.	self resetBridgeTestResources! !!PjAppTestCaseTest methodsFor: 'tests'!testDebug	| suite |	3 timesRepeat: [		suite := PjMinimalFileBasedWebAppTest buildSuite.		suite debug.		suite tests do: [: test | self assert: test bridgeResourceClass == PjDebugBridgeTestResource].		self assert: PjDebugBridgeTestResource current bridge isNil.		self assert: PjBridgeTestResource current bridge isNil.	].! !!PjAppTestCaseTest methodsFor: 'tests'!testExportedCodeOfAppRunningJsSideIsComplete	| remoteAppClass bridge jsMessage |	PjBridgeTestResource availableFor: PjNonMinmialAppRunningOnJsTest suite tests anyOne.	bridge := PjBridgeTestResource current bridge.	self assert: PjNonMinmialAppRunningOnJsTest appClass == PjHtmlGeneratingCounterApp.	jsMessage := PjJavascriptMessage receiverId: #Smalltalk selector: #at: arguments: {PjNonMinmialAppRunningOnJsTest appClass name}.	remoteAppClass := bridge evalMessage: jsMessage.	self deny: remoteAppClass isNil.	self deny: remoteAppClass currentInstance isNil! !!PjAppTestCaseTest methodsFor: 'tests'!testExportedCodeOfAppRunningPharoSideIsMinimal	| bridge jsMessage jsSystemDict |	PjBridgeTestResource		availableFor: PjNonMinmialAppRunningOnPharoTest suite tests anyOne.	bridge := PjBridgeTestResource current bridge.	self assert: PjNonMinmialAppRunningOnPharoTest appClass equals: PjHtmlGeneratingCounterApp.	jsMessage := PjJavascriptMessage		receiverId: #Smalltalk		selector: #yourself		arguments: #().	jsSystemDict := bridge evalMessage: jsMessage.	self		assert: (jsSystemDict at: PjNonMinmialAppRunningOnJsTest appClass name) isNil.	#(Array NodeList HTMLCollection)		do: [ :jsArrayLikeClassName | 			| jsArrayLikeClass |			jsArrayLikeClass := jsSystemDict at: jsArrayLikeClassName.			self assertHasArrayAPI: jsArrayLikeClass ]! !!PjAppTestCaseTest methodsFor: 'tests'!testPlainRun	| result suite |	3 timesRepeat: [		suite := PjMinimalFileBasedWebAppTest buildSuite.		result := suite run.		self assert: result hasPassed.		suite tests do: [: test | self assert: test bridgeResourceClass == PjBridgeTestResource].		self assert: PjDebugBridgeTestResource current bridge isNil.		self assert: PjBridgeTestResource current bridge isNil.	]! !!TestCase methodsFor: '*PharoJs-TestFramework'!asTestSuite	^(self suiteClass named: self name asString)				addTest: self;				yourself! !!TestCase methodsFor: '*PharoJs-TestFramework'!shallowCopy	^ self class selector: testSelector! !!TestCase methodsFor: '*PharoJs-TestFramework'!suiteClass	^self class suiteClass.! !!PjAppTestCase class methodsFor: 'suite parameters'!appClass	^self subclassResponsibility! !!PjAppTestCase class methodsFor: 'testing'!isAbstract	^self == PjAppTestCase or: [		#(currentApp appClassToExport) anySatisfy: [: selector |			(self canUnderstand: selector) not] ].! !!PjAppTestCase methodsFor: 'accessing'!app	^app! !!PjAppTestCase methodsFor: 'accessing'!appClass	^self class appClass! !!PjAppTestCase methodsFor: 'testing'!assert: aBlock evaluatesTo: expectedResult	| actualResult |	actualResult := self evalBlock: aBlock.	self assert: actualResult equals: expectedResult.! !!PjAppTestCase methodsFor: 'testing'!assertBlock: aBlock 	self assert: aBlock evaluatesTo: true! !!PjAppTestCase methodsFor: 'testing'!assertSmalltalk: smalltalkExpressionString resultsInto: expected	| actual | 	actual := self eval: smalltalkExpressionString.	self assert: actual equals: expected.! !!PjAppTestCase methodsFor: 'accessing'!bridge	^self bridgeResource bridge! !!PjAppTestCase methodsFor: 'accessing'!bridgeResource	^ self bridgeResourceClass current! !!PjAppTestCase methodsFor: 'accessing'!bridgeResourceClass	^bridgeResourceClass ifNil: [ self defaultBridgeResourceClass ]! !!PjAppTestCase methodsFor: 'private'!cleanUpInstanceVariables	| ivsToReset |	ivsToReset := self class allInstVarNames copyWithoutAll: #(testSelector bridgeResourceClass).	ivsToReset do: [ :name |		self instVarNamed: name put: nil ]! !!PjAppTestCase methodsFor: 'running'!debug	bridgeResourceClass := self debugBridgeResourceClass.	^super debug! !!PjAppTestCase methodsFor: 'running'!debugBridgeResourceClass	^PjDebugBridgeTestResource! !!PjAppTestCase methodsFor: 'accessing'!defaultBridgeResourceClass	^PjBridgeTestResource! !!PjAppTestCase methodsFor: 'testing'!evalBlock: aBlock	^self bridge evalBlock: aBlock! !!PjAppTestCase methodsFor: 'testing'!resetApp	self bridge resetClient.	self resetInstanceVariables! !!PjAppTestCase methodsFor: 'testing'!resetInstanceVariables	app := self currentApp.! !!PjAppTestCase methodsFor: 'accessing'!resources	^super resources, {self bridgeResourceClass}! !!PjAppTestCase methodsFor: 'running'!runCaseAsFailure: aSemaphore	"Used for debug purpose. See TestCase>>#debugAsFailure"	bridgeResourceClass := self debugBridgeResourceClass.	super runCaseAsFailure: aSemaphore! !!PjAppTestCase methodsFor: 'running'!setUp	super setUp.	self waitWhile: [ self currentApp isNil ] timeOut: self timeOutForAppStartUp.	self resetInstanceVariables.! !!PjAppTestCase methodsFor: 'running'!tearDown	super tearDown.	self appClass resetCurrentInstance.	self bridge resetProxiesImmediately.	"bridgeResourceClass := nil"! !!PjAppTestCase methodsFor: 'testing'!timeOutForAppStartUp	^ 20 seconds! !!PjMinimalFileBasedWebAppTest class methodsFor: 'suite parameters'!appClass	^PjMinimalFileBasedWebApp.! !!PjMinimalFileBasedWebAppTest methodsFor: 'tests'!testAppReady	self assert: [1+2] evaluatesTo: 3! !!PjMinimalFileBasedWebAppTest methodsFor: 'tests'!testCounter	| jsCounter |	jsCounter := self evalBlock: [PjCounter new].	3 timesRepeat: [jsCounter increment].	self assert: jsCounter count equals: 3! !!PjMinimalFileBasedWebAppTest methodsFor: 'tests'!testCounterWithEvent	| counter button |	counter := PjCounter new.	button := document createElement: 'button'.	button textContent: 'increment'.	button addEventListener: #click block: [ counter increment ].	3 timesRepeat: [button click].	self assert: counter count equals: 3! !!PjMinimalFileBasedWebAppTest methodsFor: 'tests'!testCounterWithSerialization	| counter serializedCounter jsCounter |	counter := PjCounter new.	3 timesRepeat: [counter increment].	serializedCounter := counter asPhxJsonString.	self bridge loadClass: PjCounter.	jsCounter := self evalBlock: [PhxJsonReader readFromString: serializedCounter].	3 timesRepeat: [jsCounter increment].	self assert: counter count equals: 3.	self assert: jsCounter count equals: 6! !!PjMinimalFileBasedWebAppTest methodsFor: 'tests'!testResetApp	self evalBlock: [window instVarNamed:#forTest put: 3].	self assert: [window instVarNamed:#forTest] evaluatesTo: 3.	self resetApp.	self assert: [window instVarNamed:#forTest] evaluatesTo: nil.! !!PjNonMinmialAppRunningOnPharoTest class methodsFor: 'suite parameters'!appClass	^PjHtmlGeneratingCounterApp! !!PjNonMinmialAppRunningOnPharoTest methodsFor: 'testing'!testAlwaysSucceed	self assert: true! !!PjWebAppTestCase methodsFor: 'accessing'!document 		^document! !!PjBridgeTestResource class methodsFor: 'running'!appClassToExportFor: aTestAsserter	^aTestAsserter appClassToExport ! !!PjBridgeTestResource class methodsFor: 'running'!availableFor: aTestAsserter	super availableFor: aTestAsserter.	self ensureAppClassFor: aTestAsserter.	self current ensureFreshClient! !!PjBridgeTestResource class methodsFor: 'running'!ensureAppClassFor: aTestAsserter	self current appClass == aTestAsserter appClassToExport ifTrue: [ 		^ self ].	current := self new.	current initFrom: aTestAsserter! !!PjBridgeTestResource class methodsFor: 'accessing'!isClientBrowserOpenedInBackground	^OpenWebBrowserInBackground ifNil: [ false ]! !!PjBridgeTestResource class methodsFor: 'accessing'!isClientBrowserOpenedInBackground: aBoolean	^OpenWebBrowserInBackground := aBoolean ! !!PjBridgeTestResource class methodsFor: 'accessing'!setWebBrowserOpenedInBackground	<script>	self isClientBrowserOpenedInBackground: true! !!PjBridgeTestResource class methodsFor: 'accessing'!setWebBrowserOpenedInForeground	<script>	self isClientBrowserOpenedInBackground: false! !!PjBridgeTestResource methodsFor: 'accessing'!appClass	^appClass! !!PjBridgeTestResource methodsFor: 'accessing'!bridge	^ bridge! !!PjBridgeTestResource methodsFor: 'accessing'!bridge: aBridge	bridge := aBridge.! !!PjBridgeTestResource methodsFor: 'accessing'!bridgeForAppClass	^ appClass bridge! !!PjBridgeTestResource methodsFor: 'running'!ensureFreshClient	self bridge isConnected ifTrue: [ ^ self resetClient ].	self startJsInterpreter! !!PjBridgeTestResource methodsFor: 'initialization'!initBridge	self bridge: self bridgeForAppClass.	PjBridge soleBridge: self bridge! !!PjBridgeTestResource methodsFor: 'initialization'!initFrom: aTestAsserter	appClass := aTestAsserter appClassToExport.	appClass resetAppFolder.	self initBridge.	self bridge shouldStartJsInterpreter: false.	self setUpClient.	self startBridge: 		self bridge ! !!PjBridgeTestResource methodsFor: 'initialization'!initialize	super initialize.	self description: 'I manage a bridge dedicated to testing a PharoJS app'.	self name: 'PharoJS Bridge TestResource'.! !!PjBridgeTestResource methodsFor: 'running'!isClientBrowserOpenedInBackground	^self class isClientBrowserOpenedInBackground! !!PjBridgeTestResource methodsFor: 'running'!resetClient	self bridge resetClient! !!PjBridgeTestResource methodsFor: 'running'!setUpClient	^self bridge client openBrowserInBackground: self isClientBrowserOpenedInBackground! !!PjBridgeTestResource methodsFor: 'running'!startBridge: aBridge	"Avoid bridge resource process being killed by test runner.	So, we force DefaultExecutionEnvironment  instead of the implicit TestExecutionEnvironment "	DefaultExecutionEnvironment beActiveDuring: [ 		aBridge startWithoutWaitingForClient ]! !!PjBridgeTestResource methodsFor: 'running'!startJsInterpreter	self bridge startJsInterpreter	! !!PjBridgeTestResource methodsFor: 'running'!tearDown	super tearDown.	self bridge		ifNotNil: [ self bridge tearDown.			PjBridge soleBridge: nil ].	Smalltalk garbageCollect! !!PjDebugBridgeTestResource methodsFor: 'running'!ensureFreshClient	self startJsInterpreter! !!PjDebugBridgeTestResource methodsFor: 'running'!resetClient	self bridge resetClient! !!PjDebugBridgeTestResource methodsFor: 'running'!setUpClient	super setUpClient.	self bridge enableClientLogging! !!PjWebClientAppBridgeTestResource methodsFor: 'accessing'!bridgeForAppClass	| bridgeClient |	bridgeClient := PjWebServedBridgeClient 		                      newWithAppClass: self appClass.	^PjBridge		                bridgeForAppClass: self appClass		                client: bridgeClient.	! !!PjWebClientAppBridgeTestResource methodsFor: 'initialization'!initBridgeClientUrl	| serverApp serverPort |	serverApp := serverBridge		             evalSelector: #currentInstance		             sentTo: serverClassName.	serverPort := serverApp port.	self bridge client urlString:		'http://127.0.0.1:' , serverPort asString , urlPathString! !!PjWebClientAppBridgeTestResource methodsFor: 'initialization'!initFrom: aTestAsserter	serverBridge := aTestAsserter serverAppClass bridge.	serverClassName := aTestAsserter serverAppClass name.	urlPathString := aTestAsserter urlPathString.	serverBridge shouldStartJsInterpreter: false.	self startBridge: serverBridge.	super initFrom: aTestAsserter! !!PjWebClientAppBridgeTestResource methodsFor: 'running'!resetClient	super resetClient.	serverBridge resetClient.! !!PjWebClientAppBridgeTestResource methodsFor: 'running'!startJsInterpreter	serverBridge startJsInterpreter.	self initBridgeClientUrl.	super startJsInterpreter! !!PjWebClientAppBridgeTestResource methodsFor: 'running'!tearDown	serverBridge stop.	super tearDown.	! !!PjAppWrapperForRunningInPharo class methodsFor: 'description'!appClass	<pharoJsSkip>	^self! !!PjAppWrapperForRunningInPharo class methodsFor: 'description'!appClasses	<pharoJsSkip>	^currentAppClass appClasses copyWithout: currentAppClass.! !!PjAppWrapperForRunningInPharo class methodsFor: 'description'!appLaunchBlock	<pharoJsSkip>	^[]! !!PjAppWrapperForRunningInPharo class methodsFor: 'description'!appPackages	<pharoJsSkip>	^#()! !!PjAppWrapperForRunningInPharo class methodsFor: 'bridge handling'!bridge	<pharoJsSkip>	^ PjBridge bridgeForAppClass: self! !!PjAppWrapperForRunningInPharo class methodsFor: 'reflective operations'!doesNotUnderstand: aMessage	<pharoJsSkip>	^aMessage sendTo: currentAppClass! !!PjAppWrapperForRunningInPharo class methodsFor: 'bridge handling'!newBridgeClient	<pharoJsSkip>	^self bridgeClientClass newWithAppClass: self! !!PjAppWrapperForRunningInPharo class methodsFor: 'initialize - release'!on: appClass	<pharoJsSkip>	currentAppClass := appClass! !!PjAppWrapperForRunningInPharo class methodsFor: 'start-stop'!start	^self! !!PjAppWrapperForRunningInPharo class methodsFor: 'start-stop'!stop	^self! !"PharoJs-TestFramework"!!PjLoadForTest commentStamp: '' prior: 0!I am a small, non-app class used in some interactive, manual, tests!!ManifestPharoJsBaseBridgeTests commentStamp: '' prior: 0!I store metadata for this package. These meta data are used by other tools such as the SmalllintManifestChecker and the critics Browser!!PjTestBridge commentStamp: '' prior: 0!I am a bridge that doesn't actually communicate.I can be used to test the incremental code generation that goes with normal bridge operations.!!PjBridgeTestCase commentStamp: '' prior: 0!Start the browser with a minimal web page, then if debugging, give a version with a debugging log of the WebSocket traffic.Note that closing a web page doesn't work under Firefox unless you go, in the browser, to: 	about:configand change the field	dom.allow_scripts_to_close_windowsto true.Otherwise it will create over 100 windows if you run all the tests.!!PjASuperClass class methodsFor: 'accessing'!someString	^'Ultimate'! !!PjASuperClass methodsFor: 'accessing'!someNumber	^ 40! !!PjArrayClassExtensionForTest class methodsFor: 'pharoJs support'!javascriptName 	<pharoJsSkip>	^#Array! !!PjEmptyClassExtensionOfASuperClass class methodsFor: 'pharoJs support'!isJsClassPlaceholder	<pharoJsSkip>	^ true! !!PjEmptyClassExtensionOfASuperClass class methodsFor: 'pharoJs support'!javascriptName	<pharoJsSkip>	^ PjASuperClass name! !!PjExtensionOfBSubClassOfA class methodsFor: 'pharoJs support'!isJsClassPlaceholder 	<pharoJsSkip>	^ true! !!PjExtensionOfBSubClassOfA class methodsFor: 'pharoJs support'!javascriptName	<pharoJsSkip>	^ PjBSubClassOfA name! !!PjExtensionOfBSubClassOfA class methodsFor: 'accessing'!someString	<jsAlias: #someStringAlias>	^ super someString , ' Answer'! !!PjExtensionOfBSubClassOfA methodsFor: 'accessing'!someNumber		<jsAlias: #someNumberAlias>	^ super someNumber + 2! !!PjLoadForTest class methodsFor: 'any'!fortyTwo	^ X ifNil: [ X := 42 ]! !!PjLoadForTest class methodsFor: 'any'!initialize	Y := 'Y original'.	Z := 'Z original'.	X := nil! !!PjLoadForTest class methodsFor: 'any'!literal	<jsLiteralGenerator>		^ 'abc','def'! !!PjLoadForTest class methodsFor: 'any'!reset	<pharoJsSkip>		self initialize! !!PjLoadForTest class methodsFor: 'any'!setupClassVars	self classVarNames do: [ :key | 		self classVarNamed: key put: key , ' value' ]! !!PjLoadForTest class methodsFor: 'any'!y	^ Y! !!PjLoadForTest methodsFor: 'any'!literal	<jsLiteralGenerator>	^ 3 + 4! !!PjLoadForTest methodsFor: 'any'!seventeen	^ X! !!PjLoadForTest methodsFor: 'any'!subtract: n	^ X := X - n! !!PjLoadForTest methodsFor: 'any'!z	^ Z! !!PjAppWithFolderNameIncludesSpace class methodsFor: 'exporting'!defaultAppFolderName	<pharoJsSkip>		^ 'Folder Name With Space'! !!ManifestPharoJsBaseBridgeTests class methodsFor: 'code-critics'!ruleRBEqualNilRuleV1FalsePositive	^ #(#(#(#RGMethodDefinition #(#'PjLoadForTest class' #initialize #true)) #'2020-01-28T09:11:41.906215-05:00') )! !!ManifestPharoJsBaseBridgeTests class methodsFor: 'code-critics'!ruleRBLongMethodsRuleV1FalsePositive	^ #(#(#(#RGClassDefinition #(#PjBasicTest)) #'2019-10-18T16:58:01.056766-04:00') )! !!ManifestPharoJsBaseBridgeTests class methodsFor: 'code-critics'!ruleRBStringConcatenationRuleV1FalsePositive	^ #(#(#(#RGMethodDefinition #(#'PjLoadForTest class' #initialize #true)) #'2020-01-28T09:11:47.308527-05:00') )! !!PjTestBridge methodsFor: 'public'!evalJavascript: javaScriptString	^ lastJavascript := javaScriptString! !!PjTestBridge methodsFor: 'accessing'!lastJavascript	^ lastJavascript! !!PjAppFolderNameIncludesSpaceTest class methodsFor: 'suite parameters'!appClass	^ PjAppWithFolderNameIncludesSpace! !!PjAppFolderNameIncludesSpaceTest methodsFor: 'tests'!testConnectionEstablished	self assert: self bridge isConnected! !!PjHtmlGeneratorTest methodsFor: 'asserting'!assert: aString equalsIgnoringLineEndings: aString2	self		assert: (aString withLineEndings: '')		equals: (aString2 withLineEndings: '')! !!PjHtmlGeneratorTest methodsFor: 'running'!setUp	super setUp.	generator := PjHtmlGenerator new! !!PjHtmlGeneratorTest methodsFor: 'tests'!testAttributedLoadFrom	generator loadFrom: '<head>the head</head>blah<body att="foo">the body</body>'.	self assert: generator html equalsIgnoringLineEndings: '<!!DOCTYPE html><meta charset="utf-8" /><head>the head</head><body att="foo">the body</body></html>'! !!PjHtmlGeneratorTest methodsFor: 'tests'!testAugmentedLoadFrom	generator loadFrom: '<head>the head</head>blah<body>the body</body>'.	generator addCssLink: 'foo.css'.	generator addScriptUrl: 'foo.js'.	self assert: generator html equalsIgnoringLineEndings: '<!!DOCTYPE html><meta charset="utf-8" /><head>the head<link rel="stylesheet" type="text/css" href="foo.css"></head><body>the body<script language="javascript" type="text/javascript" src="foo.js"></script></body></html>'! !!PjHtmlGeneratorTest methodsFor: 'tests'!testNoBodyLoadFrom	generator loadFrom: 'blah<head>the head</head>'.	self assert: generator html equalsIgnoringLineEndings: '<!!DOCTYPE html><meta charset="utf-8" /><head>the head</head><body><!!-- no body tag in file --></body></html>'! !!PjHtmlGeneratorTest methodsFor: 'tests'!testNoHeadLoadFrom	generator loadFrom: 'blah<body>the body</body>'.	self assert: generator html equalsIgnoringLineEndings: '<!!DOCTYPE html><meta charset="utf-8" /><head><!!-- no head tag in file --></head><body>the body</body></html>'! !!PjHtmlGeneratorTest methodsFor: 'tests'!testSimpleLoadFrom	generator loadFrom: '<head>the head</head>blah<body>the body</body>'.	self assert: generator html equalsIgnoringLineEndings: '<!!DOCTYPE html><meta charset="utf-8" /><head>the head</head><body>the body</body></html>'! !!PjIncrementalJavascriptTest methodsFor: 'tests'!testPolyfillLoad	| contents |	bridge := PjTestBridge bridgeForAppClass: PjMinimalNodeApplication.	bridge loadAllClasses: #().	contents := bridge lastJavascript.	self assert: (contents includesSubstring: ' WebSocket=Smalltalk.require("ws")').	bridge loadClass: PjMinimalNodeApplication.	contents := bridge lastJavascript.	self deny: (contents includesSubstring: ' WebSocket=Smalltalk.require("ws")').! !!PjProxyForGlobalsTest methodsFor: 'running'!setUp	super setUp.	authorInitialName := Author uniqueInstance fullNamePerSe.	Author uniqueInstance fullName: 'PharoJS'.	classFactory := ClassFactoryForTestCase new! !!PjProxyForGlobalsTest methodsFor: 'running'!tearDown	super tearDown.	classFactory ifNotNil: [ classFactory cleanUp ].	Author uniqueInstance fullName: authorInitialName.! !!PjProxyForGlobalsTest methodsFor: 'tests'!testProxyForNewGlobalsCreated	| globalsPool userClass |	globalsPool := classFactory silentlyNewSubclassOf: PjJavascriptGlobals instanceVariableNames: '' classVariableNames: 'A B'.	userClass := classFactory newSubclassOf: Object uses: #() instanceVariableNames: '' classVariableNames: '' poolDictionaries: globalsPool name category: classFactory defaultCategory.	userClass class 		compile: 'globals		^{A. B}'.	userClass globals do: [ : each |		self assert: (each isKindOf: PjProxy) ]! !!PjSTONReaderTest methodsFor: 'private'!materialize: string	^ PjSTONReader from: string! !!PjSTONReaderTest methodsFor: 'tests'!testInfinity	self assert: (self materialize: 'Infinity') equals: Float infinity! !!PjSTONReaderTest methodsFor: 'tests'!testNaN	self assert: (self materialize: 'NaN') isNaN! !!PjSTONReaderTest methodsFor: 'tests'!testNegativeInfinity	self assert: (self materialize: '-Infinity') equals: Float infinity negated! !!PjAliasTest methodsFor: 'running'!loadClass: aClass	self bridge loadClass: aClass! !!PjAliasTest methodsFor: 'running'!setUp	super setUp.	self bridge loadClass: PjClassForTranspilationTest! !!PjAliasTest methodsFor: 'tests'!testAlias2Methods0Arg	self		assert: [ PjClassForTranspilationTest new alias2 ]		evaluatesTo: 21.	self		assert: [ PjClassForTranspilationTest new alias2Caller ]		evaluatesTo: 42! !!PjAliasTest methodsFor: 'tests'!testAliasMethod0Args	self assert:	 [ PjClassForTranspilationTest new aliasCaller ] evaluatesTo: 42.	self assert:	 [ PjClassForTranspilationTest new alias ] evaluatesTo: 42.	self assert:	 [ PjClassForTranspilationTest new aliasSpecialNameCaller ] evaluatesTo: 42.	self assert:	 [ PjClassForTranspilationTest new aliasSpecialName ] evaluatesTo: 42.! !!PjAliasTest methodsFor: 'tests'!testAliasMethod1Arg	self assert:	 [ PjClassForTranspilationTest new alias1Caller: 41 ] evaluatesTo: 42.	self assert:	 [ PjClassForTranspilationTest new alias1: 41 ] evaluatesTo: 42! !!PjAliasTest methodsFor: 'tests'!testClassMethod1AliasInExtensionClass	self loadClass: PjExtensionClassForAliasTest.	self assert: [ Object classM1 ] evaluatesTo: 'classM1'.	self assert: [ Object js_classM1alias ] evaluatesTo: 'classM1'! !!PjAliasTest methodsFor: 'tests'!testClassMethod2AliasesInExtensionClass	self loadClass: PjExtensionClassForAliasTest.	self assert: [ Object classM2 ] evaluatesTo: 'classM2'.	self assert: [ Object js_classM2alias1 ] evaluatesTo: 'classM2'.	self assert: [ Object js_classM2alias2 ] evaluatesTo: 'classM2'! !!PjAliasTest methodsFor: 'tests'!testInstanceMethod1AliasInExtensionClass	self loadClass: PjExtensionClassForAliasTest.	self assert: [ Object new m1 ] evaluatesTo: 'instanceM1'.	self assert: [ Object new js_m1alias ] evaluatesTo: 'instanceM1'! !!PjAliasTest methodsFor: 'tests'!testInstanceMethod3AliasesInExtensionClass	self loadClass: PjExtensionClassForAliasTest.	self assert: [ Object new m2 ] evaluatesTo: 'instanceM2'.	self assert: [ Object new js_m2alias1 ] evaluatesTo: 'instanceM2'.	self assert: [ Object new js_m2alias2 ] evaluatesTo: 'instanceM2'.	self assert: [ Object new js_m2alias3 ] evaluatesTo: 'instanceM2'! !!PjAliasTest methodsFor: 'tests'!testTwoAliasPragma	self		assert: [ PjClassForTranspilationTest new twoPragmaWithAliases ]		evaluatesTo: 200.	self		assert: [ PjClassForTranspilationTest new js_firstAlias ]		evaluatesTo: 200.	self		assert: [ PjClassForTranspilationTest new js_secondAlias ]		evaluatesTo: 200! !!PjAliasTest methodsFor: 'tests'!testTwoAliasPragmaExtension	self loadClass: PjExtensionClassForAliasTest.	self assert: [ Object new twoPragmaWithAliases ] evaluatesTo: 200.	self assert: [ Object new js_firstAlias ] evaluatesTo: 200.	self assert: [ Object new js_secondAlias ] evaluatesTo: 200! !!PjBasicTest methodsFor: 'tests'!testBasicEquality	self assertBlock: [ 312 ] equalsBlock: [ 312 ].	self denyBlock: [ 312 ] equalsBlock: [ 5 ].	self assertBlock: [ 'one two three' ] equalsBlock: [ 'one two three' ].	self assertBlock: [ 'one two three' ] equalsBlock: [ 'one ', 'two', ' three' ].	self denyBlock: [ 'one two three' ] equalsBlock: [ 'one three' ].! !!PjBasicTest methodsFor: 'tests'!testBooleanMethods	self assertEquivalent: [ true asBit ].	self assertEquivalent: [ false asBit ]! !!PjBasicTest methodsFor: 'tests'!testCallingNewOnAJsConstructorViaFullProxy	| o1 o2 |	self bridge evalJavascript: 'window.MyClass = class MyClass{		x(){			return this.x;		}		y(){			return this.y;		}		z(){			return this.z;		}		constructor(a, b, c){			this.x = a;			this.y = b;			this.z = c;		}	}'.	o1 := (window instVarNamed: #MyClass) new: 1 with: 2 with: 3.	self assert: o1 x equals: 1.	self assert: o1 y equals: 2.	self assert: o1 z equals: 3.	o2 := (window instVarNamed: #MyClass) new: 77 with: 88 with: 99.	self assert: o2 x equals: 77.	self assert: o2 y equals: 88.	self assert: o2 z equals: 99! !!PjBasicTest methodsFor: 'tests'!testClosedBlocks	<expectedFailure>		| x |	self fail: 'Fix error'.	x := 3.	self assertEquivalent: [ [ x + 39 ] value ] asClosedBlock.	x := 5.	self assertEquivalent: [ x + 39 ] asClosedBlock! !!PjBasicTest methodsFor: 'tests'!testClosure	self assertEquivalent: [| tot coll |		tot := 0.		coll := OrderedCollection new.		1 to: 5 do: [ : each | coll add: [ each ] ].		coll do: [  : each | tot := tot + each value ].		tot	].! !!PjBasicTest methodsFor: 'tests'!testDifferentIdentities	self assertEquivalent: [false ~~ true].! !!PjBasicTest methodsFor: 'tests'!testEqualityAndDifferenceWithNil	self assertEquivalent: [ 0 = nil ].	self assertEquivalent: [ 0 ~= nil ].	self assertEquivalent: [ nil = 0 ].	self assertEquivalent: [ nil ~= 0 ]! !!PjBasicTest methodsFor: 'tests'!testEvalResult	self checkBasic: 42.	self checkBasic: true.	self checkBasic: false.	self checkBasic: 'abc'.	self checkBasic: 'a\b''c"d'.	self checkProxy: nil.	self		should: [ 			(PjMessageErrorResponse newWithContents: 'a Javascript error') 				getValueWithBridge: self bridge ]		raise: PjJavascriptError! !!PjBasicTest methodsFor: 'tests'!testExceptionHandling	self assert: [|exceptionSignaled|			exceptionSignaled := false.			[Error signal]on: Error do: [exceptionSignaled := true].			exceptionSignaled]	  evaluatesTo: true.	self assert: [|exceptionSignaled|			exceptionSignaled := false.			[3+4]on: Error do: [exceptionSignaled := true].			exceptionSignaled]	  evaluatesTo: false.! !!PjBasicTest methodsFor: 'tests'!testHash	self assertEquivalent: [nil hash].	self assertEquivalent: [0 hash].	self assertEquivalent: [ 1234 hash].	self assertEquivalent: [true hash].	self assertEquivalent: [false hash].	self assert: ['abc' hash ] evaluatesTo: 135459374. " not the same as on Pharo, but uses same code with different initialization "	self assertEquivalent: [|x| x:= Object new. x hash = x hash].	self assertEquivalent: [|x y| x:= Object new. y:= Object new. x hash ~= y hash].! !!PjBasicTest methodsFor: 'tests'!testIdentity	self assertEquivalent: [ false == false ]! !!PjBasicTest methodsFor: 'tests'!testIfNilIfNotNil	self assertEquivalent: [ nil ifNil: [ 1 ] ].	self assertEquivalent: [ false ifNotNil: [ 2 ] ].	self assertEquivalent: [ nil ifNil: [ 1 ] ifNotNil: [ 2 ] ].	self assertEquivalent: [ false ifNil: [ 1 ] ifNotNil: [ 2 ] ].	self		assert: [ 			(document getElementById: #notInTheDocument)				ifNil: [ 1 ]				ifNotNil: [ 2 ] ]		evaluatesTo: 1! !!PjBasicTest methodsFor: 'tests'!testIfTrueIfFalse	self assertEquivalent: [ true ifTrue: [1] ] .	self assertEquivalent: [ false ifFalse: [2] ].	self assertEquivalent: [ false ifTrue: [1] ] .	self assertEquivalent: [ true ifFalse: [2] ].	self assertEquivalent: [ true ifTrue: [1] ifFalse: [2] ].	self assertEquivalent: [ false ifTrue: [1] ifFalse: [2] ].	self assertEquivalent: [ true ifFalse: [2] ifTrue: [1] ].	self assertEquivalent: [ false ifFalse: [2] ifTrue: [1] ] ! !!PjBasicTest methodsFor: 'tests'!testJsGlobalAccess	self		assert: (self bridge evalBlock: [ Date ])		equals: (self bridge jsGlobalAt: #Date).	self assert: (self bridge evalBlock: [ Object ]) equals: (self bridge jsGlobalAt: #Object)! !!PjBasicTest methodsFor: 'tests'!testMethodsForBitManipulation	self assertEquivalent: [ -257 bitShift: -4 ].	self assertEquivalent: [ 257 bitShift: -4 ].	self assertEquivalent: [ -257 bitShift: 4 ].	self assertEquivalent: [ 257 bitShift: 4 ].	self assertEquivalent: [ -5 bitAnd: -11 ].	self assertEquivalent: [ 5 bitAnd: 11 ].	self assertEquivalent: [ -5 bitAnd: 11 ].	self assertEquivalent: [ 5 bitAnd: 11 ].	self assertEquivalent: [ -5 bitOr: -11 ].	self assertEquivalent: [ 5 bitOr: 11 ].	self assertEquivalent: [ -5 bitOr: 11 ].	self assertEquivalent: [ 5 bitOr: 11 ].	self assertEquivalent: [ -5 bitXor: -11 ].	self assertEquivalent: [ 5 bitXor: 11 ].	self assertEquivalent: [ -5 bitXor: 11 ].	self assertEquivalent: [ 5 bitXor: 11 ].	self assertEquivalent: [ 1234567 highBit ].	self assertEquivalent: [ 12300000 lowBit ].	self assertEquivalent: [ -12300000 lowBit ].! !!PjBasicTest methodsFor: 'tests'!testMethodsForNumbers	self assertEquivalent: [ -3 abs ].	self assertEquivalent: [ 0 abs ].	self assertEquivalent: [ 3 abs ].	self assertEquivalent: [ 0 sign ].	self assertEquivalent: [ 4 sign ].	self assertEquivalent: [ -25 sign ].	self assertEquivalent: [ 30 degreesToRadians ].	self assertEquivalent: [ 1.78 radiansToDegrees ].! !!PjBasicTest methodsFor: 'tests'!testMultilineConstants	self assertEquivalent: [ 		'this			and that' size ].	self assertEquivalent: [ #( 1 2 3 4 5 6 ) size ]! !!PjBasicTest methodsFor: 'tests'!testNumber	| x |	self assertEquivalent: [ 1 ].	self assertEquivalent: [ 2 asInteger ].	self assertEquivalent: [ 2.5 asInteger ].	self assertEquivalent: [ 2 asFloat ].	self assertEquivalent: [ 2.5 asFloat ].	self assertEquivalent: [ 2 asNumber ].	self assertEquivalent: [ 2.5 asNumber ].	self assertEquivalent: [ '2' asNumber ].	self assertEquivalent: [ '2.5' asNumber ].	self assertEquivalent: [ [ 3 / 1 ] on: ZeroDivide do: [ 42 ] ].	self assertEquivalent: [ [ 3 / 0 ] on: ZeroDivide do: [ 42 ] ].	self assertEquivalent: [ [ 3.0 / 0 ] on: ZeroDivide do: [ 42 ] ].	self assertEquivalent: [ [ 3.0 / 2 ] on: ZeroDivide do: [ 42 ] ].	self assertEquivalent: [ [ 3 // 0 ] on: ZeroDivide do: [ 42 ] ].	self assertEquivalent: [ [ 3 // 1 ] on: ZeroDivide do: [ 42 ] ].	self assertEquivalent: [ [ 3.0 // 0 ] on: ZeroDivide do: [ 42 ] ].	self assertEquivalent: [ [ 3.0 // 2 ] on: ZeroDivide do: [ 42 ] ].	x := 1.5e300.	self assertEquivalent: [ x * x  ]. " Infinity "	self assertEquivalent: [ x negated * x ]. " -Infinity "	self assertEquivalent: [ x * x * 0 ]. " NaN "	self assertEquivalent: [ (x * x * 0) isNaN ]. " NaN "! !!PjBasicTest methodsFor: 'tests'!testResettingTheApp	self resetApp.	self assert: app identicalTo: self currentApp.! !!PjBasicTest methodsFor: 'tests'!testResettingTheClient	self bridge resetClient.	self assert: self bridge isConnected! !!PjBasicTest methodsFor: 'tests'!testSignalingExceptionFromJavaScript	self		should: [ 			self bridge evalBlock: [ 				Object new testSignalingExceptionFromJavaScript ] ]		raise: PjJavascriptError! !!PjBasicTest methodsFor: 'tests'!testSimpleMathOperations	self assertEquivalent: [ 1+2 ].	self assertEquivalent: [ 6*7 ].	self assertEquivalent: [ (2 + 4) * (3 + 4) ].	self assertEquivalent: [ 2 + 4 * 7 ].	self assertEquivalent: [ 2 + 4 * (3 + 4) ].	self assertEquivalent: [ (3 + 4) odd ].	self assertEquivalent: [ (3 * 4) odd ].	self assertEquivalent: [ (3 + 4) even ].	self assertEquivalent: [ (3 * 4) even ].! !!PjBasicTest methodsFor: 'tests'!testTimesRepeat	self		assertEquivalent: [|counter|			counter := 0.			5 timesRepeat: [counter := counter + 1].			counter].! !!PjBasicTest methodsFor: 'tests'!testToDoBy	self assertEquivalent: [ 		| tot |		tot := 0.		1 to: 2 by: 1 do: [ :i | tot := tot + 1 ].		tot ].	self assertEquivalent: [ 		| tot |		tot := 0.		2 to: 1 by: 1 do: [ :i | tot := tot + 1 ].		tot ].	self assertEquivalent: [ 		| tot |		tot := 0.		2 to: 1 by: -1 do: [ :i | tot := tot + 1 ].		tot ]! !!PjBasicTest methodsFor: 'tests'!testUnicode	self assert: $ asJSON equals: '"\u20AC"'.	self assert: 'abcd' asJSON equals: '"ab\u20ACcd"'.	self checkBasic: 'abcd'.! !!PjBasicTest methodsFor: 'tests'!testValueBlock0Arg	self assertEquivalent: [ [1+2] value ]! !!PjBasicTest methodsFor: 'tests'!testValueBlock1Arg	self assertEquivalent: [ [ : x | x + 2] value: 1 ]! !!PjBasicTest methodsFor: 'tests'!testValues	self assertEquivalent: [ 42 value ].	self assertEquivalent: [ true value ].	self assertEquivalent: [ false value ].	self assertEquivalent: [ 'abc' value ]! !!PjBridgeTestCase class methodsFor: 'suite parameters'!appClass	^ PjMinimalWebApplication! !!PjBridgeTestCase methodsFor: 'test support'!addToDOM: html	self bridge evalBlock: [ 		| div |		div := document createElement: 'div'.		div innerHTML: html.		document body appendChild: div ]! !!PjBridgeTestCase methodsFor: 'asserting'!assert: aBlock evaluatesTo: expectedResult	| actualResult |	actualResult := (self bridge evalBlock: aBlock) asLocalObject.	expectedResult isNumber ifTrue: [ 		expectedResult isNaN ifTrue: [ ^ self assert: actualResult isNaN ] ].	self assert: actualResult equals: expectedResult! !!PjBridgeTestCase methodsFor: 'asserting'!assert: aBlock evaluatesToRaw: expectedJsonString	| actualResult |	actualResult := self bridge evalBlock: aBlock.	self assert: actualResult asRawJSONString equals: expectedJsonString! !!PjBridgeTestCase methodsFor: 'asserting'!assertBlock: aBlock	self assert: aBlock evaluatesTo: true! !!PjBridgeTestCase methodsFor: 'asserting'!assertBlock: block1 equalsBlock: block2	| result1 result2 |	result1 := self evalBlock: block1.	result2 := self evalBlock: block2.	self assert: result1 = result2! !!PjBridgeTestCase methodsFor: 'asserting'!assertEquivalent: aBlock	self assert: aBlock evaluatesTo: aBlock value! !!PjBridgeTestCase methodsFor: 'asserting'!assertJavascript: expressionString evaluatesTo: expectedResultString	self		assert: (self bridge evalJavascript: expressionString)		equals: expectedResultString! !!PjBridgeTestCase methodsFor: 'test support'!checkBasic: value	self		assert:			((PjMessageEvaluationResponse newWithContents: value asJSON) 				 getValueWithBridge: self bridge)		equals: value! !!PjBridgeTestCase methodsFor: 'test support'!checkProxy: value	self		assert:			((PjMessageEvaluationResponse newWithContents: (PjProxyInfo new					   globalName: value asJSON;					   yourself)) getValueWithBridge: self bridge)		equals: value! !!PjBridgeTestCase methodsFor: 'asserting'!denyBlock: block1 equalsBlock: block2	| result1 result2 |	result1 := self evalBlock: block1.	result2 := self evalBlock: block2.	self deny: result1 equals: result2! !!PjBridgeTestCase methodsFor: 'test support'!evalBlock: aBlock	^ self bridge evalBlock: aBlock! !!PjBridgeTestCase methodsFor: 'running'!setUp	super setUp.	authorInitialName := Author uniqueInstance fullNamePerSe.	Author uniqueInstance fullName: 'PharoJS'.	classFactory := ClassFactoryForTestCase new! !!PjBridgeTestCase methodsFor: 'running'!tearDown	super tearDown.	classFactory ifNotNil: [ classFactory cleanUp ].	Author uniqueInstance fullName: authorInitialName! !!PjBridgeTestCase methodsFor: 'test support'!transpileMethod: aMethod	^ self bridge transpiler transpileMethodToString: aMethod! !!PjClassExtensionTest methodsFor: 'tests'!setUp	super setUp.	self bridge loadAllClasses: { 			PjASuperClass.			PjBSubClassOfA }.	self bridge loadClass: PjExtensionOfBSubClassOfA.! !!PjClassExtensionTest methodsFor: 'tests'!testClassMessageToSuper	self		assert: [ PjBSubClassOfA someString ]		evaluatesTo: 'Ultimate Answer'! !!PjClassExtensionTest methodsFor: 'tests'!testClassMethodAlias	self		assert: [ PjBSubClassOfA someString ]		evaluatesTo: 'Ultimate Answer'! !!PjClassExtensionTest methodsFor: 'tests'!testEmptyClassExtension	self bridge loadClass: PjEmptyClassExtensionOfASuperClass.	self assertEquivalent: [ PjASuperClass someString ].	self assertEquivalent: [ PjASuperClass new someNumber ]! !!PjClassExtensionTest methodsFor: 'tests'!testInstanceMessageToSuper	self assert: [ PjBSubClassOfA new someNumber ] evaluatesTo: 42! !!PjClassExtensionTest methodsFor: 'tests'!testInstanceMethodAlias	self assert: [ PjBSubClassOfA new someNumberAlias ] evaluatesTo: 42! !!PjInfrastructureTest methodsFor: 'tests'!testBridgePort	self assert: self bridge port equals: self bridge server port! !!PjInfrastructureTest methodsFor: 'tests'!testCallGetsTrampolined	self assert: (self bridge evalBlock: [ 			 nil ~= (document getElementsByTagName: 'script') ])! !!PjInfrastructureTest methodsFor: 'tests'!testDNUSetup	| prefix |	prefix := self bridge exporter transpiler pharoJsSelectorPrefix.	self		assert: (self bridge evalJavascript: 'undefined === document.', prefix, 'children').	self assert: (self bridge evalBlock: [ document children ~= nil ]).	self		assert:			(self bridge evalJavascript: 'window.', prefix, 'children !!== document.', prefix, 'children').	self		assert: (self bridge evalJavascript: 'window.', prefix, 'children !!== undefined').	self		assert: (self bridge evalJavascript: 'window.', prefix, 'children === console.', prefix, 'children').	self		assert:			(self bridge				evalJavascript: 'HTMLDocument.prototype.', prefix, 'children === document.', prefix, 'children')! !!PjInfrastructureTest methodsFor: 'tests'!testGetterGetsTrampolined	self assert: (self bridge evalBlock: [ document body ~= nil ])! !!PjInfrastructureTest methodsFor: 'tests'!testIs	self assertEquivalent: [ Object isBlock ].	self assertEquivalent: [ Object new isBlock ].	self assertEquivalent: [ Object isBlock ].	self assertEquivalent: [ [] isBlock ].	self assertEquivalent: [ Object new isClass ].	self assertEquivalent: [ [] isClass ].	self assertEquivalent: [ Object isBehavior ].	self assertEquivalent: [ Object isClass ]! !!PjInfrastructureTest methodsFor: 'tests'!testJSSelector	|prefix|	prefix := self bridge exporter transpiler pharoJsSelectorPrefix.	self assert: [PjCore makePharoJsSelector: #foo] evaluatesTo: prefix, 'foo'.	self assert: [PjCore makePharoJsSelector: #foo:] evaluatesTo: prefix, 'foo_'.	self assert: [PjCore makePharoJsSelector: ','] evaluatesTo: prefix, '44_'.	self assert: [PjCore makePharoJsSelector: prefix, '44_'] evaluatesTo: prefix, '44_'.	self assert: [PjCore makePharoJsSelector: prefix, 'foo'] evaluatesTo: prefix, 'foo'.	self assert: [PjCore makePharoJsSelector: prefix, 'foo_'] evaluatesTo: prefix, 'foo_'.	self assert: [PjCore makePharoJsSelector: #'$foo:'] evaluatesTo: prefix, '$foo_'.! !!PjInfrastructureTest methodsFor: 'tests'!testOpenUrlWithParameters	| clientUrl |	clientUrl := self bridge server url ? (#paramA -> #valueA)	             & (#paramB -> #valueB).	self bridge client stop.	self bridge resetProxiesImmediately.	self waitWhile: [ self bridge isConnected ] timeOut: 2 seconds.	self bridge client openWebBrowserOn: clientUrl asString.	self waitUntil: [ self bridge isConnected ] timeOut: 2 seconds.	self waitWhile: [ (app := self currentApp) isNil ] timeOut: 2 seconds.	self assert: location search equals: '?paramA=valueA&paramB=valueB'! !!PjInfrastructureTest methodsFor: 'tests'!testSTSelector	self assert: [ PjCore makeSmalltalkSelector: #foo ] evaluatesTo: 'foo'.	self assert: [ PjCore makeSmalltalkSelector: #foo: ] evaluatesTo: 'foo:'.	self assert: [ PjCore makeSmalltalkSelector: #, ] evaluatesTo: ','.	self assert: [ PjCore makeSmalltalkSelector: PjCore pharoJsSelectorPrefix, '44_' ] evaluatesTo: ','.	self assert: [ PjCore makeSmalltalkSelector: PjCore pharoJsSelectorPrefix, 'foo' ] evaluatesTo: 'foo'.	self assert: [ PjCore makeSmalltalkSelector: PjCore pharoJsSelectorPrefix, 'foo_' ] evaluatesTo: 'foo:'! !!PjInfrastructureTest methodsFor: 'tests'!testSetterGetsTrampolined	self bridge evalBlock: [ document js_at: 'foo' put: 17 ].	self bridge evalBlock: [ document foo: 42 ].	self assert: (self bridge evalBlock: [ document foo = 42 ])! !!PjInfrastructureTest methodsFor: 'tests'!testValueNonInterference	self addToDOM: '<input id="theInput" type="text" value="Name:">'.	self assert: [|t| t := document getElementById: #theInput.t value=t defaultValue] evaluatesTo: true.	self assert: [|t| t := document getElementById: #theInput.t value: 'addr'] evaluatesTo: 'addr'.	self assert: [|t| t := document getElementById: #theInput.t value] evaluatesTo: 'addr'! !!PjLoadingTest methodsFor: 'tests'!testEvalBlock	PjLoadForTest reset.	self bridge evalBlock: [ window js_at: #valueForEvalTest put: 42 ].	self		assert: (self bridge evalBlock: [ window js_at: #valueForEvalTest ])		equals: 42.	self		should: [ self bridge evalBlock: [ window aMethodThatDoesntExist ] ]		raise: PjJavascriptError.	self		assert: (self bridge evalBlock: [ PjLoadForTest fortyTwo ])		equals: PjLoadForTest fortyTwo.	self		assert: (self bridge evalBlock: [ PjLoadForTest new subtract: 25 ])		equals: (PjLoadForTest new subtract: 25).	self		assert: (self bridge evalBlock: [ PjLoadForTest new seventeen ])		equals: PjLoadForTest new seventeen.	self		assert: (self bridge evalBlock: [ PjLoadForTest y ])		equals: PjLoadForTest y.	self		assert: (self bridge evalBlock: [ PjLoadForTest new z ])		equals: PjLoadForTest new z.	self		assert: (self bridge evalBlock: [ PjLoadForTest classVarNames size ])		equals: PjLoadForTest classVarNames size.	self		bridge evalBlock: [ PjLoadForTest setupClassVars ].	self		assert: (self bridge evalBlock: [ PjLoadForTest y ])		equals: 'Y value'.	self		assert: (self bridge evalBlock: [ PjLoadForTest new z ])		equals: 'Z value'.! !!PjLoadingTest methodsFor: 'tests'!testLiteralGeneration	self assertEquivalent: [ PjLoadForTest literal ].	self assertEquivalent: [ PjLoadForTest new literal ]! !!PjLoadingTest methodsFor: 'tests'!testLoadClass	PjLoadForTest reset.	self bridge loadClass: PjLoadForTest.	self		assert: (self bridge evalBlock: [ PjLoadForTest fortyTwo ])		equals: PjLoadForTest fortyTwo.	self		assert: (self bridge evalBlock: [ PjLoadForTest new subtract: 25 ])		equals: (PjLoadForTest new subtract: 25).	self		assert: (self bridge evalBlock: [ PjLoadForTest new seventeen ])		equals: PjLoadForTest new seventeen! !!PjLoadingTest methodsFor: 'tests'!testLoadClassContents	| first firstBlock second secondBlock className third pjPrefix|	pjPrefix := self bridge exporter transpiler pharoJsSelectorPrefix.	className := PjLoadForTest nameToUseForJsConversion.	PjLoadForTest reset.	first := self bridge convertToJs: PjLoadForTest.	self assert: (first beginsWith: 'Smalltalk.installClass(class ', className,' extends Object' ).	self assert: (first trim endsWith: className , '.', pjPrefix, 'initialize();').	firstBlock := self bridge		convertToJs: [ PjLoadForTest fortyTwo ] asValuedBlock.	self assert: ('*registerDnuForAll*' match: firstBlock).	secondBlock := self bridge		convertToJs: [ PjLoadForTest fortyTwo ] asValuedBlock.	self deny: ('*registerDnuForAll*' match: secondBlock).	second := self bridge convertToJs: PjLoadForTest.	self assert: second equals: ''.	self bridge exporter invalidateClass: PjLoadForTest.	third := self bridge convertToJs: PjLoadForTest.	self deny: third = ''.	self deny: (third beginsWith: 'function ' , className).	self deny: (third endsWith: className , '.', pjPrefix, 'initialize();')! !!PjPerformTest methodsFor: 'tests'!testPerform	self assertEquivalent: [ 3 perform: #negated ]! !!PjPerformTest methodsFor: 'tests'!testPerformWith	self assertEquivalent: [3 perform: #* with: 14]! !!PjPerformTest methodsFor: 'tests'!testPerformWithArguments	self assertEquivalent: [3 perform: #* withArguments: #(14)]! !!PjProxyTest methodsFor: 'tests'!testArrayEquality	self assertBlock: [ #() ] equalsBlock: [ #() ].	self denyBlock: [ #() ] equalsBlock: [ #(1 2 3) ].	self assertBlock: [ #(1 2 3) ] equalsBlock: [ #(1 2 3) ].	self denyBlock: [ #(1 2) ] equalsBlock: [ #(1 2 3) ].	self denyBlock: [ #(1 3 2) ] equalsBlock: [ #(1 2 3) ].	self assertBlock: [ #(one two three) ] equalsBlock: [ #(one two three) ].	self assertBlock: [ {true. 'two'. nil. 3.14.}] equalsBlock: [ {true. 'two'. nil. 3.14.} ].	self assertBlock: [ {{true. 'two'}. nil. 3.14.}] equalsBlock: [ {{true. 'two'}. nil. 3.14.} ].	self denyBlock: [ {{true. 'two'}. nil. 3.14.}] equalsBlock: [ {{false. 'abc'}. nil. 3.14.} ].! !!PjProxyTest methodsFor: 'tests'!testAsJson	self assert: 42 asJSON equals: '42'.	self assert: 'a\b"c' asJSON equals: '"a\\b\"c"'.	self assert: nil asJSON equals: 'null'.! !!PjProxyTest methodsFor: 'tests'!testBlockClosures	document body addEventListener: 'click' block: [ 42 ].	self		should: [ document body addEventListener: 'click' block: 42 ]		raise: Error.	self		should: [ document body addEventListener: 'click' block: [ :ev | ^ 42 ] ]		raise: Error.	self		assert: (document body addEventListener: 'click' block: [ :ev | 17 ])		equals: true.	self assert: self bridge blockClosures size equals: 1.	self		assert: (document body addEventListener: 'click' block: [ :ev | 42 ])		equals: true.	self assert: self bridge blockClosures size equals: 1.	document body removeEventListener: 'click'.	self assert:		self bridge blockClosures size equals: 0.! !!PjProxyTest methodsFor: 'tests'!testBrowser	self assert: (window hasOwnProperty: 'document') description: 'window properies'! !!PjProxyTest methodsFor: 'tests'!testChildren	| rectangle other |	rectangle := document createElement: 'span'.	rectangle id: 'grn'.	document body		appendChild: rectangle.	self assert: (document getElementById: 'grn') children size equals: 0.	other := document createElement: 'span'.	other id: 'other'.	rectangle appendChild: other.	Smalltalk garbageCollect.	self assert: (document getElementById: 'grn') children size equals: 1.	self assert: (document getElementsByTagName: 'span') size equals: 2.	self assert: ((document getElementsByTagName: 'span') at: 1) id equals: 'grn'! !!PjProxyTest methodsFor: 'tests'!testClick	| rectangle count |	count := 0.	rectangle := document createElement: 'div'.	rectangle id: 'grn'.	rectangle instVarNamed: #count put: 0.	" need to use instVarNamed:put: to force creation of slot "	Smalltalk garbageCollect.	document body appendChild: rectangle.	rectangle		addEventListener: 'click'		block: [ :xev | 			count := count + 1.			rectangle count: rectangle count + 1 ].	self bridge		evalJavascript:			'(' , rectangle asJSON , '.click(false),' , rectangle asJSON				, '.click(true),false)'.	Smalltalk garbageCollect.	rectangle dispatchEvent: (window MouseEvent new: #click).	rectangle dispatchEvent: (window MouseEvent new: #click).	self assert: (document getElementById: 'grn') count equals: 4.	Smalltalk garbageCollect.	self assert: (document getElementById: 'grn') count equals: 4.	rectangle dispatchEvent: (window MouseEvent new: #click).	rectangle dispatchEvent: (window MouseEvent new: #click).	Smalltalk garbageCollect.	self assert: (document getElementById: 'grn') count equals: 6.	self assert: count = 6! !!PjProxyTest methodsFor: 'tests'!testClickWithEventTarget	| rectangle1 rectangle2 lastClickedRectangle count listenerBlock |	count := 0.	rectangle1 := document createElement: 'div'.	rectangle1 id: 'rect1'.	rectangle1 instVarNamed: #count put: 0.	rectangle2 := document createElement: 'div'.	rectangle2 id: 'rect2'.	rectangle2 instVarNamed: #count put: 0.	Smalltalk garbageCollect.	document body appendChild: rectangle1.	document body appendChild: rectangle2.	listenerBlock := [ :xev :this | 	| alsoRectangle |	alsoRectangle := this.	lastClickedRectangle := alsoRectangle.	count := count + 1.	alsoRectangle count: alsoRectangle count + 1 ].	rectangle1 addEventListener: 'click' block: listenerBlock.	rectangle2 addEventListener: 'click' block: listenerBlock.	rectangle1 dispatchEvent: (window MouseEvent new: #click).	self assert: (document getElementById: 'rect1') count equals: 1.	self assert: rectangle1 equals: lastClickedRectangle.	self assert: (document getElementById: 'rect2') count equals: 0.	self assert: count = 1.	rectangle2 dispatchEvent: (window MouseEvent new: #click).	Smalltalk garbageCollect.	self assert: rectangle2 equals: lastClickedRectangle.	self assert: (document getElementById: 'rect1') count equals: 1.	self assert: (document getElementById: 'rect2') count equals: 1.	self assert: count = 2! !!PjProxyTest methodsFor: 'tests'!testGetElementById	| rectangle |	rectangle := document createElement: 'div'.	rectangle id: 'grn'.	document body		appendChild: rectangle.	self assert: (document getElementById: 'grn') id equals: 'grn'.	self assert: (document js_getElementById: 'grn') id equals: 'grn'! !!PjProxyTest methodsFor: 'tests'!testIterateOverChildren	| container newChild |	container := document createElement: 'div'.	10 timesRepeat: [		newChild := document createElement: 'span'.		container appendChild: newChild].	self assert: container children size equals: 10.	container children withIndexDo: [ : each : index | 		each textContent: index].! !!PjProxyTest methodsFor: 'tests'!testProxyGarbageCollection	| b jsName |	b := document body.	jsName := b javascriptName.	self deny: jsName isNil.		"Following lines to mimic the effect of garbage collection in a deteministic way."	(self finalizationRegistry remove: b ifAbsent: [ nil ])		ifNotNil: [ :finalizerItem | finalizerItem finalizeValues ].	b := nil.		self deny: (global includesKey: jsName)! !!PjProxyTest methodsFor: 'tests'!testProxyMissingError	1 to: 10 do: [ :num | 		document body children.		num milliSeconds wait ]! !!PjProxyTest methodsFor: 'tests'!testValueNonInterference	| theInput |	self		addToDOM: '<input id="testValueNonInterference" type="text" value="Name:">'.	theInput := self bridge		evalBlock: [ document getElementById: #testValueNonInterference ].	self assert: theInput value equals: theInput defaultValue! !!PjReflectionTest methodsFor: 'tests'!testClassName	| class |	class := classFactory		silentlyNewSubclassOf: PjObject		instanceVariableNames: 'x y'		classVariableNames: ''.	self bridge loadClass: class.	self assert: [ class name ] evaluatesTo: class name asString.	self assert: [ class new className ] evaluatesTo: class name asString! !!PjReflectionTest methodsFor: 'tests'!testDirectSubclasses	| objectInitialSubclassesSize objectNewSubclassesSize |	objectInitialSubclassesSize := self evalBlock: [ Object subclasses size  ].		self assertBlock: [Object subclasses includesAll: { PjFunction. PjArray. PjNumber. PjBoolean } ].		self assert: objectInitialSubclassesSize > 4.	self bridge loadClass: PjArrayClassExtensionForTest.	self assertBlock: [ Object subclasses size = objectInitialSubclassesSize].		self assertBlock: [PjFunction subclasses size = 1 ].	self assertBlock: [PjFunction subclasses includes: PjClass ].	self bridge loadAllClasses: { PjBSubClassOfA . PjCSubClassOfA  }.	objectNewSubclassesSize := self evalBlock: [ Object subclasses size  ].		self assert: objectNewSubclassesSize equals: objectInitialSubclassesSize + 1.	self assertBlock: [PjASuperClass subclasses size = 2 ].	self assertBlock: [PjASuperClass subclasses includes: PjBSubClassOfA].	self assertBlock: [PjASuperClass subclasses includes: PjCSubClassOfA].	self assertBlock: [PjBSubClassOfA subclasses isEmpty ].	self assertBlock: [PjCSubClassOfA subclasses isEmpty ].	! !!PjReflectionTest methodsFor: 'tests'!testDirectSuperclass		self assertBlock: [PjClass superclass == PjFunction ].	self assertBlock: [PjFunction superclass == Object ].	self assertBlock: [Object superclass isNil ].	self assertBlock: [PjArray superclass == Object ].	self bridge loadAllClasses: { PjBSubClassOfA . PjCSubClassOfA  }.	self assertBlock: [PjASuperClass superclass == Object ].	self assertBlock: [PjBSubClassOfA superclass == PjASuperClass ].	self assertBlock: [PjCSubClassOfA superclass == PjASuperClass ].	! !!PjReflectionTest methodsFor: 'tests'!testMetaclassLink		self assertBlock: [( Object getPrototypeOf: PjClass prototype) == PjFunction prototype ].	self assertBlock: [( Object getPrototypeOf: PjClass) == PjFunction ].	self assertBlock: [( Object getPrototypeOf: PjFunction) == Object ].	self assertBlock: [( Object getPrototypeOf: PjArray) == Object ].	self assertBlock: [( Object getPrototypeOf: PjBoolean ) == Object ].	self assertBlock: [( Object getPrototypeOf: PjDate ) == Object ].	self assertBlock: [( Object getPrototypeOf: PjNumber) == Object ].	self assertBlock: [( Object getPrototypeOf: PjString) == Object ].! !!PjReflectionTest methodsFor: 'tests'!testNestedRepeats	| class tryNestedRepeatsSelector tryNestedRepeatsMethod |	class := classFactory		silentlyNewSubclassOf: PjObject		instanceVariableNames: 'x y'		classVariableNames: ''.	tryNestedRepeatsSelector := #tryNestedRepeats.	tryNestedRepeatsMethod := self class compiledMethodAt: tryNestedRepeatsSelector.	class compile: tryNestedRepeatsMethod sourceCode.	self bridge loadClass: class.	self		assert: [ class new tryNestedRepeats ]		evaluatesTo: self tryNestedRepeats! !!PjReflectionTest methodsFor: 'tests'!testReflection	self assertEquivalent: [ Number inheritsFrom: Object ].	self assertEquivalent: [ Number canUnderstand: #isNil ].	self assertEquivalent: [ Number canUnderstand: #someSelectorThatDoesntExist ].	self assertEquivalent: [ Number canUnderstand: #ifTrue: ].	self assertEquivalent: [ 42 respondsTo: #ifTrue: ].	self assertEquivalent: [ 42 respondsTo: #abs ].	self assertEquivalent: [ true respondsTo: #ifTrue: ].	self assertEquivalent: [ Object new respondsTo: #neverDefined ].	self assert: [ document respondsTo: #neverDefined ] evaluatesTo: false.	self assertEquivalent: [ 3 isKindOf: Number ].	self assertEquivalent: [ 3 isKindOf: Object ].	self assertEquivalent: [ 3 isMemberOf: SmallInteger ].	self assertEquivalent: [ 3 isMemberOf: Object ].	self assertEquivalent: [ true respondsTo: #not ].	self assertEquivalent: [ true respondsTo: #ifTrue: ].	self assertEquivalent: [ 42 respondsTo: #<= ].! !!PjReflectionTest methodsFor: 'tests'!testTemporaries	| class tryTemporariesSelector tryTemporariesMethod |	class := classFactory		silentlyNewSubclassOf: PjObject		instanceVariableNames: 'x y'		classVariableNames: ''.	tryTemporariesSelector := #tryTemporaries.	tryTemporariesMethod := self class compiledMethodAt: tryTemporariesSelector.	class compile: tryTemporariesMethod sourceCode.	self bridge loadClass: class.	self		assert: [ class new tryTemporaries ]		evaluatesTo: self tryTemporaries! !!PjReflectionTest methodsFor: 'test support'!tryNestedRepeats		| x |		x := 1.		5 timesRepeat: [| w |			w := w ifNil: [ x ].			10 timesRepeat: [				x := x + 1].			x := x + w].		^ x! !!PjReflectionTest methodsFor: 'test support'!tryTemporaries 		| x b |		b := [ : a | | y |			11 timesRepeat: [ | w |				w := (w ifNil: [ 0 ])+(a*100).				y := (y ifNil: [ 0 ])+w.			].			b isNil ifFalse: [ | z |				z := (z ifNil: [ 0 ])+a.				y := (y ifNil: [ 0 ])+(a*10).				x := (x ifNil: [ 0 ])+(a*100000)+y+z]].		b value: 1.		b value: 4.		^ x! !"PharoJs-Base-Bridge-Tests"!!PjOptimizedMethods commentStamp: '' prior: 0!Sample methods for PjOptimizedMethodTest!!PjOptimizedMethodTest methodsFor: 'tests'!testShouldReturnTrue	self assertEquivalent: [|d|		d := PjOptimizedMethods new.		d shouldReturnTrue].! !!PjOptimizedMethodTest methodsFor: 'tests'!testShouldReturnTrue2	self assertEquivalent: [|d|		d := PjOptimizedMethods new.		d shouldReturnTrue2].! !!PjOptimizedClassTranspilationTest methodsFor: 'running'!setUp	super setUp.	transpiler addAllOptionalConversions! !!PjOptimizedClassTranspilationTest methodsFor: 'testing'!testBlockTempNames	self generateJsCodeForClasses: { PjClassForTranspilationTest }.	self assertInstanceMethod: #blockWithUnnamedParameter		equals: '(){var $1;if(($1=this._m1())==null){return 42;}else{return $1}}'.	self assertInstanceMethod: #blockWithUnnamedParameterNonTail		equals: '(){var $1;return 3+(($1=this._m1())==null?42:$1)}'.	self assertInstanceMethod: #blockWithNamedParameter		equals: '(){var foo;if((foo=this._m1())==null){return null;}else{return $asNil$(foo)._m1()}}'.! !!PjOptimizedClassTranspilationTest methodsFor: 'testing'!testBlocksAndReturns	self jsCode: (self convertClass: PjClassForTranspilationTest).	self assertInstanceMethod: #whileNotAtEnd		equals: '(){this._m_((x)=>{while(true==$asNil$(x)._m1()){}});while(true==this._m2()){}return 42}'.	self assertInstanceMethod: #whileAtEnd		equals: '(){this._m_((x)=>{while(true==$asNil$(x)._m1()){}});while(true==this._m2()){}return this}'.! !!PjOptimizedClassTranspilationTest methodsFor: 'testing'!testSubIf	self jsCode: (self convertClass: PjClassForTranspilationTest).	self assertClassMethod: #setupMessage		equals: '(){return $asNil$((this===JsClass?"":"Sorry, "))._44_("Click anywhere")}'.	self assertClassMethod: #click:		equals: '(ev){var m,$1;var $_err_$={};try{m=($1=this._setupMessage())==null?',PjCore throwFunctionName,'($_err_$=this):$1;return m}catch(e){if(e===$_err_$)return e;throw e}}'.! !!PjOptimizedCoreLibrariesTranspilationTest methodsFor: 'running'!setUp	super setUp.	transpiler addAllOptionalConversions! !!PjOptimizedCoreLibrariesTranspilationTest methodsFor: 'testing'!testPjLoggingEvaluatorWebSocketDelegateClass	self jsCode: (self convertClass: PjLoggingEvaluatorWebsocketDelegate).	self assertInstanceMethod: #log: equals: '(aString){var logElement,br,text,$_self_$=this;(()=>{var $1;br=$asNil$(document)._createElement_("BR");text=$asNil$(document)._createTextNode_(aString);logElement=$_self_$._logElement();return ($1=$asNil$(logElement),$1._insertBefore_node_(br,$asNil$(logElement)._firstChild()),$1._insertBefore_node_(text,$asNil$(logElement)._firstChild()))})._on_do_(Error,()=>{return $asNil$(console)._log_(aString)});return this}'! !!PjOptimizedCoreLibrariesTranspilationTest methodsFor: 'testing'!testPjStringClass	self jsCode: (self convertClass: PjString).self assertInstanceMethod: #isLetter equals: '(){return $asNil$(this._letterCharCodes())._includes_(this.charCodeAt(0))}'! !!PjGenerationOptimizationTest methodsFor: 'testing'!testAnd	| y inputAst |	y := PjTempVariableNode identifier: #y.	inputAst := PjApplyNode		receiver: selfNode		selector: #foo:		args: {PjIfTrueIfFalseNode 			test: y			whenTrue: one			whenFalse: falseNode}.	self assert:  inputAst asStringEquals: 'this._foo_(true==y&&1)'.! !!PjGenerationOptimizationTest methodsFor: 'testing'!testIfFalse	| y inputAst returnAst |	y := PjTempVariableNode identifier: #y.	inputAst := PjIfTrueNode 		test: y not		whenTrue: one.	returnAst := PjReturnNode expression: (PjIfTrueIfFalseNode 		test: y		whenTrue: nilNode		whenFalse: one).	self assert:  inputAst asStringEquals: 'if(false==y){1}'.	self assert:  returnAst asStringEquals: 'return true==y?null:1'! !!PjGenerationOptimizationTest methodsFor: 'testing'!testIfNil	| inputAst tempVariable tempVariableName y |	y := PjTempVariableNode identifier: #y.	tempVariableName := PjStringGenerator tempNamePrefix, '1'.	tempVariable := PjTempVariableNode identifier: tempVariableName asSymbol.	inputAst := PjReturnNode expression: (		PjIfNilNode 			test: (self apply: y selector: #foo)			whenNil: one).	self assert: inputAst asStringEquals: 'return $asNil$(y)._foo()==null?1:null'.	inputAst := PjIfNilNode 			test: (self apply: y selector: #foo)			whenNil: one.	self assert: inputAst asStringEquals: 'if($asNil$(y)._foo()==null){1}'.! !!PjGenerationOptimizationTest methodsFor: 'testing'!testIfNilCaseForIfNilIfNotNil	| expectedAst tempVariable tempVariableName y |	y := PjTempVariableNode identifier: #y.	tempVariableName := PjStringGenerator tempNamePrefix, '1'.	tempVariable := PjTempVariableNode identifier: tempVariableName asSymbol.	expectedAst := PjReturnNode expression: (		PjIfNilIfNotNilNode 			test: (PjAssignNode				target: tempVariable				expression: (self apply: y selector: #foo))			whenNotNil: tempVariable			whenNil: one).	self		assert: expectedAst		asStringEquals: 'return ($1=$asNil$(y)._foo())==null?1:$1'! !!PjGenerationOptimizationTest methodsFor: 'testing'!testIfNotNil	| expectedAst tempVariable tempVariableName y |	y := PjTempVariableNode identifier: #y.	tempVariableName := #x.	tempVariable := PjTempVariableNode identifier: tempVariableName.	expectedAst := PjReturnNode expression: (		PjIfNotNilNode 			test: (PjAssignNode				target: tempVariable				expression: (self apply: y selector: #foo nonNil: false))			whenNotNil: tempVariable).	self		assert: expectedAst		asStringEquals: 'return (x=$asNil$(y)._foo())==null?null:x'.	expectedAst := PjReturnNode expression: (		PjIfNotNilNode 			test: (PjAssignNode				target: tempVariable				expression: (self apply: y selector: #foo nonNil: false))			whenNotNil: (self apply: tempVariable selector: #foo nonNil: true)).	self		assert: expectedAst		asStringEquals: 'return (x=$asNil$(y)._foo())==null?null:x._foo()'.	expectedAst := PjIfNotNilNode 			test: (PjAssignNode				target: tempVariable				expression: (self apply: y selector: #foo nonNil: false))			whenNotNil: tempVariable.	self assert: expectedAst asStringEquals: 'if((x=$asNil$(y)._foo())!!=null){x}'.	expectedAst := PjIfNotNilNode 			test: (PjAssignNode				target: tempVariable				expression: (self apply: y selector: #foo))			whenNotNil: (self apply: tempVariable selector: #foo nonNil: true).	self		assert: expectedAst		asStringEquals: 'if((x=$asNil$(y)._foo())!!=null){x._foo()}'.	expectedAst := PjIfNotNilNode		test: y		whenNotNil: returnOne. 	self		assert: expectedAst		asStringEquals: 'if(y!!=null){return 1}'.! !!PjGenerationOptimizationTest methodsFor: 'testing'!testIfNotNilCaseForIfNilIfNotNil	| expectedAst tempVariable tempVariableName y |	y := PjTempVariableNode identifier: #y.	tempVariableName := #x.	tempVariable := PjTempVariableNode identifier: tempVariableName.	expectedAst := PjReturnNode expression: (		PjIfNilIfNotNilNode 			test: (PjAssignNode				target: tempVariable				expression: (self apply: y selector: #foo)) 			whenNotNil: tempVariable			whenNil: one).	self assert: expectedAst asStringEquals: 'return (x=$asNil$(y)._foo())==null?1:x'.	expectedAst := PjReturnNode expression: (		PjIfNilIfNotNilNode 			test: (PjAssignNode				target: tempVariable				expression: (self apply: y selector: #foo))			whenNotNil: (self apply: tempVariable selector: #foo nonNil: true)			whenNil: one).	self assert: expectedAst asStringEquals: 'return (x=$asNil$(y)._foo())==null?1:x._foo()'.	expectedAst := PjIfNilIfNotNilNode 			test: (PjAssignNode				target: tempVariable				expression: (self apply: y selector: #foo))			whenNotNil: tempVariable			whenNil: one .	self assert: expectedAst asStringEquals: 'if((x=$asNil$(y)._foo())==null){1;}else{x}'.	expectedAst := PjIfNilIfNotNilNode 			test: (PjAssignNode				target: tempVariable				expression: (self apply: y selector: #foo))			whenNotNil: (self apply: tempVariable selector: #foo nonNil: true)			whenNil: one.	self assert: expectedAst asStringEquals: 'if((x=$asNil$(y)._foo())==null){1;}else{x._foo()}'! !!PjGenerationOptimizationTest methodsFor: 'testing'!testIfTrue	| y inputAst |	y := PjTempVariableNode identifier: #y.	inputAst := PjIfTrueNode 		test: y		whenTrue: one.	self assert:  inputAst asStringEquals: 'if(true==y){1}'.! !!PjGenerationOptimizationTest methodsFor: 'testing'!testIfTrueIfFalse	| y inputAst returnAst |	y := PjTempVariableNode identifier: #y.	inputAst := PjIfTrueIfFalseNode 		test: y		whenTrue: one		whenFalse: two.	returnAst := PjReturnNode expression: inputAst.	self assert:  inputAst asStringEquals: 'if(true==y){1}else{2}'.	self assert:  returnAst asStringEquals: 'return true==y?1:2'! !!PjGenerationOptimizationTest methodsFor: 'testing'!testOr	| y inputAst |	y := PjTempVariableNode identifier: #y.	inputAst := PjApplyNode		receiver: selfNode		selector: #foo:		args: {PjIfTrueIfFalseNode 			test: y			whenTrue: trueNode			whenFalse: one}.	self assert:  inputAst asStringEquals: 'this._foo_(true==y||1)'.! !!PjGenerationOptimizationTest methodsFor: 'testing'!testSequence	| x inputAst |	x := PjTempVariableNode identifier: #x.	inputAst := PjSequenceNode		expressions:			{one.			two.			(PjIfTrueIfFalseNode				test: (self apply: x selector: #foo)				whenTrue: one				whenFalse: two)}.	self		assert: (PjIfTrueNode test: inputAst whenTrue: one)		asStringEquals:			'if(true==(1,2,(true==$asNil$(x)._foo()?1:2))){1}'.	self		assert: inputAst		asStringEquals: '1;2;if(true==$asNil$(x)._foo()){1}else{2}'.	inputAst := self		simpleBlock:			{(PjIfTrueIfFalseNode				test: one				whenTrue:					(PjSequenceNode						expressions:							{two.							(PjIfTrueNode test: one not whenTrue: two).							returnThree})				whenFalse:					(PjReturnNode						expression:							(self								simpleBlock:									{two.									returnThree}								locals: #()))).			two.			returnThree}		locals: #().	self		assert: inputAst		asStringEquals:			'(()=>{if(true==1){2;if(false==1){2};return 3}else{return ()=>{2;return 3}};2;return 3})'.	inputAst := PjBlockNode		parameters: #(a)		locals: #(d)		body:			{(PjIfTrueNode				test: falseNode				whenTrue:					(PjSequenceNode						expressions:							{(PjAssignNode								target: (PjTempVariableNode identifier: #d)								expression: trueNode)})).			(PjAssignNode				target: (PjTempVariableNode identifier: #d)				expression: falseNode).			(PjReturnNode expression: (PjArgumentNode identifier: #a))}.	self		assert: inputAst		asStringEquals: '((a)=>{var d;if(true==false){d=true};d=false;return a})'.	inputAst := PjBlockNode		parameters: #(a)		locals: #(d)		body:			{(PjIfTrueNode				test: falseNode				whenTrue: (PjSequenceNode expressions: #())).			(PjAssignNode				target: (PjTempVariableNode identifier: #d)				expression: falseNode).			(PjReturnNode expression: (PjArgumentNode identifier: #a))}.	self		assert: inputAst		asStringEquals: '((a)=>{var d;if(true==false){};d=false;return a})'! !!PjGenerationOptimizationTest methodsFor: 'testing'!testToDo	| in a xNode temp1 temp2 |	a := PjTempVariableNode identifier: #a.	in := PjTempVariableNode identifier: #in.	temp1 := PjTempVariableNode identifier: '$1'.	temp2 := PjTempVariableNode identifier: '$2'.	xNode := PjArgumentNode identifier: #x.	self		assert: (PjForLoopNode			from: (PjAssignNode target: xNode expression: one)			to: three			by: nil			body:  {				PjAssignNode					target: in					expression: xNode.				PjReturnNode expression: a			})		asStringEquals: 'for(var x=1;x<=3;++x){$in=x;return a}'.	self		assert: (PjForLoopNode			from: (PjAssignNode target: xNode expression: three)			to: one			by: minusOne			body:  {				PjAssignNode					target: in					expression: xNode.				PjReturnNode expression: a			})		asStringEquals: 'for(var x=3;x>=1;--x){$in=x;return a}'.	self		assert: (PjForLoopNode			from: (PjAssignNode target: xNode expression: one)			to: (PjAssignNode target: temp1 expression: a)			by: (PjAssignNode target: temp2 expression: in)			body:  {				PjAssignNode					target: in					expression: xNode.				PjReturnNode expression: a			})		asStringEquals: 'for(var x=1,$1=a,$2=$in;$2>=0?x<=$1:x>=$1;x+=$2){$in=x;return a}'.	self		assert: (PjForLoopNode			from: (PjAssignNode target: xNode expression: one)			to: (PjAssignNode target: temp1 expression: a)			by: minusTwo			body:  {				PjAssignNode					target: in					expression: xNode.				PjReturnNode expression: a			})		asStringEquals: 'for(var x=1,$1=a;x>=$1;x+=-2){$in=x;return a}'.! !!PjGenerationOptimizationTest methodsFor: 'testing'!testWhile	| for a in |	for := PjTempVariableNode identifier: #for.	a := PjTempVariableNode identifier: #a.	in := PjTempVariableNode identifier: #in.	self		assert: (PjWhileNode test: selfNode body:  {				PjAssignNode					target: in					expression: for.				PjReturnNode expression: a			})		asStringEquals: 'while(true==this){$in=$for;return a}'.	self		assert: (PjWhileNode test: (PjSequenceNode expressions: {selfNode. in}) body:  {})		asStringEquals: 'while(true==(this,$in)){}'.	self		assert: (PjWhileNode test: selfNode not body:  {				PjAssignNode					target: in					expression: for.				PjReturnNode expression: a			})		asStringEquals: 'while(false==this){$in=$for;return a}'.	self		assert: (PjWhileNode test: (PjSequenceNode expressions: {selfNode. in}) not body:  {})		asStringEquals: 'while(false==(this,$in)){}'.! !!PjConversionOptimizationTest methodsFor: 'testing'!assertUnoptimizedContentsOf: aBlock	| actualJsAst |	actualJsAst := self convertFirstStatementOfBlock: aBlock.	self assert: actualJsAst class = PjApplyNode! !!PjConversionOptimizationTest methodsFor: 'testing'!testAnd	| expectedAst y returnAst |	y := PjTempVariableNode identifier: #y.	messageConverter addAllConversions: {PjAndOptimization}. 	expectedAst := PjIfTrueIfFalseNode 		test: y		whenTrue: one		whenFalse: falseNode.	returnAst := PjIfTrueIfFalseNode 		test: y		whenTrue: returnOne		whenFalse: returnFalse.	self assertContentsOf: [ ^ y and: [1]] convertsTo: returnAst.	self assertContentsOf: [ ^ y and: 1] convertsTo: returnAst.	self assertContentsOf: [ y and: [1]] convertsTo: expectedAst.	self assertContentsOf: [ y and: 1] convertsTo: expectedAst.! !!PjConversionOptimizationTest methodsFor: 'testing'!testBlockReturns	| expectedAst tempId temp xArg |	messageConverter		addAllConversions:			{PjIfNilOptimization.			PjIfNotNilOptimization.			PjIfTrueOptimization.			PjIfTrueIfFalseOptimization}.	expectedAst := self		simpleBlock:			{three.			two.			(PjIfTrueIfFalseNode				test: one				whenTrue: returnOne				whenFalse: returnNil)}		locals: #().	self		assertContentsOf: [ [ 3.			2.			1				ifTrue: [ 1 ] ] ]		convertsTo: expectedAst.	expectedAst := self		simpleBlock:			{three.			two.			(PjIfTrueIfFalseNode				test: one				whenTrue: throwTwo				whenFalse: throwOne)}		locals: #().	self		assertContentsOf: [ [ 3.			2.			^ 1				ifTrue: [ 2 ]				ifFalse: [ 1 ] ] ]		convertsTo: expectedAst.	expectedAst := self		simpleBlock:			{three.			two.			(PjIfNilIfNotNilNode				test: one				whenNotNil: throwOne				whenNil: throwNil)}		locals: #().	self		assertContentsOf: [ [ 3.			2.			^ 1 ifNotNil: [ 1 ] ] ]		convertsTo: expectedAst.	xArg := PjArgumentNode identifier: #x.	expectedAst := self		simpleBlock:			{three.			two.			(PjIfNilIfNotNilNode				test: (PjAssignNode target: xArg expression: one)				whenNotNil: (PjNonLocalReturnNode expression: xArg)				whenNil: throwNil)}		locals: #(x).	self		assertContentsOf: [ [ 3.			2.			^ 1 ifNotNil: [ :x | x ] ] ]		convertsTo: expectedAst.	tempId := '$1'.	temp := PjTempVariableNode identifier: tempId asSymbol.	expectedAst := self		simpleBlock:			{three.			two.			(PjIfNilIfNotNilNode				test: (PjAssignNode target: temp expression: one)				whenNotNil: (PjReturnNode expression: temp)				whenNil: returnOne)}		locals: #('$1').	self		assertContentsOf: [ [ 3.			2.			1 ifNil: [ 1 ] ] ]		convertsTo: expectedAst.	expectedAst := self		simpleBlock:			{three.			two.			(PjIfNilIfNotNilNode				test: (PjAssignNode target: temp expression: one)				whenNotNil: (PjNonLocalReturnNode expression: temp)				whenNil: throwOne)}		locals: #('$1').	self		assertContentsOf: [ [ 3.			2.			^ 1 ifNil: [ 1 ] ] ]		convertsTo: expectedAst! !!PjConversionOptimizationTest methodsFor: 'testing'!testBlockReturns1	| expectedAst |	messageConverter		addAllConversions:			{PjIfNilOptimization.			PjIfNotNilOptimization.			PjIfTrueOptimization.			PjIfTrueIfFalseOptimization}.	expectedAst := self		simpleBlock: {three. two. (PjIfTrueIfFalseNode test: one whenTrue: returnTwo whenFalse: returnOne)}		locals: #().	self 		assertContentsOf: [ [ 3. 2. 1 ifTrue: [ 2 ] ifFalse: [ 1 ] ] ]		convertsTo: expectedAst.	expectedAst := self		simpleBlock: {three. two. (PjIfTrueIfFalseNode test: one whenTrue: throwTwo whenFalse: returnOne)}		locals: #().	self		assertContentsOf: [ [ 3. 2. 1 ifTrue: [ ^ 2 ] ifFalse: [ 1 ] ] ]		convertsTo: expectedAst.	expectedAst := self		simpleBlock: {PjIfTrueIfFalseNode test: one whenTrue: two whenFalse: one. returnTwo}		locals: #().	self		assertContentsOf: [ [ 1 ifTrue: [ 2 ] ifFalse: [ 1 ]. 2 ] ]		convertsTo: expectedAst.	expectedAst := self		simpleBlock: {three. two. (PjIfTrueIfFalseNode test: (PjIfTrueIfFalseNode test: one whenTrue: two whenFalse: one) whenTrue: returnTwo whenFalse: returnOne)}		locals: #().	self		assertContentsOf: [ [ 3. 2. (1 ifTrue: [ 2 ] ifFalse: [ 1 ]) ifTrue: [ 2 ] ifFalse: [ 1 ] ] ]		convertsTo: expectedAst.! !!PjConversionOptimizationTest methodsFor: 'testing'!testComparisons	| y x |	y := PjTempVariableNode identifier: #y.	x := PjTempVariableNode identifier: #x.	messageConverter addAllConversions: PjComparisonOptimization allSubclasses.	self assertContentsOf: [ x=y ]			convertsTo: (PjApplyNode receiver: x selector: #= args: {y}).	self assertContentsOf: [ 1=y ] convertsTo: (PjBinaryNode operator: #== left: one right: y).	self assertContentsOf: [ x='foo' ] convertsTo: (PjBinaryNode operator: #== left: x right: foo).	self assertContentsOf: [ x~=y ]			convertsTo: (PjApplyNode receiver: x selector: #~= args: {y}).	self assertContentsOf: [ x<=y ] convertsTo: (PjBinaryNode operator: #<= left: x right: y).	self assertContentsOf: [ x~~y ] convertsTo: (PjBinaryNode operator: #!!== left: x right: y).	self assertContentsOf: [ x==y ] convertsTo: (PjBinaryNode operator: #=== left: x right: y).	self assertContentsOf: [ 1~=y ] convertsTo: (PjBinaryNode operator: #!!= left: one right: y).! !!PjConversionOptimizationTest methodsFor: 'testing'!testIfFalse	| expectedAst y returnAst |	y := PjTempVariableNode identifier: #y.	messageConverter addAllConversions: {PjIfFalseOptimization}. 	expectedAst := PjIfTrueNode 		test: y not		whenTrue: one.	returnAst := PjIfTrueIfFalseNode 		test: y		whenTrue: returnNil		whenFalse: returnOne.	self assertContentsOf: [ ^ y ifFalse: [1]] convertsTo: returnAst.	self assertContentsOf: [ ^ y ifFalse: 1] convertsTo: returnAst.	self assertContentsOf: [ y ifFalse: [1]] convertsTo: expectedAst.	self assertContentsOf: [ y ifFalse: 1] convertsTo: expectedAst.! !!PjConversionOptimizationTest methodsFor: 'testing'!testIfFalseifTrue	| expectedAst y |	y := PjTempVariableNode identifier: #y.	messageConverter addAllConversions: {PjIfFalseIfTrueOptimization. PjNotOptimization}.	expectedAst := PjIfTrueIfFalseNode 		test: y		whenTrue: one 		whenFalse: two. 	self assertContentsOf: [ y ifFalse: [2] ifTrue: [1]] convertsTo: expectedAst.	self assertContentsOf: [ y ifFalse: 2 ifTrue: 1] convertsTo: expectedAst.	expectedAst := PjIfTrueIfFalseNode 		test: y not		whenTrue: one		whenFalse: two. 	self assertContentsOf: [ y not ifFalse: [2] ifTrue: [1]] convertsTo: expectedAst.	self assertContentsOf: [ y not ifFalse: 2 ifTrue: 1] convertsTo: expectedAst.! !!PjConversionOptimizationTest methodsFor: 'testing'!testIfNil	| expectedAst tempVariable tempVariableName y |	y := PjTempVariableNode identifier: #y.	messageConverter addAllConversions: {PjIfNilOptimization}.	tempVariableName := PjStringGenerator tempNamePrefix , '1'.	tempVariable := PjTempVariableNode		identifier: tempVariableName asSymbol.	expectedAst := PjIfNilIfNotNilNode		test:			(PjAssignNode				target: tempVariable				expression: (self apply: y selector: #foo))		whenNotNil: (PjReturnNode expression: tempVariable)		whenNil: returnOne.	self		assertContentsOf: [ ^ y foo ifNil: [ 1 ] ]		convertsTo: expectedAst.	expectedAst := self simpleBlock: expectedAst locals: #('$1').	self		assertContentsOf: [ [ y foo ifNil: [ 1 ] ] ]		convertsTo: expectedAst.	expectedAst := PjIfNilIfNotNilNode		test:			(PjAssignNode				target: tempVariable				expression: (self apply: y selector: #foo))		whenNotNil: (PjNonLocalReturnNode expression: tempVariable)		whenNil: throwOne.	expectedAst := self simpleBlock: expectedAst locals: #('$1').	self		assertContentsOf: [ [ ^ y foo ifNil: [ 1 ] ] ]		convertsTo: expectedAst.	expectedAst := PjIfNilNode		test: (self apply: y selector: #foo)		whenNil: one.	self assertContentsOf: [ y foo ifNil: [ 1 ] ] convertsTo: expectedAst! !!PjConversionOptimizationTest methodsFor: 'testing'!testIfNilIfNotNil	| expectedAst y |	y := PjTempVariableNode identifier: #y.	messageConverter addAllConversions: {PjIfNilIfNotNilOptimization}. 	expectedAst := PjIfNilIfNotNilNode 		test: y		whenNotNil: two		whenNil: one. 	self assertContentsOf: [ y ifNil: [1] ifNotNil: [2]] convertsTo: expectedAst.	self assertContentsOf: [ y ifNil: 1 ifNotNil: 2] convertsTo: expectedAst.		expectedAst := PjIfNilIfNotNilNode 		test: (PjAssignNode			target: (PjArgumentNode identifier: #x)			 expression: y) 		whenNotNil: (PjArgumentNode identifier: #x)		whenNil: one.	self assertContentsOf: [ y ifNil: [1 ] ifNotNil: [: x | x]] convertsTo: expectedAst.! !!PjConversionOptimizationTest methodsFor: 'testing'!testIfNotNil	| expectedAst y |	y := PjTempVariableNode identifier: #y.	messageConverter addAllConversions: {PjIfNotNilOptimization}.	expectedAst := PjIfNotNilNode		test: y		whenNotNil: one. 	self assertContentsOf: [y ifNotNil: [1]] convertsTo: expectedAst.	expectedAst := PjIfNotNilNode 		test: (PjAssignNode			target: (PjArgumentNode identifier: #x)			 expression: y)		whenNotNil: (PjArgumentNode identifier: #x).	self assertContentsOf: [y ifNotNil: [: x | x]] convertsTo: expectedAst.	expectedAst := PjIfNilIfNotNilNode 		test: y		whenNotNil: returnOne		whenNil:  returnNil. 	self assertContentsOf: [ ^ y ifNotNil: [1]] convertsTo: expectedAst.	expectedAst := PjIfNilIfNotNilNode 		test: (PjAssignNode			target: (PjArgumentNode identifier: #x)			 expression: y)		whenNotNil: (PjReturnNode expression: (PjArgumentNode identifier: #x))		whenNil: returnNil.	self assertContentsOf: [ ^ y ifNotNil: [: x | x]] convertsTo: expectedAst.! !!PjConversionOptimizationTest methodsFor: 'testing'!testIfNotNilifNil	| expectedAst y |	y := PjTempVariableNode identifier: #y.	messageConverter addAllConversions: {PjIfNotNilIfNilOptimization. PjNotOptimization}. 	expectedAst := PjIfNilIfNotNilNode 			test:  (self apply: y selector: #foo)			whenNotNil: returnOne			whenNil: returnNil.	self assertContentsOf: [ ^y foo ifNotNil: [1] ifNil: []] convertsTo: expectedAst.	expectedAst := PjIfNilIfNotNilNode 			test:  (self apply: y selector: #foo)			whenNotNil: (PjAssignNode target: y expression: one)			whenNil: (PjAssignNode target: y expression: two).	self assertContentsOf: [			y foo ifNotNil: [				y:=1			] ifNil: [				y:=2			]] convertsTo: expectedAst! !!PjConversionOptimizationTest methodsFor: 'testing'!testIfTrue	| expectedAst y returnAst |	y := PjTempVariableNode identifier: #y.	messageConverter addAllConversions: {PjIfTrueOptimization}. 	expectedAst := PjIfTrueNode 		test: y		whenTrue: one.	returnAst := PjIfTrueIfFalseNode 		test: y		whenTrue: returnOne		whenFalse: returnNil.	self assertContentsOf: [ y ifTrue: [1]] convertsTo: expectedAst.	self assertContentsOf: [ y ifTrue: 1] convertsTo: expectedAst.	self assertContentsOf: [ ^ y ifTrue: [1]] convertsTo: returnAst.	self assertContentsOf: [ ^ y ifTrue: 1] convertsTo: returnAst.	expectedAst := PjIfTrueNode 		test: y		whenTrue: (PjSequenceNode expressions: {one. two}).	self assertContentsOf: [ y ifTrue: [1. 2.] ] convertsTo: expectedAst.! !!PjConversionOptimizationTest methodsFor: 'testing'!testIfTrueIfFalse	| expectedAst y returnAst |	y := PjTempVariableNode identifier: #y.	messageConverter addAllConversions: {PjIfTrueIfFalseOptimization}. 	expectedAst := PjIfTrueIfFalseNode 		test: y		whenTrue: one 		whenFalse: two.	returnAst := PjIfTrueIfFalseNode 		test: y		whenTrue: returnOne		whenFalse: returnTwo.	self assertContentsOf: [ y ifTrue: [1] ifFalse: [2]] convertsTo: expectedAst.	self assertContentsOf: [ y ifTrue: 1 ifFalse: 2] convertsTo: expectedAst.	self assertContentsOf: [ ^ y ifTrue: [1] ifFalse: [2]] convertsTo: returnAst.	self assertContentsOf: [ ^ y ifTrue: 1 ifFalse: 2] convertsTo: returnAst.! !!PjConversionOptimizationTest methodsFor: 'testing'!testInlineBlockReturns	| expectedAst |	messageConverter		addAllConversions:			{PjIfTrueOptimization.			PjIfTrueIfFalseOptimization}.	expectedAst := self		simpleBlock:			{(PjIfTrueIfFalseNode				test: one				whenTrue:					(PjSequenceNode						expressions:							{two.							returnThree})				whenFalse:					(PjReturnNode						expression:							(self								simpleBlock:									{two.									returnThree}								locals: #())))}		locals: #().	self		assertContentsOf: [ [ 1				ifTrue: [ 2.					3 ]				ifFalse: [ [ 2.					3 ] ] ] ]		convertsTo: expectedAst.	expectedAst := self		simpleBlock:			{(PjIfTrueIfFalseNode				test: one				whenTrue:					(PjSequenceNode						expressions:							{two.							three})				whenFalse:					(PjSequenceNode						expressions:							{one.							(self								simpleBlock:									{two.									returnThree}								locals: #())})).			returnOne}		locals: #().	self		assertContentsOf: [ [ 1				ifTrue: [ 2.					3 ]				ifFalse: [ 1.					[ 2.					3 ] ].			1 ] ]		convertsTo: expectedAst! !!PjConversionOptimizationTest methodsFor: 'testing'!testInlineBlockTempvars	| expectedAst block |	messageConverter		addAllConversions: {PjIfTrueOptimization.PjTimesRepeatOptimization}.	block := [ [ self ifTrue: [ |w| w ] ] ].	expectedAst := PjBlockNode parameters:{} locals:{#w} body:{		PjIfTrueIfFalseNode test: (PjSelfNode new inBlock: true)			whenTrue:(PjReturnNode expression:(PjTempVariableNode identifier:#w))			whenFalse:(PjReturnNode expression:PjNilNode new)}.	self assertContentsOf: block convertsTo: expectedAst.	block := [ [ 3 timesRepeat: [ |w| w ] ] ].	expectedAst := PjBlockNode parameters:{} locals:#(w '$1') body:{		PjForLoopNode			from:(PjAssignNode target:(PjTempVariableNode identifier:'$1') expression:(PjLiteralValueNode value:1))			to:(PjLiteralValueNode value:3)			by:nil			body:{PjAssignNode target:(PjTempVariableNode identifier:#w) expression:PjNilNode new.PjTempVariableNode identifier:#w}}.	self assertContentsOf: block convertsTo: expectedAst.! !!PjConversionOptimizationTest methodsFor: 'testing'!testMethodReturns1	| expectedBody expectedAst |	messageConverter		addAllConversions: {PjIfTrueOptimization. PjIfTrueIfFalseOptimization}.	expectedBody := {three.	two.	(PjIfTrueIfFalseNode test: one whenTrue: returnTwo whenFalse: one).	returnSelf}.	expectedAst := PjMethodNode		methodName: #return1		body: expectedBody.	self assertMethod: #return1 convertsTo: expectedAst! !!PjConversionOptimizationTest methodsFor: 'testing'!testMethodReturns2And3	| expectedBody expectedAst |	messageConverter		addAllConversions: {PjIfTrueOptimization. PjIfTrueIfFalseOptimization}.	expectedBody := {three.	two.	(PjIfTrueIfFalseNode		test: one		whenTrue: returnTwo		whenFalse: returnOne)}.	#(#return2 #return3)		do: [ :selector | 			expectedAst := PjMethodNode				methodName: selector				body: expectedBody.			self assertMethod: selector convertsTo: expectedAst ]! !!PjConversionOptimizationTest methodsFor: 'testing'!testMethodReturns4	| expectedBody expectedAst |	messageConverter		addAllConversions: {PjIfTrueOptimization. PjIfTrueIfFalseOptimization}.	expectedBody := {three.	two.	(PjIfTrueIfFalseNode		test: (PjIfTrueIfFalseNode test: two whenTrue: throwSelf whenFalse: three)		whenTrue: returnTwo		whenFalse: returnOne)}.	expectedAst := PjMethodNode		methodName: #return4		body: {PjTryNode body: expectedBody}.	self assertMethod: #return4 convertsTo: expectedAst! !!PjConversionOptimizationTest methodsFor: 'testing'!testOr	| expectedAst y returnAst |	y := PjTempVariableNode identifier: #y.	messageConverter addAllConversions: {PjOrOptimization}. 	expectedAst := PjIfTrueIfFalseNode 		test: y		whenTrue: trueNode		whenFalse: one.	returnAst := PjIfTrueIfFalseNode 		test: y		whenTrue: returnTrue		whenFalse: returnOne.	self assertContentsOf: [ ^ y or: [1]] convertsTo: returnAst.	self assertContentsOf: [ ^ y or: 1] convertsTo: returnAst.	self assertContentsOf: [ y or: [1]] convertsTo: expectedAst.	self assertContentsOf: [ y or: 1] convertsTo: expectedAst.! !!PjConversionOptimizationTest methodsFor: 'testing'!testStringConcatenation	messageConverter		addAllConversions: {PjStringAppendOptimization}.	self assertContentsOf: [ 'hello',1 ] convertsTo: (PjBinaryNode operator: #+ left: helloString right: one).	self assertContentsOf: [ 1,'hello' ] convertsTo: (PjApplyNode receiver: one selector: #, args: {helloString}).	self assertContentsOf: [ 'hello',1,2 ] convertsTo: (PjBinaryNode operator: #+ left: (PjBinaryNode operator: #+ left: helloString right: one) right: two).! !!PjConversionOptimizationTest methodsFor: 'testing'!testTimesRepeat	| in a temp1 temp2 |	a := PjTempVariableNode identifier: #a.	in := PjTempVariableNode identifier: #in.	temp1 := PjTempVariableNode identifier: '$1'.	temp2 := PjTempVariableNode identifier: '$2'.	messageConverter addAllConversions: {		PjTimesRepeatOptimization	}.	self		assertContentsOf: [ 3 timesRepeat: [ a := 1]]		convertsTo: (PjForLoopNode			from: (PjAssignNode target: temp1 expression: one)			to: three			by: nil			body:  {				PjAssignNode					target: a					expression: one			}).	self		assertContentsOf: [ in timesRepeat: [ a := 1]]		convertsTo: (PjForLoopNode			from: (PjAssignNode target: temp1 expression: one)			to: (PjAssignNode target: temp2 expression: in)			by: nil			body:  {				PjAssignNode					target: a					expression: one			}).! !!PjConversionOptimizationTest methodsFor: 'testing'!testToDo	<expectedFailure> " temporarily disabled optimization "	| in a xNode temp1 temp2 |	a := PjTempVariableNode identifier: #a.	in := PjTempVariableNode identifier: #in.	temp1 := PjTempVariableNode identifier: '$1'.	temp2 := PjTempVariableNode identifier: '$2'.	messageConverter addAllConversions: {		PjToDoOptimization. PjToByDoOptimization	}. 	self		assertUnoptimizedContentsOf: [ 1 to: 10 do: [ in := 3. ^ a]].	xNode := PjArgumentNode identifier: #x.	self		assertContentsOf: [ 1 to: 3 do: [:x| in := x. ^ a]]		convertsTo: (PjForLoopNode			from: (PjAssignNode target: xNode expression: one)			to: three			by: nil			body:  {				PjAssignNode					target: in					expression: xNode.				PjReturnNode expression: a			}).	self		assertContentsOf: [ 3 to: 1 by: -1 do: [:x| in := x. ^ a]]		convertsTo: (PjForLoopNode			from: (PjAssignNode target: xNode expression: three)			to: one			by: minusOne			body:  {				PjAssignNode					target: in					expression: xNode.				PjReturnNode expression: a			}).	self		assertContentsOf: [ 1 to: a by: in do: [:x| in := x. ^ a]]		convertsTo: (PjForLoopNode			from: (PjAssignNode target: xNode expression: one)			to: (PjAssignNode target: temp1 expression: a)			by: (PjAssignNode target: temp2 expression: in)			body:  {				PjAssignNode					target: in					expression: xNode.				PjReturnNode expression: a			}).	self		assertContentsOf: [ 1 to: a by: -2 do: [:x| in := x. ^ a]]		convertsTo: (PjForLoopNode			from: (PjAssignNode target: xNode expression: one)			to: (PjAssignNode target: temp1 expression: a)			by: minusTwo			body:  {				PjAssignNode					target: in					expression: xNode.				PjReturnNode expression: a			}).! !!PjConversionOptimizationTest methodsFor: 'testing'!testWhile	| for in a |	for := PjTempVariableNode identifier: #for.	a := PjTempVariableNode identifier: #a.	in := PjTempVariableNode identifier: #in.	messageConverter addAllConversions: {		PjWhileTrueOptimization. PjWhileTrueDoOptimization.		PjWhileFalseOptimization. PjWhileFalseDoOptimization.	}. 	self		assertContentsOf: [ [self] whileTrue: [ in := for. ^ a]]		convertsTo: (PjWhileNode test: selfNode body:  {				PjAssignNode					target: in					expression: for.				PjReturnNode expression: a			}).	self		assertContentsOf: [ [self. in] whileTrue ]		convertsTo: (PjWhileNode test: (PjSequenceNode expressions: {selfNode. in}) body:  {}).	self		assertContentsOf: [ [self] whileFalse: [ in := for. ^ a]]		convertsTo:  (PjWhileNode test: selfNode not body:  {				PjAssignNode					target: in					expression: for.				PjReturnNode expression: a			}).	self		assertContentsOf: [ [self. in] whileFalse ]		convertsTo: (PjWhileNode test: (PjSequenceNode expressions: {selfNode. in}) not body:  {}).	self		assertContentsOf: [ self foo: [[self. in] whileFalse] ]		convertsTo: (PjApplyNode receiver: selfNode selector: #foo: args: (PjBlockNode parameters: #() locals: #() body: {PjWhileNode test: (PjSequenceNode expressions: {selfNodeInBlock. in}) not body:  {}}) asOrderedCollection).! !!PjOptimizedMethods methodsFor: 'asserting'!shouldReturnTrue    false        ifTrue: [ 1 ifNil: [  ] ]        ifFalse: [ 1 ifNil: [  ].            ^ true ].    ^ false! !!PjOptimizedMethods methodsFor: 'asserting'!shouldReturnTrue2    false        ifTrue: [ 1 ifNil: [  ] ]        ifFalse: [ 1 ifNotNil: [ ^ true ].            ^ true ].    ^ false! !!PjAstOptimizationTest methodsFor: 'testing'!testNotTransformation	| v1 v2 |	v1 := PjTempVariableNode identifier: #v1.	v2 := PjTempVariableNode identifier: #v2.	self assert: selfNode not equals: (PjUnaryNode operator: #!! expression: selfNode).	self assert: (PjUnaryNode operator: #!! expression: selfNode) not equals: selfNode.	self assert: selfNode not not equals: selfNode.	self assert: (PjBinaryNode operator: #< left: v1 right: v2) not equals: (PjBinaryNode operator: #< left: v2 right: v1)! !"PharoJs-Base-Transpiler-Optimizations-Tests"!!PhxPharoJsonSerialisationTests methodsFor: 'tests'!testArraysCircularReferences	| cClone aClone bClone a b c |	a := {'A'. nil. nil. nil}.	b := {'B'. nil. nil. nil }.	c := {'C'. nil. nil. nil }.	{ a. b. c } do: [ : each |		each at: 2 put: a.		each at: 3 put: b.		each at: 4 put: c.	].	cClone := PhxJsonReader readFromString: c asPhxJsonString.	aClone := cClone second.	bClone := cClone third.	{ aClone. bClone. cClone.}  with: #(A B C) do: [ : each : name |		self assert: each size equals: 4.		self assert: each first equals: name.		self assert: each second identicalTo: aClone.		self assert: each third identicalTo: bClone.		self assert: each last identicalTo: cClone.	].! !!PhxPharoJsonSerialisationTests methodsFor: 'tests'!testDictionariesReferencingEachOther	| cClone bClone aInBClone aInCClone  a b c |	a := Dictionary new.	a at: #name put: 'A'.	b := Dictionary new.	b at: #name put: 'B'.	b at: #a put: a.	c := Dictionary new.	c at: #name put: 'C'.	c at: #a put: a.	c at: #b put: b.	cClone := PhxJsonReader readFromString: c asPhxJsonString.	self assert: cClone size equals: 3.	self assert: (cClone at: #name) equals: 'C'.	aInCClone := cClone at: #a.	self deny: aInCClone isNil.	self assert: aInCClone size equals: 1.	self assert: (aInCClone at: #name) equals: 'A'.	bClone := cClone at: #b.	self deny: bClone isNil.	self assert: bClone size equals: 2.	self assert: (bClone at: #name) equals: 'B'.	aInBClone := bClone at: #a.	self assert: aInBClone identicalTo: aInCClone.! !!PhxPharoJsonSerialisationTests methodsFor: 'tests'!testDictionariesWithCircularReferences	| cClone aClone bClone  a b c |	a := Dictionary new.	a at: #name put: 'A'.	b := Dictionary new.	b at: #name put: 'B'.	c := Dictionary new.	c at: #name put: 'C'.	{ a. b. c } do: [ : each |		each at: #a put: a.		each at: #b put: b.		each at: #c put: c.	].	cClone := PhxJsonReader readFromString: c asPhxJsonString.	aClone := cClone at: #a.	bClone := cClone at: #b.	{ aClone. bClone. cClone.}  with: #(A B C) do: [ : each : name |		self assert: each size equals: 4.		self assert: (each at: #name) equals: name.		self assert: (each at: #a) identicalTo: aClone.		self assert: (each at: #b) identicalTo: bClone.		self assert: (each at: #c) identicalTo: cClone.	].! !!PhxPharoJsonSerialisationTests methodsFor: 'tests'!testOrderedCollectionsCircularReferences	| cClone aClone bClone a b c |	a := #('A') asOrderedCollection.	b := #('B') asOrderedCollection.	c := #('C') asOrderedCollection.	{ a. b. c } do: [ : each |		each add: a.		each add: b.		each add: c.	].	cClone := PhxJsonReader readFromString: c asPhxJsonString.	aClone := cClone second.	bClone := cClone third.	{ aClone. bClone. cClone.}  with: #(A B C) do: [ : each : name |		self assert: each size equals: 4.		self assert: each first equals: name.		self assert: each second identicalTo: aClone.		self assert: each third identicalTo: bClone.		self assert: each last identicalTo: cClone.	].! !!PhxPharoJsonSerialisationTests methodsFor: 'tests'!testProperInstRefOrderWhenUsingCollections	| obj problemObject string |	obj := Object new.	problemObject := {obj.	{obj}}.	string := problemObject asPhxJsonString.	self shouldnt: [ PhxJsonReader readFromString: string ] raise: Error! !!PhxPharoJsonSerialisationTests methodsFor: 'tests'!testSetsCircularReferences	<expectedFailure>	| cClone aClone bClone  a b c |	self fail: 'Pharo bug: Infinite recursion upon adding cross set references'.	a := #('A') asSet.	b := {'B'} asSet.	c := {'C'} asSet.	{ a. b. c } do: [ : each |		each add: a.		each add: b.		each add: c.	].	cClone := PhxJsonReader readFromString: c asPhxJsonString.	aClone := cClone detect: [: each | each includes: 'A'].	bClone := cClone detect: [: each | each includes: 'B'].	{ aClone. bClone. cClone.} with: #(A B C) do: [ : each : name |		self assert: each size equals: 4.		self assert: (each includes: name).		{ aClone. bClone. cClone.} do: [ : expectedElement |			self assert: (each includes: expectedElement) ]	].! !!PhxPharoJsonSerialisationTests methodsFor: 'tests'!testSetsReferencingEachOther	| cClone bClone a b c aInBClone aInCClone |	a := #( 'AAAA' ) asSet.	b := { 		     'BBBB'.		     a } asSet.	c := { 		     'CCCC'.		     a.		     b } asSet.	cClone := PhxJsonReader readFromString: c asPhxJsonString.	self assert: cClone size equals: 3.	self assert: (cClone includes: 'CCCC').	self deny: (cClone includes: cClone).	bClone := cClone detect: [ :each | each size = 2 ].	self assert: (bClone includes: 'BBBB').	self deny: (bClone includes: bClone).	aInBClone := bClone detect: [ :each | each size = 1 ].	self assert: aInBClone size equals: 1.	self assert: (aInBClone includes: 'AAAA').	aInCClone := cClone detect: [ :each | each size = 1 ].	self assert: aInBClone identicalTo: aInCClone! !!PhxJsonObjectForTestWithAlphabeticallyOrderedIVs methodsFor: 'accessing'!aaaa	^ aaaa! !!PhxJsonObjectForTestWithAlphabeticallyOrderedIVs methodsFor: 'accessing'!aaaa: anObject	aaaa := anObject! !!PhxJsonObjectForTestWithAlphabeticallyOrderedIVs methodsFor: 'accessing'!bbbb	^ bbbb! !!PhxJsonObjectForTestWithAlphabeticallyOrderedIVs methodsFor: 'accessing'!bbbb: anObject	bbbb := anObject! !!PhxJsonObjectForTestWithAlphabeticallyOrderedIVs methodsFor: 'accessing'!cccc	^ cccc! !!PhxJsonObjectForTestWithAlphabeticallyOrderedIVs methodsFor: 'accessing'!cccc: anObject	cccc := anObject! !!PhxJsonTestResources class methodsFor: 'tests'!challengingStringRequiringUnicodeAndEscapement	^ 'Hi <there>, I''m just a "String", and I cost only 2. Ol!!'! !!PhxJsonTestResources class methodsFor: 'tests'!challingingObjectAvoidingDateAndTime	| org |	org := PhxJsonTestResources objectWithLiteralIVs.	^ {org.	org.	'Hello "world"'.	123.	1.33.	{org.	org.	self challengingStringRequiringUnicodeAndEscapement.	123.	1.33}}! !!PhxJsonTestResources class methodsFor: 'tests'!objectGraphWithCycleOfLength1	| leaf1 leaf2 node root |	leaf1 := PhxJsonObjectForTestWithAlphabeticallyOrderedIVs new.	leaf2 := PhxJsonObjectForTestWithAlphabeticallyOrderedIVs new.	node := PhxJsonObjectForTestWithAlphabeticallyOrderedIVs new.	root := PhxJsonObjectForTestWithAlphabeticallyOrderedIVs new.	leaf1		aaaa: leaf1;		bbbb: 'Test org 1';		cccc: 'TestOrg1LegalForm1'.	leaf2		aaaa: 'TestOrg2';		bbbb: leaf2;		cccc: 'TestOrg1LegalForm2'.	node		aaaa: leaf1;		bbbb: leaf2;		cccc: node.	root		aaaa: leaf1;		bbbb: node;		cccc: leaf2.	^ root! !!PhxJsonTestResources class methodsFor: 'tests'!objectGraphWithCycleOfLength2	| leaf1 leaf2 node root |	leaf1 := PhxJsonObjectForTestWithAlphabeticallyOrderedIVs new.	leaf2 := PhxJsonObjectForTestWithAlphabeticallyOrderedIVs new.	node := PhxJsonObjectForTestWithAlphabeticallyOrderedIVs new.	root := PhxJsonObjectForTestWithAlphabeticallyOrderedIVs new.	leaf1		aaaa: node;		bbbb: 'Test org 1';		cccc: 'TestOrg1LegalForm1'.	leaf2		aaaa: 'TestOrg2';		bbbb: node;		cccc: 'TestOrg1LegalForm2'.	node		aaaa: leaf1;		bbbb: leaf2;		cccc: root.	root		aaaa: leaf1;		bbbb: node;		cccc: leaf2.	^ root! !!PhxJsonTestResources class methodsFor: 'tests'!objectGraphWithSharedLeaves	| leaf1 leaf2 node1 node2 node3 root |	leaf1 := PhxJsonObjectForTestWithAlphabeticallyOrderedIVs new.	leaf2 := PhxJsonObjectForTestWithAlphabeticallyOrderedIVs new.	node1 := PhxJsonObjectForTestWithAlphabeticallyOrderedIVs new.	node2 := PhxJsonObjectForTestWithAlphabeticallyOrderedIVs new.	node3 := PhxJsonObjectForTestWithAlphabeticallyOrderedIVs new.	root := PhxJsonObjectForTestWithAlphabeticallyOrderedIVs new.	leaf1		aaaa: 'stuff';		bbbb: 'Test org 1';		cccc: 'TestOrg1LegalForm1'.	leaf2		aaaa: 'TestOrg2';		bbbb: 'more stuff';		cccc: 'TestOrg1LegalForm2'.	node1		aaaa: leaf1;		bbbb: leaf2;		cccc: 'node2'.	node2		aaaa: node1;		bbbb: leaf2;		cccc: leaf1.	node3		aaaa: leaf2;		bbbb: leaf1;		cccc: node1.	root		aaaa: node3;		bbbb: node1;		cccc: node2.	^ root! !!PhxJsonTestResources class methodsFor: 'tests'!objectWithLiteralIVs	^ PhxJsonObjectForTestWithAlphabeticallyOrderedIVs new		  aaaa: 'TestOrg1';		  bbbb: 'Test org 1';		  cccc: 'TestOrg1LegalForm';		  yourself! !!PhxBridgedDateAndDateAndTimeTests methodsFor: 'tests'!testDateAndTimeNowEquivalence	| pharoTs jsTsString jsTs |	pharoTs := DateAndTime now.	jsTsString := self evalBlock: [ DateAndTime now toISOString ].	jsTs := DateAndTime fromString: jsTsString.	self assert: (pharoTs asSeconds - jsTs asSeconds) abs < 10.	self assert: (pharoTs asUTC asSeconds - jsTs asSeconds) abs < 10! !!PhxBridgedDateAndDateAndTimeTests methodsFor: 'tests'!testDateAndTimePhxJsonAlwaysUTC	| jsTs phxJson pharoTs pharoTs2 |	pharoTs := PhxJsonReader		readFromString: '{"class":"DateAndTime","instance":"2020-04-21T21:17:08.908+02:00"}'.	self assert: pharoTs offset = 2 hours.	pharoTs2 := PhxJsonReader readFromString: pharoTs asPhxJsonString.	self assert: pharoTs2 offset isZero.	phxJson := self		evalBlock: [ | ts |			ts := PhxJsonReader				readFromString: '{"class":"DateAndTime","instance":"2020-04-21T21:17:08.908+02:00"}'.			console log: ts.			ts asPhxJsonString	"always translates to UTC" ].	jsTs := PhxJsonReader readFromString: phxJson.	self assert: jsTs offset isZero! !!PhxBridgedDateAndDateAndTimeTests methodsFor: 'tests'!testDateAndTimeRefCountWhileMaterializing	| phxJson |	phxJson := self evalBlock: [ 		           | ts |		           ts := DateAndTime now.		           { 			           ts.			           ts } asPhxJsonString ].	self		shouldnt: [ PhxJsonReader readFromString: phxJson ]		raise: SubscriptOutOfBounds! !!PhxBridgedJsonSerialisationTests methodsFor: 'private'!assertAllWithInstantiationBlock: aBlock literal: jsonString testEq: testEq test4Stages: test4Stages	| instanceProxy |	instanceProxy := self evalBlock: aBlock.	self		assert: [ instanceProxy asPhxJsonString ]		evaluatesTo: jsonString.	testEq ifTrue: [ self assertEquivalent: aBlock ].	self isEqualAfterWriteReadInJs: aBlock.	test4Stages ifTrue: [ 		self isEqualAfter4StageMarshalingInBothWorlds: aBlock ]! !!PhxBridgedJsonSerialisationTests methodsFor: 'private'!isEqualAfter4StageMarshalingInBothWorlds: aBlock	| jsonStringOfObject objectProxy serializedInJsWorld materializedObjectSmalltalk serializedInSmalltalkWorld stringifiedAfterMaterializedInJsWorld |	objectProxy := self evalBlock: aBlock.	serializedInJsWorld := self evalBlock: [ objectProxy asPhxJsonString ].	materializedObjectSmalltalk := PhxJsonReader readFromString:		                               serializedInJsWorld.	serializedInSmalltalkWorld := materializedObjectSmalltalk		                              asPhxJsonString.	stringifiedAfterMaterializedInJsWorld := self evalBlock: [ 		                                         JSON stringify:			                                         (PhxJsonReader 				                                          readFromString:				                                          serializedInSmalltalkWorld) ].	jsonStringOfObject := self evalBlock: [ JSON stringify: objectProxy ].	self		assert: stringifiedAfterMaterializedInJsWorld		equals: jsonStringOfObject! !!PhxBridgedJsonSerialisationTests methodsFor: 'private'!isEqualAfterWriteReadInJs: aBlock	| jsonStringAfterWriteRead jsonStringOfObject instanceProxy instanceJsonInJsWorld |	instanceProxy := self evalBlock: aBlock.	instanceJsonInJsWorld := self evalBlock: [ 		                         instanceProxy asPhxJsonString ].	jsonStringAfterWriteRead := self evalBlock: [ 		                            JSON stringify:			                            (PhxJsonReader readFromString:				                             instanceProxy asPhxJsonString) ].	jsonStringOfObject := self evalBlock: [ 		                      JSON stringify: instanceProxy ].	self assert: jsonStringAfterWriteRead equals: jsonStringOfObject! !!PhxBridgedJsonSerialisationTests methodsFor: 'tests'!testSerializeArray	self		assertAllWithInstantiationBlock:  [{}]  		literal: '{"class":"Array","instance":[]}'		testEq: true		test4Stages: true! !!PhxBridgedJsonSerialisationTests methodsFor: 'tests'!testSerializeAssociations	self		assertAllWithInstantiationBlock: [{ 'een' -> 1. 'twee' -> 2 }  ]		literal: '{"class":"Array","instance":[{"class":"Association","instance":{"key":"een","value":1}},{"class":"Association","instance":{"key":"twee","value":2}}]}'		testEq: false		test4Stages: true! !!PhxBridgedJsonSerialisationTests methodsFor: 'tests'!testSerializeBoolean	self		assertAllWithInstantiationBlock: [ true  ]		literal: 'true'		testEq: true		test4Stages: true.	self		assertAllWithInstantiationBlock: [ false  ]		literal: 'false'		testEq: true		test4Stages: true! !!PhxBridgedJsonSerialisationTests methodsFor: 'tests'!testSerializeChallengingObject	self		assertAllWithInstantiationBlock: [ PhxJsonTestResources challingingObjectAvoidingDateAndTime  ]		literal: PhxJsonTestResources challingingObjectAvoidingDateAndTime asPhxJsonString		testEq: false		test4Stages: true! !!PhxBridgedJsonSerialisationTests methodsFor: 'tests'!testSerializeDate	<expectedFailure>	self fail: #ToDo.	self		assertAllWithInstantiationBlock: [ | d |			d := (DateAndTime				year: 2020				month: 04				day: 11				hour: 23				minute: 2				second: 3) asDate.			d  ]		literal: '{"class":"DateAndTime","instance":"2020-04-11T23:02:03.000Z"}'		testEq: true		test4Stages: true! !!PhxBridgedJsonSerialisationTests methodsFor: 'tests'!testSerializeDateAndTime	<expectedFailure>	self fail: #ToDo.	self		assertAllWithInstantiationBlock: [ | d |			d := DateAndTime				year: 2020				month: 04				day: 11				hour: 23				minute: 2				second: 3.			d  ]		literal: '{"class":"DateAndTime","instance":"2020-04-11T23:02:03.000Z"}'		testEq: true		test4Stages: true! !!PhxBridgedJsonSerialisationTests methodsFor: 'tests'!testSerializeDictionary	self		assertAllWithInstantiationBlock: [ | d |			d := Dictionary new.			d at: 'a' put: 'abc'.			d at: 'b' put: '123'.			d ]		literal: '{"class":"Dictionary","instance":{"a":"abc","b":"123"}}'		testEq: false "#assertEquivalent: doesn't work for this type of object"		test4Stages: true! !!PhxBridgedJsonSerialisationTests methodsFor: 'tests'!testSerializeDifferentObjectGraphs	| jsString pharoString |	#(objectGraphWithSharedLeaves objectGraphWithCycleOfLength2 objectGraphWithCycleOfLength1	   objectWithLiteralIVs ) do: [ :each | 		self assertEquivalent: [ 			(PhxJsonTestResources perform: each) asPhxJsonString ].		jsString := self evalBlock: [ 			            (PhxJsonTestResources perform: each) asPhxJsonString ].		self			shouldnt: [ PhxJsonReader readFromString: jsString ]			raise: Exception.		pharoString := (PhxJsonTestResources perform: each) asPhxJsonString.		self			shouldnt: [ 			self evalBlock: [ PhxJsonReader readFromString: pharoString ] ]			raise: Exception ]! !!PhxBridgedJsonSerialisationTests methodsFor: 'tests'!testSerializeEmptyObject	self		assertAllWithInstantiationBlock: [ Object new  ]		literal: '{"class":"Object","instance":{}}'		testEq: false "#assertEquivalent: doesn't work for this type of object"		test4Stages: true! !!PhxBridgedJsonSerialisationTests methodsFor: 'tests'!testSerializeIdentityDictionary1Entry	self		assertAllWithInstantiationBlock: [ 			| d |			d := IdentityDictionary new.			d at: 'b' put: '123'.			d ]		literal: '{"class":"IdentityDictionary","instance":{"b":"123"}}'		testEq: false "#assertEquivalent: doesn't work for this type of object"		test4Stages: true.	self		assertAllWithInstantiationBlock: [ 			| d |			d := IdentityDictionary new.			d at: 'a' put: 'abc'.			d ]		literal: '{"class":"IdentityDictionary","instance":{"a":"abc"}}'		testEq: false "#assertEquivalent: doesn't work for this type of object"		test4Stages: true! !!PhxBridgedJsonSerialisationTests methodsFor: 'tests'!testSerializeIdentityDictionary2Entries	"Entries in a dictionary are unordered. So, serialization may result into different valid results."	| serializationBlock validSerializationStrings jsSerialization pharoSerialization |	serializationBlock := [ | d |			d := IdentityDictionary new.			d at: 'a' put: 'abc'.			d at: 'b' put: '123'.			d asPhxJsonString ].	validSerializationStrings := #(		'{"class":"IdentityDictionary","instance":{"a":"abc","b":"123"}}'		'{"class":"IdentityDictionary","instance":{"b":"123","a":"abc"}}').	jsSerialization := self evalBlock: serializationBlock.	pharoSerialization := serializationBlock value.	{jsSerialization. pharoSerialization} do: [ : serialization |		self assert: (validSerializationStrings includes: serialization)	]! !!PhxBridgedJsonSerialisationTests methodsFor: 'tests'!testSerializeInstRefs	"objects should be checked by identity!!!!!!"	| a |	a := {}.	self		assert: [ {a.			a} asPhxJsonString ]		evaluatesTo:			'{"class":"Array","instance":[{"class":"Array","instance":[]},{"instRef":2}]}'.	self		assertEquivalent: [ {a.			a} asPhxJsonString ]! !!PhxBridgedJsonSerialisationTests methodsFor: 'tests'!testSerializeInstRefsAvoidWhenDifferentInstances	"objects should be checked by identity!!!!!!"	self		assert: [ {{}.			{}} asPhxJsonString ]		evaluatesTo:			'{"class":"Array","instance":[{"class":"Array","instance":[]},{"class":"Array","instance":[]}]}'.	self		assertEquivalent: [ {{}.			{}} asPhxJsonString ]! !!PhxBridgedJsonSerialisationTests methodsFor: 'tests'!testSerializeNil	self		assertAllWithInstantiationBlock: [ nil  ]		literal: 'null'		testEq: true		test4Stages: true! !!PhxBridgedJsonSerialisationTests methodsFor: 'tests'!testSerializeNumber	self		assertAllWithInstantiationBlock: [ 123456789  ]		literal: '123456789'		testEq: true		test4Stages: true.	self		assertAllWithInstantiationBlock: [ 12345.6789  ]		literal: '12345.6789'		testEq: true		test4Stages: true! !!PhxBridgedJsonSerialisationTests methodsFor: 'tests'!testSerializeOrderedCollection	"On js side, OrderedCollection does not exist!!!!!! "	"Auto transpiled to Array."	self		assertAllWithInstantiationBlock: [ OrderedCollection new ]		literal: '{"class":"Array","instance":[]}'		testEq: false "don't test because it's an Array client side"		test4Stages: true! !!PhxBridgedJsonSerialisationTests methodsFor: 'tests'!testSerializeOrderedCollectionInPharoMatrializeInJs	| originalCollection serializationString materializedCollection |	originalCollection := OrderedCollection withAll: #( a 11 'xyz' ).	serializationString := originalCollection asPhxJsonString.	materializedCollection := self evalBlock: [ 		                          PhxJsonReader readFromString: 			                          serializationString ].	originalCollection withIndexDo: [ :each :index | 		self assert: (materializedCollection at: index) equals: each ]! !!PhxBridgedJsonSerialisationTests methodsFor: 'tests'!testSerializeSet	self		assertAllWithInstantiationBlock: [ Set new ]		literal: '{"class":"Set","instance":[]}'		testEq: false "#assertEquivalent: doesn't work for this type of object"		test4Stages: true ! !!PhxBridgedJsonSerialisationTests methodsFor: 'tests'!testSerializeString	self		assertAllWithInstantiationBlock: [ PhxJsonTestResources challengingStringRequiringUnicodeAndEscapement				 ]		literal:			PhxJsonTestResources challengingStringRequiringUnicodeAndEscapement				asPhxJsonString		testEq: true		test4Stages: true! !!PhxJavascriptJsonSerialisationTests methodsFor: 'tests'!testArraysCircularReferences	| cClone aClone bClone |	cClone := self evalBlock: [		| a b c |		a := {'A'. nil. nil. nil}.		b := {'B'. nil. nil. nil }.		c := {'C'. nil. nil. nil }.		{ a. b. c } do: [ : each |			each at: 2 put: a.			each at: 3 put: b.			each at: 4 put: c.		].		PhxJsonReader readFromString: c asPhxJsonString.		].		aClone := cClone second.	bClone := cClone third.	{ aClone. bClone. cClone.}  with: #(A B C) do: [ : each : name |		self assert: each size equals: 4.		self assert: each first equals: name.		self assert: each second identicalTo: aClone.		self assert: each third identicalTo: bClone.		self assert: each last identicalTo: cClone.	].! !!PhxJavascriptJsonSerialisationTests methodsFor: 'tests'!testDictionariesReferencingEachOther	<expectedFailure>	| cClone aClone bClone |	cClone := self evalBlock: [		| a b c |		a := Dictionary new.		a at: #name put: 'A'.		b := Dictionary new.		b at: #name put: 'B'.		b at: #a put: a.		c := Dictionary new.		c at: #name put: 'C'.		c at: #a put: a.		c at: #b put: b.		PhxJsonReader readFromString: c asPhxJsonString.		].	self assert: cClone size equals: 3.	aClone := cClone at: #a.	self assert: aClone size equals: 1.	self assert: (aClone at: #name) equals: 'A'.	bClone := cClone at: #b.	self assert: bClone size equals: 2.	self assert: (bClone at: #name) equals: 'B'.	self assert: (bClone at: #b) identicalTo: aClone.! !!PhxJavascriptJsonSerialisationTests methodsFor: 'tests'!testDictionariesWithCircularReferences	<expectedFailure>	| cClone aClone bClone |	cClone := self evalBlock: [		| a b c |		a := Dictionary new.		a at: #name put: 'A'.		b := Dictionary new.		b at: #name put: 'B'.		c := Dictionary new.		c at: #name put: 'C'.		{ a. b. c } do: [ : each |			each at: #a put: a.			each at: #b put: b.			each at: #c put: c.		].		PhxJsonReader readFromString: c asPhxJsonString.		].	aClone := cClone at: #a.	bClone := cClone at: #b.	{ aClone. bClone. cClone.}  with: #(A B C) do: [ : each : name |		self assert: each size equals: 4.		self assert: (each at: #name) equals: name.		self assert: (each at: #a) identicalTo: aClone.		self assert: (each at: #b) identicalTo: bClone.		self assert: (each at: #c) identicalTo: cClone.	].! !!PhxJavascriptJsonSerialisationTests methodsFor: 'tests'!testOrderedCollectionsCircularReferences	| cClone aClone bClone |	cClone := self evalBlock: [		| a b c |		a := #('A') asOrderedCollection.		b := {'B'} asOrderedCollection.		c := {'C'} asOrderedCollection.		{ a. b. c } do: [ : each |			each add: a.			each add: b.			each add: c.		].		PhxJsonReader readFromString: c asPhxJsonString.		].		aClone := cClone second.	bClone := cClone third.	{ aClone. bClone. cClone.}  with: #(A B C) do: [ : each : name |		self assert: each size equals: 4.		self assert: each first equals: name.		self assert: each second identicalTo: aClone.		self assert: each third identicalTo: bClone.		self assert: each last identicalTo: cClone.	].! !!PhxJavascriptJsonSerialisationTests methodsFor: 'tests'!testSetsCircularReferences	<expectedFailure>	| cClone aClone bClone identitySet |	cClone := self evalBlock: [		| a b c |		a := {'A'} asSet.		b := {'B'} asSet.		c := {'C'} asSet.		{a. b. c} do: [ : each | each addAll: {a. b. c} ].		PhxJsonReader readFromString: c asPhxJsonString.		].		aClone := cClone detect: [: each | each includes: 'A'] ifNone: [nil].	bClone := cClone detect: [: each | each includes: 'B'] ifNone: [nil].	{ aClone. bClone. cClone.} with: #(A B C) do: [ : each : name |		self assert: each size equals: 4.		self assert: (each includes: name).	].	identitySet := IdentitySet new.	{aClone. bClone. cClone} do: [ : each | identitySet addAll: each ].	identitySet removeAll: #(A B C).	self assert: identitySet size equals: 3.! !!PhxJavascriptJsonSerialisationTests methodsFor: 'tests'!testSetsReferencingEachOther	| cClone bClone aInBClone aInCClone |	cClone := self evalBlock: [		| a b c |		a := #('A') asSet.		b := {'B'. a } asSet.		c := {'C'. a. b } asSet.		PhxJsonReader readFromString: c asPhxJsonString.	].	self assert: cClone size equals: 3.	self assert: (cClone includes: 'C').	self deny: (cClone includes: cClone).	bClone := cClone detect: [ : each | each includes: 'B' ] ifNone: [nil].	self assert: bClone size equals: 2.	self deny: (bClone includes: bClone).	aInBClone := bClone detect: [ : each | each includes: 'A' ] ifNone: [nil].	self assert: aInBClone size equals: 1.	aInCClone := cClone detect: [ : each | each includes: 'A' ] ifNone: [nil].	self assert: aInBClone identicalTo: aInCClone.! !"PharoJs-Base-Serialization-Tests"!!PjObject class methodsFor: '*PharoJs-Base-Serialization-Deprecated'!newFromMaterialized: serializationArray	|restored ivIndex|	restored := self new. "Ensure initialize is performed in case there are new IVs"	ivIndex := 1.	[ivIndex <= serializationArray size] whileTrue: [		restored 			instVarNamed: (serializationArray at: ivIndex) 			put: (serializationArray at: ivIndex + 1) materialize.		ivIndex := ivIndex + 2.	].	^restored! !!PjObject methodsFor: '*PharoJs-Base-Serialization-Deprecated'!serializationArray	^ {self className.	self serializationContents}! !!PjObject methodsFor: '*PharoJs-Base-Serialization-Deprecated'!serializationContents	|serializable|	serializable := OrderedCollection new.	self keysAndValuesDo: [ : key : value |		serializable add: key.		serializable add: value serializationArray.	].	^serializable! !!PjObject methodsFor: '*PharoJs-Base-Serialization-Deprecated'!serialize	^ self serializationArray asJSON! !!PjCompositeForSerializationTest methodsFor: 'accessing'!a	^ a! !!PjCompositeForSerializationTest methodsFor: 'accessing'!a: anObject	a := anObject! !!PjCompositeForSerializationTest methodsFor: 'accessing'!b	^ b! !!PjCompositeForSerializationTest methodsFor: 'accessing'!b: anObject	b := anObject! !!PjUndefinedObject class methodsFor: '*PharoJs-Base-Serialization-Deprecated'!newFromMaterialized: anObject	^nil! !!PjUndefinedObject methodsFor: '*PharoJs-Base-Serialization-Deprecated'!serializationContents	^self! !!PjNumber class methodsFor: '*PharoJs-Base-Serialization-Deprecated'!newFromMaterialized: materializedObject	^materializedObject! !!PjNumber methodsFor: '*PharoJs-Base-Serialization-Deprecated'!serializationContents	^self! !!PjString class methodsFor: '*PharoJs-Base-Serialization-Deprecated'!newFromMaterialized: materializedObject	^materializedObject! !!PjString methodsFor: '*PharoJs-Base-Serialization-Deprecated'!materialize	^PjMaterializer materializeFromString: self! !!PjString methodsFor: '*PharoJs-Base-Serialization-Deprecated'!serializationContents	^self! !!PjTArray classTrait methodsFor: '*PharoJs-Base-Serialization-Deprecated'!newFromMaterialized: aJsonArray	| materializedArray |	materializedArray := self new.	aJsonArray do: [ : each | materializedArray add: each materialize].	^materializedArray! !!PjTArray methodsFor: '*PharoJs-Base-Serialization-Deprecated'!serializationContents	"Important not to use a collect to ensure that we have an OrderedCollection that is actually a JS array. Since JSON knows how to handle arrays."	| serializableElements |	serializableElements := OrderedCollection new.	self do: [ : each | serializableElements add: each serializationArray ].	^serializableElements! !!PjSerializationTest methodsFor: 'testing'!testBasicTypes	self assert: [ 'abc' serialize ] evaluatesTo: '["String","abc"]'.	self assert: [ 3.14 serialize ] evaluatesTo: '["Number",3.14]'.	self assert: [ true serialize ] evaluatesTo: '["Boolean",true]'.	self assert: [ nil serialize ] evaluatesTo: '["PjUndefinedObject",{}]'.	self assertBlock: [ PjSerializationTestSupport assertEquals: 645].	self assertBlock: [ PjSerializationTestSupport assertEquals: 3.14].	self assertBlock: [ PjSerializationTestSupport assertEquals: 'hello' ].	self assertBlock: [ PjSerializationTestSupport assertIdentity: nil ].	self assertBlock: [ PjSerializationTestSupport assertIdentity: true ].	self assertBlock: [ PjSerializationTestSupport assertIdentity: false ].! !!PjSerializationTest methodsFor: 'testing'!testCollectionsOfBasicTypes	self assertBlock: [ PjSerializationTestSupport assertCollection: #() ].	self assertBlock: [ PjSerializationTestSupport assertCollection: #(1 2 3) ].	self assertBlock: [ PjSerializationTestSupport assertCollection: #('abc' 'other' 'yes') ].	self assertBlock: [ PjSerializationTestSupport assertCollection: OrderedCollection new ].	self assertBlock: [ PjSerializationTestSupport assertCollection: Set new ].	self assertBlock: [ 		|s|		s := Set new.		s addAll: #(1 2 3).		PjSerializationTestSupport assertCollection: s ].	self assertBlock: [ PjSerializationTestSupport assertCollection: SortedCollection new ].	self assertBlock: [ 		|s|		s := SortedCollection new.		s addAll: #(310 22 13).		PjSerializationTestSupport assertCollection: s ].! !!PjSerializationTest methodsFor: 'testing'!testCollectionsOfComplexTypes	self assertBlock: [ 		|s|		s := Set new.		s addAll: {Time now. 1 hour}.		PjSerializationTestSupport assertCollection: s ].	self assertBlock: [ 		|c1 c2 s|		s := Set new.		s addAll: {'wonderful'. 'world'}.		c1 := PjCompositeForSerializationTest new.		c1 a: 456.		c1 b: true.		c2 := PjCompositeForSerializationTest new.		c2 a: s.		c2 b: c1.		PjSerializationTestSupport assertComplexObject: c2.		].! !!PjSerializationTest methodsFor: 'testing'!testDuration	self assertBlock: [ PjSerializationTestSupport assertDuration: Duration zero].	self assertBlock: [ PjSerializationTestSupport assertDuration: 10 years].	self assertBlock: [ PjSerializationTestSupport assertDuration: 6 months].	self assertBlock: [ PjSerializationTestSupport assertDuration: 2 weeks].	self assertBlock: [ PjSerializationTestSupport assertDuration: 2 hours].	self assertBlock: [ PjSerializationTestSupport assertDuration: 30 minutes].	self assertBlock: [ PjSerializationTestSupport assertDuration: 10 seconds].! !!PjSerializationTest methodsFor: 'testing'!testTime	self assertBlock: [ PjSerializationTestSupport assertTime: Time now].	self assertBlock: [ 		PjSerializationTestSupport assertTime: (Time hour: 1 minute: 1 second: 13)].	self assertBlock: [ 		PjSerializationTestSupport assertTime: (Time now seconds: 25)].	self assertBlock: [ 		PjSerializationTestSupport assertTime: (Time now seconds: 625)].	self assertBlock: [ 		PjSerializationTestSupport assertTime: (Time noon)].	self assertBlock: [ 		PjSerializationTestSupport assertTime: (Time midnight)].	self assertBlock: [ 		PjSerializationTestSupport assertTime: (Time hour: 1 minute: 0 second: 0)].	self assertBlock: [ 		PjSerializationTestSupport assertTime: (Time hour: 12 minute: 0 second: 0)].	self assertBlock: [ 		PjSerializationTestSupport assertTime: (Time hour: 13 minute: 0 second: 0)].	self assertBlock: [ 		PjSerializationTestSupport assertTime: (Time hour: 23 minute: 59 second: 30)].! !!PjSerializationTest methodsFor: 'testing'!testTimeDetailledSerialization	| now clone |	now := self evalBlock: [ 				window instVarNamed: #now put: Time now.		 		window now.	].	clone := self evalBlock: [ PjSerializationTestSupport serializeThenMaterialize: window now].	self assert: clone hour24 equals: now hour24.	self assert: clone minute equals: now minute.	self assert: clone second equals: now second.! !!PjMaterializer class methodsFor: 'materializing'!materializeFrom: anObject	^anObject materialize! !!PjMaterializer class methodsFor: 'materializing'!materializeFromArray: array	| class |	class := global instVarNamed: array first.	^class newFromMaterialized: array second! !!PjMaterializer class methodsFor: 'materializing'!materializeFromString: aString	| array |	array := JSON parse: aString.	^self materializeFromArray: array! !!PjSerializationTestSupport class methodsFor: 'serializing'!assertCollection: aCollection	| clone |	clone := self serializeThenMaterialize: aCollection.	clone class == aCollection class ifFalse: [ ^false ].	clone size == aCollection size ifFalse: [ ^false ].	aCollection withIndexDo: [ : element : index |		element class == (clone at: index) class ifFalse: [ ^false ].	].	^true! !!PjSerializationTestSupport class methodsFor: 'serializing'!assertComplexObject: aComposite	| clone |	clone := self serializeThenMaterialize: aComposite.	clone class == aComposite class ifFalse: [ ^false ].	clone a class == aComposite a class ifFalse: [ ^false ].	clone b class == aComposite b class ifFalse: [ ^false ].	^true! !!PjSerializationTestSupport class methodsFor: 'serializing'!assertDuration: aDuration	| clone |	clone := self serializeThenMaterialize: aDuration.	clone class == Duration ifFalse: [ ^false ].	^aDuration totalSeconds = clone totalSeconds! !!PjSerializationTestSupport class methodsFor: 'serializing'!assertEquals: anObject	^(self serializeThenMaterialize: anObject) = anObject! !!PjSerializationTestSupport class methodsFor: 'serializing'!assertIdentity: anObject	^(self serializeThenMaterialize: anObject) == anObject! !!PjSerializationTestSupport class methodsFor: 'serializing'!assertTime: aTime	| clone |	clone := self serializeThenMaterialize: aTime.	clone class == Time ifFalse: [ ^false ].	clone hour24 = aTime hour24 ifFalse: [ ^false ].	clone minute = aTime minute ifFalse: [ ^false ].	clone second = aTime second ifFalse: [ ^false ].	^true! !!PjSerializationTestSupport class methodsFor: 'serializing'!serializeThenMaterialize: anObject	^PjMaterializer materializeFrom: anObject serialize! !!PjTDate classTrait methodsFor: '*PharoJs-Base-Serialization-Deprecated'!newFromMaterialized: jsonString	<javascript: 'return new Date(jsonString)'>! !!PjTDate methodsFor: '*PharoJs-Base-Serialization-Deprecated'!serializationContents	^self! !!PjArray methodsFor: '*PharoJs-Base-Serialization-Deprecated'!materialize	^PjMaterializer materializeFromArray: self! !!PjBoolean class methodsFor: '*PharoJs-Base-Serialization-Deprecated'!newFromMaterialized: materializedObject	^materializedObject! !!PjBoolean methodsFor: '*PharoJs-Base-Serialization-Deprecated'!serializationContents	^self! !"PharoJs-Base-Serialization-Deprecated"!!PjStreamTest commentStamp: '' prior: 0!I contain test for the simplistic Read/Write Stream implementation!!PjCoreLibrariesTranspilationTest methodsFor: 'tests'!testPjStringClass	self jsCode: (self convertClass: PjString).	self assertInstanceMethod: #= equals: '(other){return this==other}'.	self assertInstanceMethod: #, equals:  '(other){return this+other}'.! !!PjCoreLibrariesTranspilationTest methodsFor: 'tests'!testPjUndefinedObjectClass	self jsCode: (self convertClass: PjUndefinedObject).	self assertInstanceMethod: #= equals:  '(other){return null==other}'.	self assertClassMethod: #new equals: '(){return Smalltalk._signal_("cannot create instances of UndefinedObject")}'.	self assertClassMethod: #javascriptInitialize equals: '(){var $1;this.uniqueInstance=this._basicNew();$1=$asNil$(Object);$1.freeze(this.uniqueInstance);$1.freeze(this);return this}'! !!PjArrayLikeCollectionTest class methodsFor: 'testing'!isAbstract	^self == PjArrayLikeCollectionTest! !!PjArrayLikeCollectionTest methodsFor: 'accessing - defaults'!defaultCollection	self subclassResponsibility! !!PjArrayLikeCollectionTest methodsFor: 'running'!setUp	super setUp.	collection := self defaultCollection! !!PjArrayLikeCollectionTest methodsFor: 'testing'!testIndexOf	| index |	index := collection indexOf: collection first.	self assert: index equals: 1.	self assert: (collection at: index) == collection first! !!PjHtmlCollectionTest methodsFor: 'accessing - defaults'!defaultCollection	^ document body children! !!PjNodeListTest methodsFor: 'accessing - defaults'!defaultCollection	^ document body childNodes! !!PjNodeListTest methodsFor: 'tests'!testAllButFirst	self assert: collection allButFirst size equals: collection size - 1.! !!PjNodeListTest methodsFor: 'tests'!testCollectionIsNotEmpty	self assert: collection notEmpty.	self deny: collection isEmpty! !!PjArrayTest methodsFor: 'tests'!testAllButFirst	| array |	array := self bridge evalBlock: [ #(10 20 30 40) ].	self assert: array allButFirst size equals: array size - 1! !!PjArrayTest methodsFor: 'tests'!testArrayClassDoesNotOverlapWithArrayFunction	self assertJavascript: 'typeof Array' evaluatesTo: 'function'.	self assertJavascript: 'typeof PjArray' evaluatesTo: 'undefined'.! !!PjArrayTest methodsFor: 'tests'!testArrayWith1Element	self assert: [{1}] evaluatesToRaw: '[1]'.	self assert: [#(1)] evaluatesToRaw: '[1]'.! !!PjArrayTest methodsFor: 'tests'!testArrayWith2Elements	self assert: [{1. 2}] evaluatesToRaw: '[1,2]'.	self assert: [#(1 2)] evaluatesToRaw: '[1,2]'.! !!PjArrayTest methodsFor: 'tests'!testArrayWithMoreElements	self assert: [{1. 2}] evaluatesToRaw: '[1,2]'.	self assert: [#(1 2)] evaluatesToRaw: '[1,2]'.	self assert: [#(1 true 'id' 'x\y"z')] evaluatesToRaw: '[1,true,"id","x\\y\"z"]'.! !!PjArrayTest methodsFor: 'tests'!testAsOrderedCollection	| orderedCollection |	orderedCollection := self evalBlock: [#(1 2 3 4) asOrderedCollection].	self assert: orderedCollection size equals: 4.! !!PjArrayTest methodsFor: 'tests'!testAt	| array |	array := self bridge evalBlock: [ #(10 20 30 40) ].	#(10 20 30 40)		doWithIndex:			[ :expectedValue :index | self assert: [ array at: index ] evaluatesTo: expectedValue ]! !!PjArrayTest methodsFor: 'tests'!testAtIfAbsent	| array actualValue |	array := self bridge evalBlock: [ #(10 20 30) ].	#(10 20 30)		withIndexDo: [ :expectedValue :index | 			actualValue := self bridge				evalBlock: [ array at: index ifAbsent: [ nil ] ].			self assert: actualValue equals: expectedValue ].	actualValue := self bridge		evalBlock: [ array at: 10 ifAbsent: [ 100 ] ].	self assert: actualValue equals: 100! !!PjArrayTest methodsFor: 'tests'!testAtPut	| array |	array := self bridge evalBlock: [ #(10 20 30 40) ].	#(11 22 33 44)		doWithIndex:			[ :newValue :index | self bridge evalBlock: [ array at: index put: newValue ] ].	self assert: [ array ] evaluatesToRaw: '[11,22,33,44]'! !!PjArrayTest methodsFor: 'tests'!testCircularReference	| array |	array := self bridge evalBlock: [#('X')].	self deny: (array includes: array).! !!PjArrayTest methodsFor: 'tests'!testCollect	| double |	double := self bridge		evalBlock: [ | array |			array := #(10 20 30 40).			array collect: [ :element | 2 * element ] ].	#(20 40 60 80)		doWithIndex:			[ :expectedValue :index | self assert: [ (double at: index) = expectedValue ] evaluatesTo: true ]! !!PjArrayTest methodsFor: 'tests'!testCollectPerform	| double |	double := self bridge		evalBlock: [ | array |			array := #(10 -20 -30 40).			array collect: [ :each | each abs ] ].	#(10 20 30 40)		doWithIndex:			[ :expectedValue :index | self assert: [ (double at: index) = expectedValue ] evaluatesTo: true ]! !!PjArrayTest methodsFor: 'tests'!testCollectPerformSymbol	| double |	double := self bridge		evalBlock: [ | array |			array := #(10 -20 -30 40).			array collect: #abs ].	#(10 20 30 40)		doWithIndex:			[ :expectedValue :index | self assert: [ (double at: index) = expectedValue ] evaluatesTo: true ]! !!PjArrayTest methodsFor: 'tests'!testConverstionToArray	| collection |	collection := self evalBlock: [#(1 2 3 4)].	self deny: collection asArray identicalTo: collection.! !!PjArrayTest methodsFor: 'tests'!testConverstionToSet	| setFromArray |	setFromArray := self bridge evalBlock: [ #(10 20 30 40) asSet ].	setFromArray addAll: #(10 20 30 40).	self assert: setFromArray size equals: 4.	setFromArray add: 30.	self assert: setFromArray size equals: 4.	setFromArray add: 50.	self assert: setFromArray size equals: 5.	#(10 20 30 40 50) do: [ :each |		self assert: (setFromArray includes: each) ]! !!PjArrayTest methodsFor: 'tests'!testCopy	| tests |	tests := self bridge		evalBlock: [ | array |			array := #(10 20 30 40).			{array copy = array. array copy == array} ].	self assert: tests first.	self deny: tests last.! !!PjArrayTest methodsFor: 'tests'!testDetectIfFound	self		assertEquivalent: [|array found|			array := #(1 2 3 4).			found := false.			array detect: [ : element | console log: element. element == 2] ifFound: [found := true].			found].! !!PjArrayTest methodsFor: 'tests'!testDetectIfNone	self 		assertEquivalent: [|array notFound| array := #(1 2 3 4).			notFound := false.			array detect: [ : element | element == 5] ifNone: [notFound := true].			notFound].! !!PjArrayTest methodsFor: 'tests'!testDo	self		assertEquivalent: [|array total|			array := #(1 2 3 4).			total := 0.			array do: [ : element | total := total + element].			total].! !!PjArrayTest methodsFor: 'tests'!testDoWithIndex	self		assertEquivalent: [|array total|			array := #(10 20 30 40).			total := 0.			array doWithIndex: [ : element : index | total := total + index].			total].! !!PjArrayTest methodsFor: 'tests'!testEmptyArray	self assert: [{}] evaluatesToRaw: '[]'.	self assert: [#()] evaluatesToRaw: '[]'.! !!PjArrayTest methodsFor: 'tests'!testEquality	self assertEquivalent: [#() = #()].	self assertEquivalent: [#(11) = #(11)].	self assertEquivalent: [#(11 22) = #(11 22)].	self assertEquivalent: [#(11 22 33) = #(11 22 33)].	self assertEquivalent: [#(11 33 22) = #(11 22 33)].! !!PjArrayTest methodsFor: 'tests'!testIncludes	self assertEquivalent: [#() includes: 4].	self assertEquivalent: [#(2 3 4 5) includes: 4].	self assertEquivalent: [#() includes: 'hello'].	self assertEquivalent: [#(2 'hello' 5) includes: 'hello'].	self assertEquivalent: [ #(2 3 (4 5) 6) includes: #(4 5) ].	self assertEquivalent: [ #(2 3 (4 5) 6) includes: #(5 6) ].! !!PjArrayTest methodsFor: 'tests'!testIncludesAll	self assertEquivalent: [#() includesAll: #(4)].	self assertEquivalent: [#(2 3 4 5) includesAll: #(4)].	self assertEquivalent: [#() includesAll: #('hello')].	self assertEquivalent: [#(2 'hello' 5) includesAll: #('hello')].	self assertEquivalent: [ #(2 3 4 5 6) includesAll: #(4 5) ].	self assertEquivalent: [ #(2 3 4 5 6) includesAll: #(6 2 6) ].! !!PjArrayTest methodsFor: 'tests'!testIncludesAny	self assertEquivalent: [#() includesAny: #(4)].	self assertEquivalent: [#(2 3 4 5) includesAny: #(4)].	self assertEquivalent: [#() includesAny: #('hello')].	self assertEquivalent: [#(2 'hello' 5) includesAny: #('hello')].	self assertEquivalent: [ #(2 3 4 5 6) includesAny: #(4 5) ].	self assertEquivalent: [ #(2 3 4 5 6) includesAny: #(6 2 6) ].! !!PjArrayTest methodsFor: 'tests'!testInserElement! !!PjArrayTest methodsFor: 'tests'!testIsEmpty	self assertEquivalent: [#() isEmpty].	self assertEquivalent: [#(11) isEmpty].	self assertEquivalent: [#(11 22 33) isEmpty].! !!PjArrayTest methodsFor: 'tests'!testNotEmpty	self assertEquivalent: [#() notEmpty].	self assertEquivalent: [#(11) notEmpty].	self assertEquivalent: [#(11 22 33) notEmpty].! !!PjArrayTest methodsFor: 'tests'!testReject	| filtered |	filtered := self bridge evalBlock: [ #(10 20 30 40) reject: [ : each | each > 35 or: [ each < 15 ] ]].	self assert: filtered size equals: 2.	self assert: filtered first equals: 20.	self assert: filtered last equals: 30.! !!PjArrayTest methodsFor: 'tests'!testRemove	self assertEquivalent: [ #(10 20 30 40) asOrderedCollection removeAt: 2 ].	self assertEquivalent: [ (#(10 20 30 40) asOrderedCollection removeAt: 2;yourself) asArray ].! !!PjArrayTest methodsFor: 'tests'!testReversed	self		assertEquivalent: [|array|			array := #(1 2 3 4).			array,array reversed].! !!PjArrayTest methodsFor: 'tests'!testShallowCopy	| clone |	clone := self evalBlock: [ #(11 22 33) copy].	self assert: clone size equals: 3.	#(11 22 33) withIndexDo: [ : each : index |		self assert: (clone at: index) equals: each		 ].! !!PjArrayTest methodsFor: 'tests'!testSize	self assertEquivalent: [#() size].	self assertEquivalent: [#(11 ) size].	self assertEquivalent: [#(11 22) size].	self assertEquivalent: [#(11 22 33) size].! !!PjAsJsObjectInJs methodsFor: 'tests'!testBoolean	self assertBlock: [ true asJsObject == true].	self assertBlock: [ false asJsObject == false].! !!PjAsJsObjectInJs methodsFor: 'tests'!testConvertingADictionary	self assertBlock: [{ #a -> 1. #b -> 2. #c -> 3 } asDictionary asJsObject class == Object].! !!PjAsJsObjectInJs methodsFor: 'tests'!testConvertingAnAssociationArray	self assertBlock: [{ #a -> 1. #b -> 2. #c -> 3 } asJsObject class == Object].! !!PjAsJsObjectInJs methodsFor: 'tests'!testConvertingCompositeArray	| converted convertedAssociations convertedDict |	converted := self evalBlock: [		{ 		#array -> #(1 2 3). 		#associationArray -> { #a -> 1. #b -> 2. #c -> 3 }.		#dict ->  { #x -> 0. #y -> 3.14.} asDictionary.		#object -> Object new	} asJsObject].	self assertBlock: [converted class == Object].	self assertBlock: [(converted at: #array) class == Array].	self assertBlock: [(converted at: #object) class == Object].	convertedAssociations := converted at: #associationArray.	self assertBlock: [convertedAssociations class == Object].	#(a b c) with: #(1 2 3) do: [ : iv : expectedValue | 		self assert: (convertedAssociations at: iv) equals: expectedValue].	convertedDict := converted at: #dict.	self assertBlock: [convertedDict class == Object].	#(x y) with: #(0 3.14) do: [ : iv : expectedValue | 		self assert: (convertedDict at: iv) equals: expectedValue].! !!PjAsJsObjectInJs methodsFor: 'tests'!testConvertingCompositeDictionary	| converted |	converted := self evalBlock: [		{ 		#array -> #(1 2 3). 		#associationArray -> { #a -> 1. #b -> 2. #c -> 3 }.		#dict ->  { #x -> 0. #y -> 3.14.} asDictionary.		#object -> Object new	} asDictionary asJsObject].	self assertBlock: [converted class == Object].	self assertBlock: [(converted at: #array) class == Array].	self assertBlock: [(converted at: #object) class == Object].	self assertBlock: [(converted at: #associationArray) class == Object].	self assertBlock: [(converted at: #dict) class == Object].! !!PjAsJsObjectInJs methodsFor: 'tests'!testConvertingNestedDictionariesAndArrays	| converted |	converted := self evalBlock: [		{ { 		#arrays -> { { #a -> 4. #b -> 5 }. false not. 3 negated. #(3 4 5)}.	} } asJsObject].	self assertBlock: [converted class == Array].	self assertBlock: [converted first class == Object].	self assertBlock: [(converted first at: #arrays) class == Array].	self assertBlock: [(converted first at: #arrays) first class == Object].	self assertBlock: [(converted first at: #arrays) second class == Boolean].	self assertBlock: [(converted first at: #arrays) third class == SmallInteger].	self assertBlock: [(converted first at: #arrays) fourth class == Array].! !!PjAsJsObjectInJs methodsFor: 'tests'!testConvertingObjectWithNestedDictionaryAndArray	| original converted |	self bridge loadClass: PjObjectForTestingAsJsObject.	original :=  self evalBlock: [PjObjectForTestingAsJsObject from:		{ 		#plainArray -> #(1 2 3). 		#associationArray -> { #a -> 1. #b -> 2. #c -> 3 }.		#dict ->  { #x -> 0. #y -> 3.14.} asDictionary.		#object -> Object new	}].	converted := self evalBlock: [original asJsObject].	self assertBlock: [converted == original].	self assertBlock: [converted class == PjObjectForTestingAsJsObject].	self assertBlock: [converted plainArray == original plainArray].	self assertBlock: [converted plainArray class == Array].	self assertBlock: [converted associationArray == original associationArray].	self assertBlock: [converted associationArray class == Array].	self assertBlock: [converted dict == original dict].	self assertBlock: [converted dict class == Dictionary].	self assertBlock: [converted object == original object].	self assertBlock: [converted object class == Object].! !!PjAsJsObjectInJs methodsFor: 'tests'!testIfnil    self        assertBlock: [ PjDummyTestObject string: ('Hello' ifNil: [ 'World' ]).            PjDummyTestObject string = 'Hello' ]! !!PjAsJsObjectInJs methodsFor: 'tests'!testIgnoreArrayOfNonAssociations	self assertBlock: [#(1 2 3) asJsObject class == Array].! !!PjAsJsObjectInJs methodsFor: 'tests'!testNumber	self assertBlock: [ 3.14 asJsObject == 3.14].	self assertBlock: [ 42 asJsObject == 42].! !!PjAsJsObjectInJs methodsFor: 'tests'!testString	self assertBlock: [ 'Smalltalk Rocks!!' asJsObject == 'Smalltalk Rocks!!'].! !!PjAssociationTest methodsFor: 'tests'!testEqualityForAssociations	self assertEquivalent: [(1->#hello)=(2->#hello)].	self assertEquivalent: [(3->#hello)=(3->#hello)].	self assertEquivalent: [(1->#hello)=(2->#goodbye)].	self assertEquivalent: [(3->#hello)=(3->#goodbye)].	self assertEquivalent: [			| a | 			a := 3->4. 			a = a].	self assertEquivalent: [(1->5)=(2->5)].	self assertEquivalent: [(3->5)=(3->5)].	self assertEquivalent: [(1->5)=(2->8)].	self assertEquivalent: [(3->8)=(3->8)].! !!PjAssociationTest methodsFor: 'tests'!testEqualityForKeys	self assertEquivalent: [		| a b |		a := 3->4.		b := 3->6.		a key = b key].	self assertEquivalent: [		| a b |		a := 4->1.		b := 6->2.		a key = b key].! !!PjAssociationTest methodsFor: 'tests'!testEqualityForValues	self assertEquivalent: [		| a b |		a := 4->3.		b := 6->3.		a value = b value].	self assertEquivalent: [		| a b |		a := 4->1.		b := 6->2.		a value = b value].! !!PjChronololgyTest methodsFor: 'running'!setUp	super setUp.	self bridge		loadAllClasses:			{			Time.			Duration.			DateAndTime}! !!PjChronololgyTest methodsFor: 'tests'!testAddDurationToDateAndTime	self assertEquivalent: [|origin later|		origin := DateAndTime year: 2020 month: 1 day: 1 hour: 0 minute: 0 second: 0.		later := origin + 123 milliSeconds.		later milliSecond.].		self assertEquivalent: [|origin later|		origin := DateAndTime year: 2020 month: 1 day: 1 hour: 0 minute: 0 second: 0.		later := origin + 23 seconds.		later second.].		self assertEquivalent: [|origin later|		origin := DateAndTime year: 2020 month: 1 day: 1 hour: 0 minute: 0 second: 0.		later := origin + 45 minutes.		later minute.].		self assertEquivalent: [|origin later|		origin := DateAndTime year: 2020 month: 1 day: 1 hour: 0 minute: 0 second: 0.		later := origin + 7 hours.		later hour.].		self assertEquivalent: [|origin later|		origin := DateAndTime year: 2020 month: 1 day: 1 hour: 0 minute: 0 second: 0.		later := origin + 5 days.		later dayOfMonth.].! !!PjChronololgyTest methodsFor: 'tests'!testDateAndTimeArithmetic	self evalBlock: [|reference|		reference := DateAndTime todayHour: 14 minute: 59 second: 33.		window instVarNamed: #reference put: reference].		self evalBlock: [		|plus1Sec| 		plus1Sec := window reference +  1 second.		window instVarNamed: #plus1Sec put: plus1Sec].		self assertEquivalent: [window plus1Sec hour24 = 14].	self assertEquivalent: [window plus1Sec hour = 14].	self assertEquivalent: [window plus1Sec hour12 = 2].	self assertEquivalent: [window plus1Sec minute = 59].	self assertEquivalent: [window plus1Sec second = 34].! !!PjChronololgyTest methodsFor: 'tests'!testDateAndTimeCreation	self evalBlock: [|today tomorrow|		today := DateAndTime todayHour: 14 minute: 59 second: 34.		tomorrow := DateAndTime tomorrowHour: 14 minute: 59 second: 34.		window instVarNamed: #today put: today.		window instVarNamed: #tomorrow put: tomorrow.		].		{window today. window tomorrow} do: [: each |		self assert: each hour24 = 14.		self assert: each hour = 14.		self assert: each hour12 = 2.		self assert: each minute = 59.		self assert: each second = 34.	].	self assert: window today year equals: Date today year.	self assert: window today monthIndex equals: Date today monthIndex.	self assert: window today dayOfMonth equals: Date today dayOfMonth.	self assert: window today dayOfWeek equals: Date today dayOfWeek.	self assert: window tomorrow year equals: Date tomorrow year.	self assert: window tomorrow monthIndex equals: Date tomorrow monthIndex.	self assert: window tomorrow dayOfMonth equals: Date tomorrow dayOfMonth.	self assert: window tomorrow dayOfWeek equals: Date tomorrow dayOfWeek.! !!PjChronololgyTest methodsFor: 'tests'!testDuration	self assertBlock: [ Duration zero class == Duration ].	self assertEquivalent: [ Duration zero days].	self assertEquivalent: [ Duration zero hours].	self assertEquivalent: [ Duration zero minutes].	self assertEquivalent: [ 1 month monthsCount].! !!PjChronololgyTest methodsFor: 'tests'!testSubtractDateAndTime	self assertEquivalent: [|origin later|		origin := DateAndTime year: 2020 month: 1 day: 1 hour: 0 minute: 0 second: 0.		later := origin + 123 milliSeconds.		(later - origin) millisecondsCount	].		self assertEquivalent: [|origin later|		origin := DateAndTime year: 2020 month: 1 day: 1 hour: 0 minute: 0 second: 0.		later := origin + 54 seconds.		(later - origin) seconds	].		self assertEquivalent: [|origin later|		origin := DateAndTime year: 2020 month: 1 day: 1 hour: 0 minute: 0 second: 0.		later := origin + 12 minutes.		(later - origin) minutes	].		self assertEquivalent: [|origin later|		origin := DateAndTime year: 2020 month: 1 day: 1 hour: 0 minute: 0 second: 0.		later := origin + 3 hours.		(later - origin) hours	].! !!PjChronololgyTest methodsFor: 'tests'!testTime	self assertBlock: [ Time now class == Time ].	self assertEquivalent: [ (Time hour: 5 minute: 30) asDateAndTime dayOfMonth].	self assertEquivalent: [ (Time hour: 5 minute: 30) asDateAndTime monthIndex].	self assertEquivalent: [ (Time hour: 5 minute: 30) asDateAndTime year].	self assertEquivalent: [ Time now hour].	self assertEquivalent: [ Time now hour].	self assertEquivalent: [ Time now hour12].	self assertEquivalent: [ Time now hour24].	self assertEquivalent: [ Time now minute].	self assert: [ (Time hour: 1 minute: 1 second: 13) asSeconds ] evaluatesTo: 3673.	self assert: [ (Time now seconds: 25) hour24 ] evaluatesTo: 0.	self assert: [ (Time now seconds: 25) minute ] evaluatesTo: 0.	self assert: [ (Time now seconds: 25) second ] evaluatesTo: 25.	self assert: [ (Time now seconds: 625) hour24 ] evaluatesTo: 0.	self assert: [ (Time now seconds: 625) minute ] evaluatesTo: 10.	self assert: [ (Time now seconds: 625) second ] evaluatesTo: 25.	self assertEquivalent: [ Time noon meridianAbbreviation].	self assertEquivalent: [ Time noon hour12].	self assertEquivalent: [ Time noon hour24].	self assertEquivalent: [ Time midnight meridianAbbreviation].	self assertEquivalent: [ Time midnight hour12].	self assertEquivalent: [ Time midnight hour24].	self assertEquivalent: [ (Time hour: 0 minute: 0 second: 0) hour12 ].	self assertEquivalent: [ (Time hour: 1 minute: 0 second: 0) hour12 ].	self assertEquivalent: [ (Time hour: 11 minute: 0 second: 0) hour12 ].	self assertEquivalent: [ (Time hour: 12 minute: 0 second: 0) hour12 ].	self assertEquivalent: [ (Time hour: 13 minute: 0 second: 0) hour12 ].	self assertEquivalent: [ (Time hour: 23 minute: 0 second: 0) hour12 ].! !!PjDateAndTimeTest methodsFor: 'tests'!testConversion	| today todayString |	self assertEquivalent: [ 		(DateAndTime fromString: '2022-01-02T12:30:21-04:00') getTime ].	self assertEquivalent: [ 		(DateAndTime fromString: '2022-01-02T12:30:21-04:00') printString ].	self assertEquivalent: [ 		(DateAndTime fromString: '2022-01-02T12:30:21-00:00') printString ].	self assertEquivalent: [ 		(DateAndTime fromString: '2022-01-02T12:30:21+04:00') printString ].	today := DateAndTime today.	todayString := String streamContents: [ :str | 		               BasicDatePrinter default			               printYMD: today			               withLeadingSpace: false			               on: str ].	self assertEquivalent: [ 		(DateAndTime fromString: todayString , 'T12:30:21') printString ]! !!PjDictionaryTest methodsFor: 'tests'!testAsDictionary	| original asDictResult |	original := self bridge evalBlock: [ Dictionary new].	original 		at: #a put: 1;		at: #b put: 2.	asDictResult := original asDictionary.	self assert: original == asDictResult! !!PjDictionaryTest methodsFor: 'tests'!testAtIfAbsent	self assertEquivalent: [|d|		d := Dictionary new.		d at: #x ifAbsent: [42]].! !!PjDictionaryTest methodsFor: 'tests'!testAtIfAbsentPut	self assertEquivalent: [|d|		d := Dictionary new.		d at: #x ifAbsentPut: 42.		d at: #x].! !!PjDictionaryTest methodsFor: 'tests'!testAtIfEmpty	self assertEquivalent: [ Dictionary new isEmpty ].	self assertEquivalent: [ (Dictionary new at: #x put: 4;yourself) isEmpty ].	self assertEquivalent: [|d|		d := Dictionary new.		d ifEmpty: [ 3 ]].	self assertEquivalent: [|d|		d := Dictionary new.		d ifEmpty: [ 3 ] ifNotEmpty: [42]].	self assertEquivalent: [|d|		d := Dictionary new.		d ifNotEmpty: [ 3 ] ifEmpty: [42]].	self assertEquivalent: [|d t|		d := Dictionary new.t:=5.		d at: #x put: 4.		d ifEmpty: [ t:=3 ].t].	self assertEquivalent: [|d|		d := Dictionary new.		d at: #x put: 4.		d ifEmpty: [ 3 ] ifNotEmpty: [42]].	self assertEquivalent: [|d|		d := Dictionary new.		d at: #x put: 4.		d ifNotEmpty: [ 3 ] ifEmpty: [42]].! !!PjDictionaryTest methodsFor: 'tests'!testAtPut	self assertEquivalent: [|d|		d := Dictionary new.		d at: #x put: 42.		d at: #x].	self assert: [|d|		d := Dictionary new.		d at: #x put: 42.		d] evaluatesToRaw: '{"x":42}'! !!PjDictionaryTest methodsFor: 'tests'!testBridgeConstructor	| eg |	eg := self bridge		evalBlock: [ {(#a -> 3).			(#b -> 5)} asDictionary ].	self assert: [ eg at: #a ] evaluatesTo: 3.	self assert: [ eg at: #b ] evaluatesTo: 5.	self		assert: [ eg				add: #c -> 42;				at: #c ]		evaluatesTo: 42.	self assert: [ eg keys ] evaluatesToRaw: '["a","b","c"]'! !!PjDictionaryTest methodsFor: 'tests'!testBridgeConstructorSimple	| eg |	eg := self bridge evalBlock: [ {(#a -> 3)} asDictionary ].	self assert: [ eg at: #a ] evaluatesTo: 3.	self assert: [ eg keys ] evaluatesToRaw: '["a"]'! !!PjDictionaryTest methodsFor: 'tests'!testDictionaryWithProxies	| proxy dictionaryWithProxy |	proxy := self evalBlock: [ Object new ].	dictionaryWithProxy := { #someId -> proxy } asDictionary.	self 		shouldnt: [window instVarNamed: #dict put:  dictionaryWithProxy ]		raise: Error! !!PjDictionaryTest methodsFor: 'tests'!testKeysAndValuesDo	| eg |	eg := self bridge		evalBlock: [ {(#a -> 3).			(#b -> 5).			(#c -> 42)} asDictionary ].	self		assert: [ | count |			count := 0.			eg keysAndValuesDo: [ :k :v | count := count + v ].			count ]		evaluatesTo: 50.	self		assert: [ | count |			count := 0.			eg do: [ :v | count := count + v ].			count ]		evaluatesTo: 50.	self assert: [ eg isEmpty ] evaluatesTo: false.	self assert: [ Dictionary new isEmpty ] evaluatesTo: true! !!PjDictionaryTest methodsFor: 'tests'!testNewFromPairs	| d |	d := self bridge		evalBlock: [ Dictionary newFromPairs: #(#x 17 #y 42) ].	self assert: d asRawJSONString equals: '{"x":17,"y":42}'! !!PjDictionaryTest methodsFor: 'tests'!testNonInterference	" make sure dictionary emulation doesn't interfere "	self assert: [document body classList add: 'hello'] evaluatesTo: nil.	self assert: [document body classList contains: 'hello'] evaluatesTo: true! !!PjDictionaryTest methodsFor: 'tests'!testUseEqualObjectsAsKeys	self assert: [		|dict firstKey secondKey| 		dict := Dictionary new.		firstKey := PjObjectForDictTest data: 1.		dict at: firstKey put: 'A'.		secondKey := PjObjectForDictTest data: 1.		dict at: secondKey put: 'B'.		dict at: firstKey	] evaluatesTo: 'B'.! !!PjDictionaryTest methodsFor: 'tests'!testUseNonEqualObjectsAsKeys	self assert: [		|dict firstKey secondKey| 		dict := Dictionary new.		firstKey := PjObjectForDictTest data: 1.		dict at: firstKey put: 'A'.		secondKey := PjObjectForDictTest data: 2.		dict at: secondKey put: 'B'.		dict at: firstKey	] evaluatesTo: 'A'.! !!PjIdentityDictionaryTest methodsFor: 'tests'!testAsDictionary	| original asDictResult |	original := self bridge evalBlock: [ IdentityDictionary new].	original 		at: #a put: 1;		at: #b put: 2.	asDictResult := original asDictionary.	self assert: original == asDictResult! !!PjIdentityDictionaryTest methodsFor: 'tests'!testAtIfAbsent	self assertEquivalent: [|d|		d := IdentityDictionary new.		d at: #x ifAbsent: [42]].! !!PjIdentityDictionaryTest methodsFor: 'tests'!testAtIfAbsentPut	self assertEquivalent: [|d|		d := IdentityDictionary new.		d at: #x ifAbsentPut: 42.		d at: #x].	self assertEquivalent: [|d|		d := IdentityDictionary new.		d at: #x ifAbsentPut: [42].		d at: #x].! !!PjIdentityDictionaryTest methodsFor: 'tests'!testAtIfEmpty	self assertEquivalent: [ IdentityDictionary new isEmpty ].	self assertEquivalent: [ (IdentityDictionary new at: #x put: 4;yourself) isEmpty ].	self assertEquivalent: [|d|		d := IdentityDictionary new.		d ifEmpty: [ 3 ]].	self assertEquivalent: [|d|		d := IdentityDictionary new.		d ifEmpty: [ 3 ] ifNotEmpty: [42]].	self assertEquivalent: [|d|		d := IdentityDictionary new.		d ifNotEmpty: [ 3 ] ifEmpty: [42]].	self assertEquivalent: [|d t|		d := IdentityDictionary new.t:=5.		d at: #x put: 4.		d ifEmpty: [ t:=3 ].t].	self assertEquivalent: [|d|		d := IdentityDictionary new.		d at: #x put: 4.		d ifEmpty: [ 3 ] ifNotEmpty: [42]].	self assertEquivalent: [|d|		d := IdentityDictionary new.		d at: #x put: 4.		d ifNotEmpty: [ 3 ] ifEmpty: [42]].! !!PjIdentityDictionaryTest methodsFor: 'tests'!testAtPut	self assertEquivalent: [|d|		d := IdentityDictionary new.		d at: #x put: 42.		d at: #x].	self assertEquivalent: [|d|		d := IdentityDictionary new.		d at: #x put: 42.		d size]! !!PjIdentityDictionaryTest methodsFor: 'tests'!testKeysAndValuesDo	| dict |	dict := self bridge		evalBlock: [ 			IdentityDictionary new				at: #a put: 3;				at: #b put: 5;				at: #c put: 42;				yourself ].	self		assert: [ | count |			count := 0.			dict keysAndValuesDo: [ :k :v | count := count + v ].			count ]		evaluatesTo: 50.	self		assert: [ | count |			count := 0.			dict do: [ :v | count := count + v ].			count ]		evaluatesTo: 50.	self assert: [ dict isEmpty ] evaluatesTo: false.	self assert: [ IdentityDictionary new isEmpty ] evaluatesTo: true! !!PjIdentityDictionaryTest methodsFor: 'tests'!testNewFromPairs	| d |	d := self bridge		evalBlock: [ IdentityDictionary newFromPairs: #(#x 17 #y 42) ].! !!PjIdentityDictionaryTest methodsFor: 'tests'!testNonInterference	" make sure dictionary emulation doesn't interfere "	self assert: [document body classList add: 'hello'] evaluatesTo: nil.	self assert: [document body classList contains: 'hello'] evaluatesTo: true! !!PjIdentityDictionaryTest methodsFor: 'tests'!testUseObjectsAsKeysForIdentityDictionary	self assert: [		|dict firstKey secondKey| 		dict := IdentityDictionary new.		firstKey :=  PjObjectForDictTest data: 1.		dict at: firstKey put: 'A'.		secondKey := PjObjectForDictTest data: 1.		dict at: secondKey put: 'B'.		dict at: firstKey	] evaluatesTo: 'A'.! !!PjObjectTest methodsFor: 'tests'!testNewObjectHasNoEnumeratableKeys	"This is important for many JS third party libraries"	self assertBlock: [ Object new allEnumeratableKeys isEmpty ] .! !!PjObjectTest methodsFor: 'tests'!testPrintStringArray	self		assert: [ #( 1 2 3 nil true #nil #symbol ) printString ]		evaluatesTo: '#(1 2 3 nil true ''nil'' ''symbol'')'.	self		assert: [ 		#( #( 1 2 3 nil ) #(  ) #( true #nil #symbol ) ) printString ]		evaluatesTo: '#(#(1 2 3 nil) #() #(true ''nil'' ''symbol''))'.	self		assert: [ 			{ 				Object new.				#( true nil ).				nil.				12.4.				#someSymbol.				(true and: [ false ]).				[ 42 factorial ] } printString ]		evaluatesTo:		'an Array(an Object #(true nil) nil 12.4 ''someSymbol'' false a Block)'! !!PjObjectTest methodsFor: 'tests'!testPrintStringBasicCases	self assert: [ Object new printString ] evaluatesTo: 'an Object'.	self assert: [ PjSet new printString ] evaluatesTo: 'a PjSet()'.	self		assert: [ 'hello world' printString ]		evaluatesTo: '''hello world'''.	self		assert: [ 'DragN''Drop' printString ]		evaluatesTo: '''DragN''''Drop'''.	self assert: [ true printString ] evaluatesTo: 'true'.	self assert: [ false printString ] evaluatesTo: 'false'.	self assert: [ nil printString ] evaluatesTo: 'nil'.	self		assert: [ #someSymbol printString ]		evaluatesTo: '''someSymbol'''! !!PjObjectTest methodsFor: 'tests'!testPrintStringException	{ 		Error.		ZeroDivide } do: [ :exceptionClass | 		self			assert: [ exceptionClass new description ]			evaluatesTo: exceptionClass name.		self			assert: [ 				exceptionClass new					messageText: 'Some cause';					description ]			evaluatesTo: exceptionClass name , ': Some cause' ]! !!PjObjectTest methodsFor: 'tests'!testPrintStringNumbers	self assert: [ 123 printString ] evaluatesTo: '123'.	self		assert: [ Float infinity printString ]		evaluatesTo: 'Float infinity'.	self		assert: [ Float nan printString ]		evaluatesTo: 'Float nan'.! !!PjObjectTest methodsFor: 'tests'!testShallowCopy	self assertBlock: [		|original clone|		original := Object new.		original instVarNamed: #a put: 1. 		clone := original copy.		clone class == Object and: [ (clone instVarNamed: #a) = 1 ]		 ]! !!PjOrderedCollectionTest methodsFor: 'running'!setUp	super setUp.	collection := self evalBlock: [ OrderedCollection new ]! !!PjOrderedCollectionTest methodsFor: 'tests'!testCircularReference	self deny: (collection includes: collection).	collection add: 'A'.	self deny: (collection includes: collection).	collection add: collection.	self assert: (collection includes: collection).	self assert: collection size equals: 2.! !!PjOrderedCollectionTest methodsFor: 'tests'!testConverstionToOrderedCollection	self deny: collection asOrderedCollection identicalTo: collection.! !!PjOrderedCollectionTest methodsFor: 'tests'!testInsertElementBeforeFirstOne	collection addAll: #(1 2 3).	collection insert: 0 before: 1.	self assert: collection size equals: 4.	(0 to: 3) withIndexDo: [ : expectedElement : index |		self assert: (collection at: index) equals: expectedElement	]! !!PjOrderedCollectionTest methodsFor: 'tests'!testJoin	| temp |	collection addAll: #(4 5).	temp := collection join: #((1 2 3) (6 7) (3 2)).	self assert: collection size equals: 2.	self assert: temp size equals: 11.	#(1 2 3 4 5 6 7 4 5 3 2) withIndexDo: [ : expectedElement : index |		self assert: (temp at: index) equals: expectedElement	]! !!PjOrderedCollectionTest methodsFor: 'tests'!testRemoveAll	collection addAll: #(1 2 3 4 5).	collection removeAll: #(1 5).	self assert: collection size equals: 3.	#(2 3 4) withIndexDo: [ : expectedElement : index |		self assert: (collection at: index) equals: expectedElement	].	collection removeAll.	self assert: collection isEmpty.! !!PjSetTest methodsFor: 'running'!setUp	super setUp.	set := self evalBlock: [ Set new ]! !!PjSetTest methodsFor: 'tests'!testCircularReference	self deny: (set includes: set).	set add: 'A'.	self deny: (set includes: set).	set add: set.	self assert: (set includes: set).	self assert: set size equals: 2.! !!PjSetTest methodsFor: 'tests'!testConverstionToSet	self assert: set asSet identicalTo: set! !!PjSetTest methodsFor: 'tests'!testElementAddedFirstSeveralTimesShowsUpOnlyOnce	3 timesRepeat: [ set addFirst: 42 ].	self assert: set size equals: 1.	self assert: (set includes: 42).! !!PjSetTest methodsFor: 'tests'!testElementAddedLastSeveralTimesShowsUpOnlyOnce	3 timesRepeat: [ set addLast: 42 ].	self assert: set size equals: 1.	self assert: (set includes: 42).! !!PjSetTest methodsFor: 'tests'!testElementAddedSeveralTimesShowsUpOnlyOnce	3 timesRepeat: [ set add: 42 ].	self assert: set size equals: 1.	self assert: (set includes: 42).! !!PjSetTest methodsFor: 'tests'!testLike	set addAll: #(1 2 3 4 5).	self assert: (set like: 4) equals: 4.	self assert: (set like: 42) equals: nil.	self assert: (set like: 4 ifAbsent: [ 3+4 ]) equals: 4.	self assert: (set like: 42 ifAbsent: [ 3+4 ]) equals: 7.! !!PjSetTest methodsFor: 'tests'!testRemove	set addAll: #(1 2 3 4 5).	set remove: 3 ifAbsent: [ ].	set remove: 42 ifAbsent: [ ].	self assert: set size equals: 4.	#(1 2 4 5) do: [ : expectedElement |		self assert: (set includes: expectedElement)	].! !!PjSetTest methodsFor: 'tests'!testRemoveAll	set addAll: #(1 2 3 4 5).	set removeAll: #(1 5).	self assert: set size equals: 3.	#(2 3 4) do: [ : expectedElement |		self assert: (set includes: expectedElement)	].	set removeAll.	self assert: set isEmpty.! !!PjSortedCollectionTest methodsFor: 'utilities'!atRandomAddAll: elements	| toInsert |	toInsert := Set withAll: elements. 	toInsert size timesRepeat: [		|inserted|		inserted := toInsert atRandom.		collection add: inserted.		toInsert remove: inserted].! !!PjSortedCollectionTest methodsFor: 'running'!setUp	super setUp.	collection := self evalBlock: [ SortedCollection new ]! !!PjSortedCollectionTest methodsFor: 'tests'!testAllButLast	| allButLast |	1 to: 4 do: [:each|		collection add: each].	allButLast := collection allButLast.	self assert: allButLast size equals: 3.	1 to: 3 do: [ : each |		self assert: (allButLast at: each) equals: each.	].! !!PjSortedCollectionTest methodsFor: 'tests'!testCollect	collection := self evalBlock: [ 		|s|		s := SortedCollection  new.		s add: 3; add: 1.		s collect: [: each | each ]].	self assert: collection size equals: 2.	self assert: collection first equals: 1.	self assert: collection last equals: 3.! !!PjSortedCollectionTest methodsFor: 'tests'!testReSortingNumbers	self evalBlock: [ collection sortBlock: [ : a : b | a <= b ] ].	self atRandomAddAll: (1 to: 10).	self evalBlock: [ collection sortBlock: [ : a : b | a >= b ] ].	(1 to: 10) with: (1 to: 10) reversed do: [ : index : expectedValue |		self assert: (collection at: index) equals: expectedValue ]! !!PjSortedCollectionTest methodsFor: 'tests'!testShallowCopy	| clone |	self atRandomAddAll: (1 to: 10).	clone := collection copy.	self assert: clone size equals: 10.	(1 to: 10) do: [ : index |		self assert: (clone at: index) equals: index ]! !!PjSortedCollectionTest methodsFor: 'tests'!testSortingNumbersGreaterFirst	self evalBlock: [ collection sortBlock: [ : a : b | a >=b ] ].	self atRandomAddAll: (1 to: 10).	(1 to: 10) with: (1 to: 10) reversed do: [ : index : expectedValue |		self assert: (collection at: index) equals: expectedValue ]! !!PjSortedCollectionTest methodsFor: 'tests'!testSortingNumbersSmallerFirst	self atRandomAddAll: (1 to: 10).	(1 to: 10) do: [ : index |		self assert: (collection at: index) equals: index ]! !!PjStreamTest methodsFor: 'tests'!testArrayRead	self assertEquivalent: [#(1 2 3) readStream next].	self assertEquivalent: [#(1 2 3) readStream next;next].	self assertEquivalent: [#(1 2 3) readStream next;next;next].	self assertEquivalent: [#(1 2 3) readStream next;next;next;next].	self assertEquivalent: [#(1 2 3) readStream next;next;next;atEnd].! !!PjStreamTest methodsFor: 'tests'!testArrayReadWrite	self assert: [#() writeStream nextPutAll: #(1 2 3);nextPutAll: #(4 5 6);next;next;next;next] evaluatesTo: 4.! !!PjStreamTest methodsFor: 'tests'!testArrayWrite	self assertEquivalent: [#(() writeStream nextPut: 3;nextPutAll: 'abc';contents) at: 2].! !!PjStreamTest methodsFor: 'tests'!testStringNewWrite	self assertEquivalent: [ 		String new: 10 streamContents: [ :stream | stream << 'hello world' ] ]! !!PjStreamTest methodsFor: 'tests'!testStringPeek	self assertEquivalent: ['abc' readStream peek asString].	self assertEquivalent: [('abc' readStream peek;next) asString].	self assertEquivalent: [('abc' readStream next;peek;next) asString].	self assertEquivalent: ['abc' readStream next;next;peek;atEnd].! !!PjStreamTest methodsFor: 'tests'!testStringRead	self assertEquivalent: ['abc' readStream next asString].	self assertEquivalent: [('abc' readStream next;next) asString].	self assertEquivalent: [('abc' readStream next;next;next) asString].	self assertEquivalent: ['abc' readStream next;next;next;atEnd].	self assertEquivalent: ['abc' readStream next;next;next;next].! !!PjStreamTest methodsFor: 'tests'!testStringReadWrite	self assert: [('' writeStream nextPutAll: 'abc';nextPutAll: 'def';next;next;next;next) asString] evaluatesTo: 'd'.! !!PjStreamTest methodsFor: 'tests'!testStringWrite	self assertEquivalent: ['' writeStream nextPut: $x;nextPutAll: 'abc';contents].! !!PjStringTest methodsFor: 'tests'!testConversion	self assertEquivalent: ['the Eiffel Tower' asUppercase].	self assertEquivalent: ['the Eiffel Tower' asLowercase].	self assertEquivalent: ['the Eiffel Tower' capitalized].! !!PjStringTest methodsFor: 'tests'!testConversionToNumbers	self assertEquivalent: ['07' asInteger].	self assertEquivalent: ['3.14' asInteger].	self assertEquivalent: ['3.14' asNumber].	self assertEquivalent: ['2xyz' asNumber].	self assertEquivalent: ['1.41xyz' asNumber].! !!PjStringTest methodsFor: 'tests'!testFirst	self assert: ['abc' first] evaluatesTo: 'a'.	self assert: ['CBA' first] evaluatesTo: 'C'.! !!PjStringTest methodsFor: 'tests'!testIfEmpty	self assertEquivalent: ['abc' ifEmpty: ['xyz']].	self assertEquivalent: ['' ifEmpty: ['xyz']].! !!PjStringTest methodsFor: 'tests'!testIsAlphanumeric	| digits |	digits := Character allByteCharacters select: [: each | each isAlphaNumeric ].	self assertBlock: [digits allSatisfy: [: char |char isAlphaNumeric ]].! !!PjStringTest methodsFor: 'tests'!testIsDigit	| digits |	digits := Character allByteCharacters select: [: each | each isDigit].	self assertBlock: [digits allSatisfy: [: char |char isDigit]].! !!PjStringTest methodsFor: 'tests'!testIsLetter	| letters nonLetters |	letters := Character allByteCharacters select: [: each | each isLetter].	self assertBlock: [letters allSatisfy: [: char |char isLetter]].	nonLetters := Character allByteCharacters copyWithoutAll: letters.	self assertBlock: [nonLetters noneSatisfy: [: char |  char isLetter]].! !!PjStringTest methodsFor: 'tests'!testLast	self assert: ['abc' last] evaluatesTo: 'c'.	self assert: ['CBA' last] evaluatesTo: 'A'.! !!PjStringTest methodsFor: 'tests'!testReversed	self		assertEquivalent: ['abcd' reversed].! !!PjStringTest methodsFor: 'tests'!testSplit	| splited |	splited := self evalBlock: ['.' split: 'a.b.c'].	self assert: splited size equals: 3.	#(a b c) withIndexDo: [ : expected : index | 		self assert: (splited at: index) equals: expected]! !!PjStringTest methodsFor: 'tests'!testSplitOn	self assertEquivalent: [		('a.b.c' splitOn: '.') asArray ]! !!PjUndefinedObjectTest methodsFor: 'tests'!testNilCannotBeReplaced	self assertBlock: [ PjUndefinedObject uniqueInstance == nil yourself ].	self evalBlock: [ 		window at: #originalNil put: PjUndefinedObject uniqueInstance ].	self		should: [ 		self evalBlock: [ PjUndefinedObject uniqueInstance: #( 42 ) ] ]		raise: Error.	self assertBlock: [ 		(window at: #originalNil) == PjUndefinedObject uniqueInstance ]! !!PjUndefinedObjectTest methodsFor: 'tests'!testNilStructureCannotChange	self should: [self evalBlock: [ nil at: #newProperty put: 42 ]] raise: Error.	self assert: [ nil at: #newProperty ] evaluatesTo: nil.! !!PjAsJsObjectInPharo methodsFor: 'tests'!testBasicObjects	{ 'abc'. true. false. nil. 3.14. 2000. $a } do: [ : each |		self assert: each asJsObject == each	]! !!PjAsJsObjectInPharo methodsFor: 'tests'!testConvertingADictionary	| dict |	dict := { #a -> 1. #b -> 2. #c -> 3 } asDictionary.	self assert: (dict asJsObject isKindOf: Dictionary)! !!PjAsJsObjectInPharo methodsFor: 'tests'!testConvertingAnAssociationArray	| converted |	converted := { #a -> 1. #b -> 2. #c -> 3 } asJsObject.	self assert: (converted isKindOf: Dictionary)! !!PjAsJsObjectInPharo methodsFor: 'tests'!testConvertingCompositeArray	| converted |	converted := { 		#array -> #(1 2 3). 		#associationArray -> { #a -> 1. #b -> 2. #c -> 3 }.		#dict ->  { #x -> 0. #y -> 3.14.} asDictionary.		#object -> Object new	} asJsObject.	self assert: (converted isKindOf: Dictionary).	self assert: ((converted at: #array) isKindOf: Array).	self assert: ((converted at: #object) isKindOf: Dictionary).	self assert: ((converted at: #associationArray) isKindOf: Dictionary).	self assert: ((converted at: #dict) isKindOf: Dictionary).! !!PjAsJsObjectInPharo methodsFor: 'tests'!testConvertingCompositeDictionary	| converted |	converted := { 		#array -> #(1 2 3). 		#associationArray -> { #a -> 1. #b -> 2. #c -> 3 }.		#dict ->  { #x -> 0. #y -> 3.14.} asDictionary.		#object -> Object new	} asDictionary asJsObject.	self assert: (converted isKindOf: Dictionary).	self assert: ((converted at: #array) isKindOf: Array).	self assert: ((converted at: #object) isKindOf: Dictionary).	self assert: ((converted at: #associationArray) isKindOf: Dictionary).	self assert: ((converted at: #dict) isKindOf: Dictionary).! !!PjAsJsObjectInPharo methodsFor: 'tests'!testConvertingObjectWithNestedDictionaryAndArray	| original converted |	original := PjObjectForTestingAsJsObject from: { 		#plainArray -> #(1 2 3). 		#associationArray -> { #a -> 1. #b -> 2. #c -> 3 }.		#dict ->  { #x -> 0. #y -> 3.14.} asDictionary.		#objectNoIvs -> Object new.		#objectWithIvs -> (PjObjectForTestingAsJsObject from: {#plainArray -> #(x y z)}).	}.	converted := original asJsObject.	self assert: (converted isKindOf: Dictionary).	self assert: ((converted at: #plainArray) isKindOf: Array).	self assert: ((converted at: #objectNoIvs) isKindOf: Dictionary).	self assert: ((converted at: #objectWithIvs) isKindOf: Dictionary).	self assert: ((converted at: #associationArray) isKindOf: Dictionary).	self assert: ((converted at: #dict) isKindOf: Dictionary).! !!PjAsJsObjectInPharo methodsFor: 'tests'!testIgnoreArrayOfNonAssociations	| array |	array := #(1 2 3).	self assert: array asJsObject == array! !!PjAsJsObjectInPharo methodsFor: 'tests'!testProxy	| proxy |	proxy := PjProxy new.	self assert: proxy asJsObject == proxy! !!PjDummyTestObject class methodsFor: 'accessing'!string	^string! !!PjDummyTestObject class methodsFor: 'accessing'!string: aString	string := aString! !!PjObjectForDictTest class methodsFor: 'instance creation'!data: anObject	^self new		data: anObject;		yourself! !!PjObjectForDictTest methodsFor: 'comparing'!= other	^data = other data! !!PjObjectForDictTest methodsFor: 'accessing'!data	^ data! !!PjObjectForDictTest methodsFor: 'accessing'!data: anObject	data := anObject! !!PjObjectForDictTest methodsFor: 'comparing'!hash	^data hash! !!PjObjectForTestingAsJsObject class methodsFor: 'instance creation'!from: anAssociationArray	^self new		from: anAssociationArray;		yourself! !!PjObjectForTestingAsJsObject methodsFor: 'initialization'!from: anAssociationArray	anAssociationArray asDictionary keysAndValuesDo: [ : key :value|		self instVarNamed: key put: value]! !!PjDomControllerJsTest methodsFor: 'accessing' prior: 34116719!appClassToExport	^self appClass! !!PjDomControllerPharoTest class methodsFor: 'suite parameters'!appClass	^PjMinimalFileBasedWebApp! !!PjDomControllerPharoTest methodsFor: 'accessing' prior: 34116936!appClassToExport	^PjAppWrapperForRunningInPharo on: self appClass! !!PjDomControllerPharoTest methodsFor: 'running'!setUp	super setUp.	domElement := app createElement: 'div'! !!PjDomControllerPharoTest methodsFor: 'testing'!testCssClassARemoval	app cssClassesStringElement: domElement set: 'a b c'.	self assert: (app cssClassesStringElement: domElement) equals: 'a b c'.	app cssClassesRemoveAll: #(a c) element: domElement.	self assert: (app cssClassesStringElement: domElement) trimBoth equals: 'b'! !!PjDomControllerPharoTest methodsFor: 'testing'!testCssClassAddition	self assert: (app cssClassesStringElement: domElement) equals: ''.	app cssClassesAddAll: #(a b c) element: domElement.	self assert: (app cssClassesStringElement: domElement) trimBoth equals: 'a b c'! !!PjDomControllerPharoTest methodsFor: 'testing'!testCssClassReplacement	app cssClassesStringElement: domElement set: 'a b c'.	self assert: (app cssClassesStringElement: domElement) equals: 'a b c'.	app cssClassesReplaceAll: #(a c) byAll: #(x y) element: domElement.	self assert: (app cssClassesStringElement: domElement) trimBoth equals: 'b x y'! !"PharoJs-Base-JS-CoreLibraries-Tests"!!PjTest1Polyfill class methodsFor: 'polyfill'!nodePackageName	<pharoJsSkip>	^ 'foobar'! !!PjTest2Polyfill class methodsFor: 'polyfill'!nodePolyfill: aTranspiler	<pharoJsSkip>	super nodePolyfill: aTranspiler.	aTranspiler		nextPutAll: 'var Bar=Foobar.Bar;';cr! !!PjTest2Polyfill class methodsFor: 'polyfill'!requiredPolyfills	^ self sharedPools! !!PjTestClassForPolyfill class methodsFor: 'accessing'!pharoJsSelectorPrefix	^ 'alt_'! !!PjTestClassForPolyfill class methodsFor: 'settings'!playgroundDoNotList	<pharoJsSkip>	! !!PjTestClassForPolyfill methodsFor: 'any'!m	| bar ws |	bar := Bar new.	ws := WebSocket new.! !!PjDependentTranspilerTest methodsFor: 'testing'!testBootstrapClasses	transpiler alreadyConvertedClasses: { PjCore }.	self generateJsCodeForClasses: PjExporter bootstrapClasses.	self assertClassExtension: PjObject installedBefore: PjString.	self assertClassExtension: PjObject installedBefore: PjError! !!PjDependentTranspilerTest methodsFor: 'testing'!testClassOrdering	transpiler alreadyConvertedClasses: { PjCore. Object. }.	self generateJsCodeForClasses: {		PjAlternateClassForTranspilationTest.	}.	self assertClass: PjSuperClassForTranspilationTest installedBefore: PjAlternateClassForTranspilationTest.	self assertClass: PjSharedPoolForTest installedBefore: PjSuperClassForTranspilationTest.	self assertClass: PjClassEForPackageTranspilationTest installedBefore: PjAlternateClassForTranspilationTest.	self assert: PjSharedPoolForTest initializedBefore: PjAlternateClassForTranspilationTest.! !!PjDependentTranspilerTest methodsFor: 'testing'!testIncludeMethods	" test that methods from a variety of dependent classes get loaded "	self generateJsCodeForClasses: { PjClassForTranspilationTest }.	self assert: (self instanceMethod: #selector) equals: '(){return this.selector}'.	self assert: (self instanceMethod: #selectors) equals: '(){return [this.selector]}'.	self assert: (self instanceMethod: #order:selector:) equals: '(aNumber,aString){this._order_(aNumber);this.selector=aString;return this}'.	self assert: (self classMethod: #javascriptName) equals: nil. "because of pragma"	self assert: (self classMethod: #exampleForTest) equals: '(){return this}'.! !!PjDependentTranspilerTest methodsFor: 'accessing'!transpilerClass	^ PjDependentTranspiler! !!PjAppPathTest methodsFor: 'running'!resetAppClass	appClass appHtmlSubFolder: nil.	appClass appJsSubFolder: nil.	appClass defaultAppFolderPath deleteIfAbsent: [ ]! !!PjAppPathTest methodsFor: 'running'!setUp	super setUp.	appClass := PjAppForPathTest.	appClass appFolder: '/some/folder' asFileReference. 	self resetAppClass! !!PjAppPathTest methodsFor: 'running'!tearDown	super tearDown.	self resetAppClass! !!PjAppPathTest methodsFor: 'running'!testDefaultAppFolderCreatedIfMissing	self assert: appClass defaultAppFolder exists! !!PjAppPathTest methodsFor: 'running'!testNilHtmlFolderAndNilJsFolder	appClass appHtmlSubFolder: nil.	appClass appJsSubFolder: nil.	self assert: appClass appFullHtmlFolderPath equals: appClass appFolder.	self assert: appClass appFullJsFolderPath equals: appClass appFullHtmlFolderPath.! !!PjAppPathTest methodsFor: 'running'!testNilHtmlFolderFolderButNotNilJsFolder	appClass appHtmlSubFolder: nil.	appClass appJsSubFolder: 'js'.	self assert: appClass appFullHtmlFolderPath equals: appClass appFolder.	self assert: appClass appFullJsFolderPath equals: appClass appFullHtmlFolderPath / 'js'.! !!PjAppPathTest methodsFor: 'running'!testNotNilHtmlFolderAndNotNilJsFolder	appClass appHtmlSubFolder: 'www'.	appClass appJsSubFolder: 'js'.	self assert: appClass appFullHtmlFolderPath equals: appClass appFolder/'www'.	self assert: appClass appFullJsFolderPath equals: appClass appFullHtmlFolderPath / 'js'.! !!PjAppPathTest methodsFor: 'running'!testNotNilHtmlFolderButNilJsFolder	appClass appHtmlSubFolder: 'www'.	appClass appJsSubFolder: nil.	self assert: appClass appFullHtmlFolderPath equals: appClass appFolder/ 'www'.	self assert: appClass appFullJsFolderPath equals: appClass appFullHtmlFolderPath.! !!PjExporterTest methodsFor: 'running' prior: 33755099!classToTranspile	^ PjClassExtensionForTest! !!PjExporterTest methodsFor: 'accessing' prior: 33755695!jsCode	^jsCode! !!PjExporterTest methodsFor: 'accessing' prior: 33644778!lineEnding	^exporter transpiler lineEnding! !!PjExporterTest methodsFor: 'accessing'!pharoJsSelectorPrefix	^ exporter transpiler pharoJsSelectorPrefix! !!PjExporterTest methodsFor: 'running'!setUp	super setUp.	exporter := PjExporter new.! !!PjExporterTest methodsFor: 'testing'!testAvoidOverridingOnImportMethodsFromPharo	exporter initializeWithAppClass: PjApplication.	exporter addClass: PjClassExtensionForTest.	jsCode := exporter javascriptCode.	self assertInstanceMethod: #foo equals: '(){return 42}'.	self		assert: (jsCode splitOn:				 self pharoJsSelectorPrefix , 'foo') size		equals: 2! !!PjExporterTest methodsFor: 'testing'!testClassInheritanceOrder	exporter initializeWithAppClass: PjDOMApplication.	jsCode := exporter javascriptCode.	self assert: 'class PjApplication' precedes: 'class PjDOMApplication'! !!PjExporterTest methodsFor: 'testing'!testCoreClassedLoaded	| pjPrefix |	exporter initializeWithAppClass: PjApplication.	pjPrefix := self pharoJsSelectorPrefix. " has to be done after an application has been set "	jsCode := exporter javascriptCode.	self assert: (jsCode includesSubstring:			 'installClass(class PjClass extends Function{').	self assert: (jsCode includesSubstring:			 'installClass(class PjApplication extends Object{').	self deny: (jsCode includesSubstring: 'class Object').	self assert: (jsCode includes: 'PjClass' before: 'PjApplication').	self assert: (jsCode			 includes: PjTranspiler installClassSelector , '=function('			 before: 'PjApplication').	self assert: (jsCode			 includes:			 PjTranspiler installJsClassPlaceholderSelector , '=function('			 before: 'PjApplication')! !!PjExporterTest methodsFor: 'testing'!testExportingClassesAndPackages	exporter addClass: Object.	self assert: exporter classes size equals: 1.	exporter addAllClasses: {String. Array}.	self assert: exporter classes size equals: 3.	exporter addPackage: 'PharoJs-Base-Exporter-Tests-Support'.	self assert: exporter classes size = 8.	exporter addAllPackages: {PjExporter category.  PjTranspiler category}.	self assert: exporter classes size > 10.! !!PjExporterTest methodsFor: 'testing'!testImportMethodsFromPharo	exporter initializeWithAppClass: PjApplication.	exporter addClass: PjClassExtensionForTest.	jsCode := exporter javascriptCode.	#(yourself isArray isLiteral eqv:) do: [ : selector |		self assertHasInstanceMethod: selector ].	#(allInstances allInstancesDo: new) do: [ : selector |		self assertHasClassMethod: selector ].	self assertInstanceMethod: #yourself equals: '(){return this}'! !!PjExporterTest methodsFor: 'testing'!testJsSelector	| contents |	contents := (PjTestFileExporter exportApp: PjTestClassForPolyfill) contents.	self assert: (contents includesSubstring: 'alt_m(').! !!PjExporterTest methodsFor: 'testing'!testLaunchCodeAppearsAtTheEndOfExportedCode	exporter initializeWithAppClass: PjApplication.	exporter launchBlock: [42].	jsCode := exporter javascriptCode.	self assert: (jsCode allButLast endsWith: 'return 42})();')! !!PjExporterTest methodsFor: 'testing'!testMainClassIsAddedToClassesToExport	exporter initializeWithAppClass: PjWebApplication.	self assert: (exporter classes includes: PjWebApplication).	self assert: exporter classes size > 1.! !!PjExporterTest methodsFor: 'testing'!testPolyfills	| contents foobar bar |	contents := (PjTestFileExporter exportApp: PjMinimalNodeApplication) contents.	self deny: (contents includesSubstring: ' WebSocket=Smalltalk.require("ws")').	contents := (PjTestFileExporter exportApp: PjTestClassForPolyfill) contents.	self assert: (contents includesSubstring: ' WebSocket=Smalltalk.require("ws")').	self assert: (contents includesSubstring: ' Foobar=Smalltalk.require("foobar")').	self assert: (contents includesSubstring: 'Bar=Foobar.Bar').	foobar := contents findString: ' Foobar=Smalltalk.require("foobar")'.	bar := contents findString: 'Bar=Foobar.Bar'.	self assert: foobar<bar.! !!PjExporterTest methodsFor: 'testing'!testTestResourcesAreIgnored	exporter addAllClasses: {TestResource}.	self assert: exporter classes isEmpty.! !!PjExporterTest methodsFor: 'testing'!testTestsAreIgnored	exporter addAllClasses: {TestCase. PjExporterTest}.	self assert: exporter classes isEmpty.! !!PjExporterTest methodsFor: 'testing'!testTraitsAreIgnored	exporter addClass: TComparable.	self assert: exporter classes isEmpty.! !!PjNodeAppExportTest class methodsFor: 'suite parameters'!appClass	^ PjMinimalNodeApplication! !!PjNodeAppExportTest methodsFor: 'tests'!testRequiredJsModulesInstalled	self appClass modulesFolder ensureDeleteAll.	self deny: self appClass modulesFolder exists.	self appClass exportApp.	self assert: self appClass modulesFolder exists! !!PjAppForPathTest class methodsFor: 'accessing'!appFolder	^appFolder! !!PjAppForPathTest class methodsFor: 'accessing'!appHtmlSubFolder	^appHtmlSubFolder! !!PjAppForPathTest class methodsFor: 'accessing'!appHtmlSubFolder: anObject	appHtmlSubFolder := anObject! !!PjAppForPathTest class methodsFor: 'accessing'!appJsSubFolder	^appJsSubFolder! !!PjAppForPathTest class methodsFor: 'accessing'!appJsSubFolder: anObject	appJsSubFolder := anObject! !!PjAlternateClassForTranspilationTest class methodsFor: 'initialization-release'!initialize! !!PjAlternateClassForTranspilationTest methodsFor: 'any'!m	^ PjClassEForPackageTranspilationTest new! !"PharoJs-Base-Exporter-Tests"!!PjMinimalNodeApplication commentStamp: '' prior: 0!I am a minimal application that runs in nodejs!!PjHelloWorldExpressApp commentStamp: '' prior: 0!Express-based app. Requires the following node packages be installed in the folder	- [express](https://expressjs.com)	- [body-parser](https://expressjs.com/en/resources/middleware/body-parser.html): Parse incoming request bodies in a middleware before your handlers, available under the req.body property.	- [serve-static](https://expressjs.com/en/resources/middleware/serve-static.html): Create a new middleware function to serve files from within a given root directory. The file to serve will be determined by combining req.url with the provided root directory. When a file is not found, instead of sending a 404 response, this module will instead call next() to move on to the next middleware, allowing for stacking and fall-backs.!!PhysicsSim commentStamp: '' prior: 0!This example was first introduced durint a talk given at the ESUG 2018 conference.It shows how to use an existing JS library by relying on the matters.js libraryhttps://brm.io/matter-js/!!PjDisjointForceDirectedGraphExample commentStamp: '' prior: 0!Example of app using data visualisation library D3JS https://d3js.org/Displays a graph with clickable and draggable nodes!!PjHelloWorldApp commentStamp: '' prior: 0!Simple Hello World example. The app UI relies on an text input field and a button.The HTML file is on GIT https://github.com/bouraqadi/PharoJS.git sub-folder PharoJsExamples/HelloWorld/To generate the javascript index.js file, evaluate the following expression: PjHelloWorldApp exportApp!!PjHelloWorldExpressClientApp commentStamp: '' prior: 0!I rely on the [Fetch API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API) to make REST calls on the ExpressJS-based server implemented by `PjHelloWorldExpressApp`.!!PjDrawRectangleApp commentStamp: '' prior: 0!I am just the shared methods of a minimal browser application.My subclasses are the actual implementions.!!PjDrawRectangleNoDnuApp commentStamp: '' prior: 0!I implement a minimal browser application.I am a version that doesn't need a DNU infrastructure.!!PjDrawRectangleUseDnuApp commentStamp: '' prior: 0!I implement a minimal browser application.I am a version that needs a working DNU infrastructure.!!PjES5vsES6BenchmarkChartsApp commentStamp: '' prior: 0!I provide charts of benchmarks conducted to compare the evolution of the transpiler to generated EcmaScript 6 (ES6) style JS instead of EcmaScript 5 (ES5).These benchmarks were conducted as part of a paper presented at International Workshop on Smalltalk Technology (IWST) colocated with [ESUG 2023 conference](https://esug.github.io/2023-Conference/conf2023.html) in Lyon, France.Charts are built using [ChartJS](https://www.chartjs.org) a Simple and flexible JavaScript charting framework.Just like PharoJS, ChartJS open-source and distributed via GitHub under a MIT License.!!PjMinimalWebApplication commentStamp: '' prior: 0!I am a minimal application that runs in a web browser.I demonstrate overriding the default html and css, and log to the console.!!PjThreeJsDemo commentStamp: '' prior: 0!Simple demo of ThreeJS 3D graphics library (https://threejs.org/).Shows a cube that can be rotated by pressing keyboard arrow keys."Transpile to JS"PjThreeJsDemo exportApp.!!PjMinimalNodeApplication class methodsFor: 'event handling'!start	super start.	console log: 'this is a minimal Node application'! !!PjHelloWorldExpressApp class methodsFor: 'accessing'!clientAppClasses	<pharoJsSkip>	^{PjHelloWorldExpressClientApp }! !!PjHelloWorldExpressApp class methodsFor: 'accessing'!staticFilesFolderName	^'public'! !!PjHelloWorldExpressApp methodsFor: 'initialization'!greetings	^ String streamContents: [ :str | 		  str << 'ExpressJS says: Hello'.		  self name ifNotNil: [ 			  str				  space;				  << self name ].		  str << $!! ]! !!PjHelloWorldExpressApp methodsFor: 'handlers'!handlePostNameRequest: req response: res	"See 	Request doc https://expressjs.com/en/4x/api.html#req	Response doc https://expressjs.com/en/4x/api.html#res"	self name: req body.	res send: self name! !!PjHelloWorldExpressApp methodsFor: 'initialization'!initialize	super initialize.	self serveStaticFilesIn: self staticFilesFolderName.	server get: '/name' handler: [ :req :res | res send: self name ].	server		post: '/name'		handler: [ :req :res | 		self handlePostNameRequest: req response: res ].	server		get: '/greetings'		handler: [ :req :res | res send: self greetings ]! !!PjHelloWorldExpressApp methodsFor: 'accessing'!name	^ name! !!PjHelloWorldExpressApp methodsFor: 'accessing'!name: anObject	name := anObject! !!PjHelloWorldExpressApp methodsFor: 'initialization'!staticFilesFolderName	^self class staticFilesFolderName! !!PhysicsSim class methodsFor: 'description'!appJsSubFolder	<pharoJsSkip>	^#js! !!PhysicsSim methodsFor: 'initialize - release'!addInitialBodies	| boxA boxB ground |	boxA := self matterJsRoot Bodies rectangle: 400 y: 200 width: 80 height: 80.	boxB := self matterJsRoot Bodies rectangle: 450 y: 50 width: 80 height: 80.	ground := self matterJsRoot Bodies rectangle: 400 y: 610 width: 810 height: 60 options: {#isStatic -> true} asJsObject.	self matterJsRoot World add: engine world bodies: { boxA. boxB. ground }! !!PhysicsSim methodsFor: 'accessing'!bodies	^ engine world bodies! !!PhysicsSim methodsFor: 'initialize - release'!createAndStartEngine	| runner |	engine := self matterJsRoot Engine create.	runner := self matterJsRoot Runner create.	self matterJsRoot Runner run: runner with: engine! !!PhysicsSim methodsFor: 'initialize - release'!initialize	super initialize.	self createAndStartEngine.	self setupAndStartRendering.	self addInitialBodies.	self onClick: #resetButton do: [ 		self matterJsRoot World clear: engine world keepStatic: true]! !!PhysicsSim methodsFor: 'initialize - release'!matterJsRoot	^ window Matter! !!PhysicsSim methodsFor: 'initialize - release'!setupAndStartRendering	| render simulationView |	simulationView := self elementAt: #simulationView.	render := self matterJsRoot Render create: 		{#element -> simulationView.		#engine -> engine.		#options -> {#width -> 800.					#height -> 600.					#wireframes -> false.					#background -> 'transparent'}} asJsObject.	self matterJsRoot Render run: render! !!PjCounterBrowserApp class methodsFor: 'description'!appClasses	<pharoJsSkip>	^super appClasses, {PjCounter. PjCounterController}! !!PjCounterBrowserApp class methodsFor: 'description'!appJsSubFolder	^'js'! !!PjCounterBrowserApp methodsFor: 'accessing'!countDisplay	^ self elementAt: 'countDisplay'! !!PjCounterBrowserApp methodsFor: 'accessing'!incrementButton	^ self elementAt: 'incrementButton'! !!PjCounterBrowserApp methodsFor: 'initialize-release'!initialize	super initialize.	counter := PjCounter new.	controller := PjCounterController new.	controller counter: counter.	controller countDisplay: self countDisplay.	self resetButton addEventListener: #click block: [ controller reset ].	self incrementButton addEventListener: #click block: [ controller increment ]! !!PjCounterBrowserApp methodsFor: 'accessing'!resetButton	^ self elementAt: 'resetButton'! !!PjDisjointForceDirectedGraphExample methodsFor: 'initialization'!addMouseActions	svgNodes on: 'click' do: [ : event | self onClick: event].	svgNodes call: self onDrag.! !!PjDisjointForceDirectedGraphExample methodsFor: 'initialization'!createSimulationWith: data	| forceId distance strength |	dataNodes := data result nodes.	dataLinks := data result links.	simulation := d3 forceSimulation: dataNodes.	forceId := (d3 forceLink: dataLinks) id: [: d | d id].	distance := forceId distance: [ : d  | 1.0 / d score].	strength := distance strength: [ : d | d score ].	simulation force: 'link' with: strength. 	simulation force: 'charge' with: d3 forceManyBody.   simulation force: 'center' with: d3 forceCenter.! !!PjDisjointForceDirectedGraphExample methodsFor: 'initialization'!createSvg	| obj |	svg := d3 create: 'svg'.	svg attr: 'preserveAspectRatio' with: 'xMidYMid meet'.   obj := (svg append: 'g').	obj := obj attr: 'stroke' with: '#999'.	obj := obj attr: 'stroke-opacity' with: 0.8.	obj := obj selectAll: 'line'.	obj := obj data: dataLinks.	obj := obj join: 'line'.	svgLinks := obj attr: 'stroke-width' with: [ : d | d score * 7.0 ].	obj :=  svg append: 'g'.	obj := obj attr: 'stroke' with: '#fff'.	obj := obj attr: 'stroke-opacity' with: 0.5.	obj := obj selectAll: 'circle'.	obj := obj data: dataNodes.	obj := obj join: 'circle'.	obj := obj attr: 'r' with: 5.	svgNodes := obj attr: 'fill' with: [self randomColor].! !!PjDisjointForceDirectedGraphExample methodsFor: 'initialization'!d3	^d3! !!PjDisjointForceDirectedGraphExample methodsFor: 'initialization'!initialize	super initialize.	(d3 json: 'graph.json')		then: [ :data | 			| node |			self createSimulationWith: data.			self createSvg.			self addMouseActions.			node := svg node.			document body append: node.			simulation				on: #tick				do: [ self updateDisplay ] ]! !!PjDisjointForceDirectedGraphExample methodsFor: 'accessing'!maxOf: aCollection	<javascript: 'return Math.max(...aCollection)'>! !!PjDisjointForceDirectedGraphExample methodsFor: 'accessing'!minOf: aCollection	<javascript: 'return Math.min(...aCollection)'>! !!PjDisjointForceDirectedGraphExample methodsFor: 'initialization'!onClick: event	| clickedNode index |	clickedNode := event target.	index := clickedNode parentNode children indexOf: clickedNode. 	window alert: (dataNodes at: index) title.! !!PjDisjointForceDirectedGraphExample methodsFor: 'initialization'!onDrag	| dragStarted dragged dragEnded obj |	dragStarted := [: event |		event active ifFalse: [ (simulation alphaTarget: 0.3) restart ].		event subject at: #fx put: event  subject x.		event subject at: #fy put: event  subject y.   ].  	dragged := [: event| 		event subject at: #fx put: event x.		event subject at: #fy put: event y. 	].                 dragEnded := [: event| 		event active ifFalse: [simulation alphaTarget: 0].		event subject fx: nil.		event subject fy: nil.	].	obj := d3 drag.	obj := obj on: 'start' with: dragStarted.	obj := obj on: 'drag' with: dragged.	^obj on: 'end' with: dragEnded! !!PjDisjointForceDirectedGraphExample methodsFor: 'initialization'!randomColor	| colors randomIndex |	colors := #(pink red blue green yellow orange purple).	randomIndex := self randomIndexOf: colors.	^colors at: randomIndex! !!PjDisjointForceDirectedGraphExample methodsFor: 'initialization'!randomIndexOf: aCollection	<javascript: 'let min = 1;  let max = aCollection.length;  return Math.floor(Math.random() * (max - min) + min);'>! !!PjDisjointForceDirectedGraphExample methodsFor: 'initialization'!updateDisplay	| nodes_x nodes_y min_x min_y w h |	svgLinks		attr: 'x1' with: [: d | d source x];		attr: 'y1' with: [: d | d source y];		attr: 'x2' with: [: d | d target x];		attr: 'y2' with: [: d | d target y].	svgNodes		attr: 'cx' with: [: d | d x];		attr: 'cy' with: [: d | d y]. 	nodes_x := dataNodes map: [: d | d x]. 	nodes_y := dataNodes map: [: d | d y].	min_x := (self minOf: nodes_x) - 10.	min_y := (self minOf: nodes_y) - 10.	w := (self maxOf: nodes_x)  - min_x + 10.	h := (self maxOf: nodes_y)  - min_y + 10.   svg attr: 'viewBox' bounds: {min_x. min_y. w. h}.! !!PjHelloWorldApp class methodsFor: 'description'!appClasses	<pharoJsSkip>	^super appClasses, { PjUser }! !!PjHelloWorldApp methodsFor: 'initialize-release'!start	| nameInput sayHelloButton greetingMessageContainer |	super start.	user := PjUser new.	nameInput := document getElementById: #nameTextInput.	sayHelloButton := document getElementById: #sayHelloButton.	nameInput addEventListener: #change block: [ user name: nameInput value ].	greetingMessageContainer := document getElementById: #greetingMessageContainer.	sayHelloButton addEventListener: #click block: [ greetingMessageContainer innerHTML: 'Hello ' , user name ]! !!PjHelloWorldExpressClientApp class methodsFor: 'accessing' prior: 33969486!serverAppClass	<pharoJsSkip>	^ PjHelloWorldExpressApp! !!PjHelloWorldExpressClientApp methodsFor: 'acting'!greetings: aString	self greetingsContainer textContent: aString! !!PjHelloWorldExpressClientApp methodsFor: 'accessing'!greetingsContainer	^self elementAt: #greetingsMessageContainer! !!PjHelloWorldExpressClientApp methodsFor: 'initialization'!initialize	super initialize.	self		onClickElement: self updateGreetingsButton		do: [ self updateGreetings ].	self onClickElement: self setNameButton do: [ self setName ]! !!PjHelloWorldExpressClientApp methodsFor: 'accessing'!nameInput	^ self elementAt: #nameTextInput! !!PjHelloWorldExpressClientApp methodsFor: 'acting'!setName	| providedName |	providedName := self nameInput value.	providedName size < 2 ifTrue: [ 		^ window alert: 'Please provide a name with at least 2 characters' ].	(window fetch: '/name' with: { (#method -> 'POST'). #body -> providedName } asJsObject) 		then: [ :response | self setNameResponse: response ]! !!PjHelloWorldExpressClientApp methodsFor: 'accessing'!setNameButton	^self elementAt: #setNameButton! !!PjHelloWorldExpressClientApp methodsFor: 'acting'!setNameResponse: response	response ok ifFalse: [ ^window alert: 'Setting name failed!!' ].	self nameInput value: ''.	self updateGreetings! !!PjHelloWorldExpressClientApp methodsFor: 'acting'!updateGreetings	(window fetch: '/greetings') then: [ :response | 		response text then: [ :value | self greetings: value ] ]! !!PjHelloWorldExpressClientApp methodsFor: 'accessing'!updateGreetingsButton	^self elementAt: #updateGreetingsButton! !!PjHtmlGeneratingCounterApp class methodsFor: 'accessing'!pharoJsSelectorPrefix	<pharoJsSkip>	^  '_'! !!PjHtmlGeneratingCounterApp methodsFor: 'initialize-release'!buttonsSharedCss	^ {	#border -> 'none'.	#padding -> '15px 32px'.	#textAlign -> 'center'.	#textDecoration -> 'none'.	#display -> 'inline-block'.	#fontSize -> '16px'}! !!PjHtmlGeneratingCounterApp methodsFor: 'initialize-release'!containerCss	^ {	#width -> '100%'.	#textAlign -> 'center'.	#backgroundColor -> '#ddffdd'.	#padding -> '50px'.	#boxSizing -> 'border-box'}! !!PjHtmlGeneratingCounterApp methodsFor: 'accessing'!count	^ count! !!PjHtmlGeneratingCounterApp methodsFor: 'accessing'!count: newCount	count := newCount.	countDisplay innerHTML: newCount! !!PjHtmlGeneratingCounterApp methodsFor: 'initialize-release'!initialize	| container incrementButton decrementButton |	super initialize.	container := self addElement: 'div' style: self containerCss.	countDisplay := self addElement: 'div' to: container style: {#fontSize -> '300%'}.	self addElement: 'br' to: container.	incrementButton := self addElement: 'button' to: container style: self buttonsSharedCss.	incrementButton innerHTML: 'Increment'.	self setElement: incrementButton style: {#backgroundColor -> '#ccf5ff'}.	self onClickElement: incrementButton do: [ self count: self count + 1 ].	decrementButton := self addElement: 'button' to: container style: self buttonsSharedCss.	decrementButton innerHTML: 'Decrement'.	self onClickElement: decrementButton do: [ self count: self count - 1 ].	self setElement: decrementButton style: {#backgroundColor -> '#ffe6e6'}.	self count: 0! !!PjDrawRectangleApp methodsFor: 'event handling'!onLoad! !!PjDrawRectangleApp methodsFor: 'event handling'!start	super start.	self setupDOM! !!PjDrawRectangleNoDnuApp methodsFor: 'initialize - release'!setupDOM	rectangle := document js_createElement: 'div'.	rectangle js_at:#id put: 'grn'.	colour := 'green'.	(rectangle js_at:#style)		js_at:#backgroundColor put: colour;		js_at:#height put: 3cm;		js_at:#width put: 3cm;		js_at:#margin put: -1.5cm;		js_at:#position put: #absolute;		js_at:#left put: 100px;		js_at:#top put: 150px.	rectangle js_at:#innerHTML put: 'Clck to ','' capitalized,'change' capitalized,' colour'.	rectangle js_addEventListener: #click block: [ : ev |		colour = 'green' ifTrue: [			colour := 'pink'.			(rectangle js_at:#style) js_at:#backgroundColor put: colour		] ifFalse: [			colour = 'pink' ifTrue: [				colour := 'yellow'.			(rectangle js_at:#style) js_at:#backgroundColor put: colour			] ifFalse: ["				self flag: 'TODO: firefox requires the listener in removeEventListener'."				(document js_at:#body) js_removeChild: rectangle.				self stop		]]	].	(document js_at:#body)		js_appendChild: rectangle;		js_addEventListener: #click block: [ : ev | | x y |			x := ev js_at:#pageX.			y := ev js_at:#pageY.			(rectangle js_at:#style)				js_at:#left put: x px;				js_at:#top put: y px		]! !!PjDrawRectangleNoDnuApp methodsFor: 'initialize - release'!subscribeToDeviceEvents	" Bind any events that are required on startup. Common events are:    	 'load', 'deviceready', 'offline', and 'online'."	super subscribeToDeviceEvents.	document js_addEventListener: 'load' block: [: ev | self onLoad].! !!PjDrawRectangleUseDnuApp methodsFor: 'initialize - release'!setupDOM	rectangle := document createElement: 'div'.	rectangle id: 'grn'.	colour := 'green'.	rectangle style 		backgroundColor: colour;		height: 3cm;		width: 3cm;		margin: -1.5cm;		position: #absolute;		left: 100px;		top: 150px.	rectangle innerHTML: 'Clck to change colour'.	rectangle addEventListener: #click block: [ : ev |		colour = 'green' ifTrue: [			colour := 'pink'.			rectangle style backgroundColor: colour		] ifFalse: [			colour = 'pink' ifTrue: [				colour := 'yellow'.				rectangle style backgroundColor: colour			] ifFalse: [				self flag: 'TODO: firefox requires the listener in removeEventListener'.				document body removeChild: rectangle.				self stop		]]	].	document body		appendChild: rectangle;		addEventListener: #click block: [ : ev | | x y |			x := ev pageX.			y := ev pageY.			rectangle style				left: x px;				top: y px		]! !!PjDrawRectangleUseDnuApp methodsFor: 'initialize - release'!subscribeToDeviceEvents	" Bind any events that are required on startup. Common events are:    	 'load', 'deviceready', 'offline', and 'online'."	super subscribeToDeviceEvents.	document addEventListener: 'load' block: [: ev | self onLoad].! !!PjES5vsES6BenchmarkChartsApp class methodsFor: 'accessing'!appJsSubFolder	<pharoJsSkip>	^ #js! !!PjES5vsES6BenchmarkChartsApp class methodsFor: 'accessing'!bridgeClientClass	<pharoJsSkip>	^ PjBridgeServedFileBasedBrowserBridgeClient! !!PjES5vsES6BenchmarkChartsApp methodsFor: 'initialization'!chartCSV: csvString	| canvas data |	canvas := self addElement: 'canvas'.	data := window Papa parse: csvString , { 			                (#header -> true) } asJsObject.	console log: data! !!PjES5vsES6BenchmarkChartsApp methodsFor: 'initialization'!initialize	| canvas data |	super initialize.	canvas := self addElement: 'canvas'.	data := { 		        { 			        (#year -> 2010).			        (#count -> 10) }.		        { 			        (#year -> 2011).			        (#count -> 20) }.		        { 			        (#year -> 2012).			        (#count -> 15) }.		        { 			        (#year -> 2013).			        (#count -> 25) }.		        { 			        (#year -> 2014).			        (#count -> 22) }.		        { 			        (#year -> 2015).			        (#count -> 30) }.		        { 			        (#year -> 2016).			        (#count -> 28) } } asJsObject.	self newChartIn: canvas config: { 			(#type -> 'bar').			(#data -> { 				 (#labels -> (data collect: [ :row | row year ])).				 (#datasets -> { { 					  (#label -> 'Acquisitions by year').					  (#data -> (data collect: [ :row | row count ])) } }) }) }			asJsObject! !!PjES5vsES6BenchmarkChartsApp methodsFor: 'initialization'!initializeNew	super initialize.	(window fetch: 'data/loadTime.csv')		then: [ :response | 			response text then: [ :text | self chartCSV: text ] ];		catch: [ :err | console log: err ]! !!PjES5vsES6BenchmarkChartsApp methodsFor: 'initialization'!initializeOLD	| canvas data |	super initialize.	canvas := self addElement: 'canvas'.	data := { 		        { 			        (#year -> 2010).			        (#count -> 10) }.		        { 			        (#year -> 2011).			        (#count -> 20) }.		        { 			        (#year -> 2012).			        (#count -> 15) }.		        { 			        (#year -> 2013).			        (#count -> 25) }.		        { 			        (#year -> 2014).			        (#count -> 22) }.		        { 			        (#year -> 2015).			        (#count -> 30) }.		        { 			        (#year -> 2016).			        (#count -> 28) } } asJsObject.	self newChartIn: canvas config: { 			(#type -> 'bar').			(#data -> { 				 (#labels -> (data collect: [ :row | row year ])).				 (#datasets -> { { 					  (#label -> 'Acquisitions by year').					  (#data -> (data collect: [ :row | row count ])) } }) }) }			asJsObject! !!PjES5vsES6BenchmarkChartsApp methodsFor: 'instance creation'!newChartIn: containerDom config: chartConfig	<javascript: 'return new Chart(containerDom, chartConfig)'>	! !!PjMinimalWebApplication class methodsFor: 'pharojs support'!css	^ 'body{color:blue}'! !!PjMinimalWebApplication class methodsFor: 'event handling'!log: message	console log: message! !!PjMinimalWebApplication class methodsFor: 'event handling'!start	super start.	console log: 'this is a minimal Browser application'! !!PjCounter methodsFor: 'accessing'!count	^ count! !!PjCounter methodsFor: 'accessing'!count: anObject	count := anObject! !!PjCounter methodsFor: 'initialize - release'!increment	self count: self count + 1! !!PjCounter methodsFor: 'initialize - release'!initialize	super initialize.	self reset! !!PjCounter methodsFor: 'initialize - release'!reset	self count: 0! !!PjCounterController methodsFor: 'accessing'!countDisplay	^ countDisplay! !!PjCounterController methodsFor: 'accessing'!countDisplay: anObject	countDisplay := anObject! !!PjCounterController methodsFor: 'accessing'!counter	^ counter! !!PjCounterController methodsFor: 'accessing'!counter: anObject	counter := anObject! !!PjCounterController methodsFor: 'actions'!increment	self counter increment.	self updateDisplay! !!PjCounterController methodsFor: 'actions'!reset	self counter reset.	self updateDisplay! !!PjCounterController methodsFor: 'displaying'!updateDisplay	self countDisplay innerHTML: self counter count! !!PjUser methodsFor: 'accessing'!name	^name! !!PjUser methodsFor: 'accessing'!name: anObject	name := anObject! !!PjThreeJsDemo class methodsFor: 'description'!appJsSubFolder	<pharoJsSkip>	^#js! !!PjThreeJsDemo methodsFor: 'initialization'!animate	window requestAnimationFrame: [ self animate ].	renderer render: scene camera: camera! !!PjThreeJsDemo methodsFor: 'initialization'!handleKeydown: keyboardEvent	"https://developer.mozilla.org/en-US/docs/Web/API/Element/keydown_event"	keyboardEvent key = 'ArrowRight' ifTrue: [ ^ self rotateY: 1 ].	keyboardEvent key = 'ArrowLeft' ifTrue: [ ^ self rotateY: -1 ].	keyboardEvent key = 'ArrowUp' ifTrue: [ ^ self rotateX: -1 ].	keyboardEvent key = 'ArrowDown' ifTrue: [ ^ self rotateX: 1 ]! !!PjThreeJsDemo methodsFor: 'initialization'!initialize	| geometry material texture canvasWidth canvasHeight canvas |	super initialize.	scene := Scene new.	canvasWidth := 1024.	canvasHeight := canvasWidth / 1.6.	camera := PerspectiveCamera		          new: 75		          with: canvasWidth / canvasHeight		          with: 0.1		          with: 1000.	renderer := WebGLRenderer new.	renderer setSize: canvasWidth height: canvasHeight.	document body appendChild: renderer domElement.	geometry := BoxGeometry new: 1 with: 1 with: 1.	texture := TextureLoader new load:		           'https://pharo.js.org/img/pharoJsBiColorIconWithBorder.jpg'.	material := MeshBasicMaterial new: { (#map -> texture) } asJsObject.	cube := Mesh new: geometry with: material.	scene add: cube.	camera position z: 2.	canvas := document querySelector: 'canvas'.	canvas		setAttribute: #tabindex value: 1;		focus;		addEventListener: #keydown		block: [ :event | self handleKeydown: event ].	self animate! !!PjThreeJsDemo methodsFor: 'initialization'!rotateX: deltaX	| previousRotation newRotation |	previousRotation := cube rotation x.	newRotation := previousRotation + (deltaX * 0.1).	cube rotation x: newRotation! !!PjThreeJsDemo methodsFor: 'initialization'!rotateY: deltaY	| previousRotation newRotation |	previousRotation := cube rotation y.	newRotation := previousRotation + (deltaY * 0.1).	cube rotation y: newRotation! !!PjThreeJsGlobals class methodsFor: 'initialization'!javascriptInitialize	THREE := window THREE.	WebGLRenderer := THREE WebGLRenderer.	Scene := THREE Scene.	BoxGeometry := THREE BoxGeometry.	MeshBasicMaterial := THREE MeshBasicMaterial.	Mesh := THREE Mesh.	PerspectiveCamera := THREE PerspectiveCamera.	TextureLoader := THREE TextureLoader! !"PharoJs-Examples"!!PjCounterTest methodsFor: 'running'!setUp	counter := PjCounter new! !!PjCounterTest methodsFor: 'tests'!testIncrementIncreasesCountBy1	1 to: 10 do: [ : expectedCount |			counter increment.		self assert: counter count equals: expectedCount	]! !!PjCounterTest methodsFor: 'tests'!testInitialCountIs0	self assert: counter count equals: 0! !!PjCounterTest methodsFor: 'tests'!testResetSetsCountTo0	3 timesRepeat: [counter increment].	counter reset.	self assert: counter count equals: 0! !!PjHelloWorldExpressAppApiTest class methodsFor: 'suite parameters'!appClass	^ PjHelloWorldExpressApp ! !!PjHelloWorldExpressAppApiTest methodsFor: 'tests'!testHttpGetGreetings	| response |	response := self get: '/greetings'.	self assert: response contents equals: 'ExpressJS says: Hello!!'.	app name: 'Spiderman'.	self assert: (self get: '/greetings') contents equals: 'ExpressJS says: Hello Spiderman!!'.! !!PjHelloWorldExpressAppApiTest methodsFor: 'tests'!testHttpGetName	| response providedName |	response := self get: '/name'.	self assert: response code equals: 200.	self assert: response contents equals: nil.	providedName := 'Smalltalk Balloon'.	app name: providedName.	self assert: (self get: '/name') contents equals: providedName! !!PjHelloWorldExpressAppApiTest methodsFor: 'tests'!testHttpGetRoot	| response |	response := self get: '/'.	self assert: response isSuccess.	self assert: (response contentType matches: ZnMimeType textHtml).	self assert: (response contents includesSubstring: 'pharoJsLogo')! !!PjHelloWorldExpressAppApiTest methodsFor: 'tests'!testHttpPostName	| response name |	name := 'PharoJS'.	response := self post: '/name' text: name.	self assert: response code equals: 200.	self assert: response contents equals: name.	self assert: (self get: '/name') contents equals: name.	self		assert: (self get: '/greetings') contents		equals: 'ExpressJS says: Hello ' , name , '!!'! !!PhysicsSimTest class methodsFor: 'suite parameters'!appClass	^PhysicsSim! !!PhysicsSimTest methodsFor: 'tests'!testAppInitialSetup	self assert: app bodies size equals: 3! !!PhysicsSimTest methodsFor: 'tests'!testResetDeleteMobileBodiesOnly	self clickElementById: #resetButton.	self assert: app bodies size equals: 1.! !!PjCounterBrowserAppTest class methodsFor: 'suite parameters'!appClass	^PjCounterBrowserApp! !!PjCounterBrowserAppTest methodsFor: 'tests'!setUp	super setUp.	countDisplay := app countDisplay.	resetButton := app resetButton.	incrementButton := app incrementButton.! !!PjCounterBrowserAppTest methodsFor: 'tests'!testClickOnIncrementButtonIncreasesCountAndUpdatesDisplay	1 to: 10 do: [ : expectedCount |		incrementButton click.		self assert: countDisplay innerHTML equals: expectedCount asString	]! !!PjCounterBrowserAppTest methodsFor: 'tests'!testClickOnResetButtonSetsCountTo0	3 timesRepeat: [incrementButton click.].	resetButton click.	self assert: countDisplay innerHTML equals: '0'! !!PjCounterBrowserAppTest methodsFor: 'tests'!testInitialCountDisplayIs0	self assert: countDisplay innerHTML equals: '0'! !!PjHelloWorldAppTest class methodsFor: 'suite parameters'!appClass	^PjHelloWorldApp! !!PjHelloWorldAppTest methodsFor: 'running'!setUp	super setUp.	nameInput := document getElementById: #nameTextInput.	sayHelloButton := document getElementById: #sayHelloButton.	greetingMessageContainer := document getElementById: #greetingMessageContainer.! !!PjHelloWorldAppTest methodsFor: 'tests'!testSayHello	#(Luke Yoda 'Obi One') do: [ : name |		self changeElement: nameInput value: name.		self clickElement: sayHelloButton.		self assert: (greetingMessageContainer innerHTML endsWith: name)	]! !!PjHelloWorldExpressClientAppTest class methodsFor: 'suite parameters'!appClass	^ PjHelloWorldExpressClientApp! !!PjHelloWorldExpressClientAppTest methodsFor: 'tests'!testDisplayGreetingsNoName	self assert: app greetingsContainer textContent equals: '---'.	self clickElement: app updateGreetingsButton.	self waitUntil: [ 		app greetingsContainer textContent = 'ExpressJS says: Hello!!' ]! !!PjHelloWorldExpressClientAppTest methodsFor: 'tests'!testGreetingsUpdatedAfterSettingName	self assert: app greetingsContainer textContent equals: '---'.	app nameInput value: 'Test Name'.	self clickElement: app setNameButton.	self waitUntil: [ 		app greetingsContainer textContent		= 'ExpressJS says: Hello Test Name!!' ]! !!PjHelloWorldExpressClientAppTest methodsFor: 'initialization' prior: 34120687!urlPathString	^'/'! !!PjMinimalNodeApplicationTest class methodsFor: 'suite parameters'!appClass 	^PjMinimalNodeApplication ! !!PjMinimalNodeApplicationTest methodsFor: 'tests'!exportedAppJsFileChangeTime	^ self appClass appFullJsFileName resolve changeTime! !!PjMinimalNodeApplicationTest methodsFor: 'tests'!testArithmeticOperations	self assert: [ 1+2 ] evaluatesTo: 3.	self assert: [ 32 / 8 ] evaluatesTo: 4.! !!PjMinimalNodeApplicationTest methodsFor: 'tests'!testLoadClass	| jsCounter |	jsCounter := self evalBlock: [ PjCounter new ].	self assert: jsCounter count equals: 0.	1 to: 3 do: [ : expectedCount | 		jsCounter increment.		self assert: jsCounter count equals: expectedCount	]! !!PjMinimalNodeApplicationTest methodsFor: 'tests'!testResetApp	| initialChangeTime latestChangeTime |	self evalBlock: [ global instVarNamed: #forTest put: 3 ].	self assert: [ global instVarNamed: #forTest ] evaluatesTo: 3.	initialChangeTime := self exportedAppJsFileChangeTime.	self resetApp.	self assert: [ global instVarNamed: #forTest ] evaluatesTo: nil.	latestChangeTime := self exportedAppJsFileChangeTime.	self assert: latestChangeTime equals: initialChangeTime! !"PharoJs-Examples-Tests"!!PjNodeTimingApplication commentStamp: '' prior: 0!I am the class that provides comparative timing on NodeJS.I run tests that have no explicit reference to Javascript objects, tests that reference generic top-level object, and tests that are specific to NodeJS.!!PjTimingTestTranspiler commentStamp: '' prior: 0!I am a transpiler that can be controlled to support the timing application/!!PjBrowserTimingApplication commentStamp: '' prior: 0!I am the class that provides comparative timing on browsers.I run tests that have no explicit reference to Javascript objects, tests that reference generic top-level object, and tests that are specific to browsers with a DOM.!!PjTimingPlatformApp commentStamp: '' prior: 0!I am an App to determine timings of blocks.This is used to justify optimizations!!PjDbPlan commentStamp: '' prior: 0!A Plan is an ordered list of constraints to be executed in sequence toresatisfy all currently satisfiable constraints in the face of one or morechanging inputs.!!PjDbAbstractConstraint commentStamp: '' prior: 0!I am an abstract class representing a system-maintainable relationship (or"constraint") between a set of variables. I supply a strength instancevariable; concrete subclasses provide a means of storing the constrainedvariables and other information required to represent a constraint.Instance variables:	strength			the strength of this constraint <Strength>!!PjDbBinaryConstraint commentStamp: '' prior: 0!I am an abstract superclass for constraints having two possible outputvariables.Instance variables:	v1, v2		possible output variables <Variable>	direction		one of:					#forward (v2 is output)					#backward (	v1 is output)					nil (not satisfied)!!PjDbEqualityConstraint commentStamp: '' prior: 0!I constrain two variables to have the same value: "v1 = v2".!!PjDbScaleConstraint commentStamp: '' prior: 0!I relate two variables by the linear scaling relationship:"v2 = (v1 * scale) + offset". Either v1 or v2 may be changed to maintain thisrelationship but the scale factor and offset are considered read-only.Instance variables:	scale		scale factor input variable <Variable>	offset		offset input variable <Variable>!!PjDbUnaryConstraint commentStamp: '' prior: 0!I am an abstract superclass for constraints having a single possible outputvariable.Instance variables:	output		possible output variable <Variable>	satisfied		true if I am currently satisfied <Boolean>!!PjDbEditConstraint commentStamp: '' prior: 0!I am a unary input constraint used to mark a variable that the clientwishes to change.!!PjDbStayConstraint commentStamp: '' prior: 0!I mark variables that should, with some level of preference, stay the same.I have one method with zero inputs and one output, which does nothing. Plannersmay exploit the fact that, if I am satisfied, my output will not change duringplan execution. This is called "stay optimization."!!PjDbPlanner commentStamp: '' prior: 0!This benchmark is an implementation of the DeltaBlue Constraint Solverdescribed in `The DeltaBlue Algorithm: An Incremental ConstraintHierarchy Solver', by Bjorn N. Freeman-Benson and John Maloney,Communications of the ACM, January 1990 (also as University ofWashington TR 89-08-06). To run the benchmark, execute the expression `Planner standardBenchmark'.!!PjDbStrength commentStamp: '' prior: 0!Strengths are used to measure the relative importance of constraints. Thehierarchy of available strengths is determined by the class variableStrengthTable (see my class initialization method). Because Strengths areinvariant, references to Strength instances are shared (i.e. all references to"Strength of: #required" point to a single, shared instance). New strengths maybe inserted in the strength hierarchy without disrupting current constraints.Instance variables:	symbolicValue		symbolic strength name (e.g. #required) <Symbol>	arithmeticValue		index of the constraint in the hierarchy, used for comparisons <Number>!!PjDbVariable commentStamp: '' prior: 0!I represent a constrained variable. In addition to my value, I maintain thestructure of the constraint graph, the current dataflow graph, and variousparameters of interest to the DeltaBlue incremental constraint solver.Instance variables:	value			my value; changed by constraints, read by client <Object>	constraints		normal constraints that reference me <Array of Constraint>	determinedBy	the constraint that currently determines					my value (or nil if there isn't one) <Constraint>	walkStrength		my walkabout strength <Strength>	stay			true if I am a planning-time constant <Boolean>	mark			used by the planner to mark constraints <Number>!!PjPharoTimingApplication commentStamp: '' prior: 0!I am the class that provides comparative timing on Pharo or other native Smalltalk systems.I only run tests that have no explicit reference to Javascript objects.!!PjTimingApplication commentStamp: '' prior: 0!I am the class with actual benchmark code.I have 4 class methods for the actual benchmarks, and a variety of instance methods to support them.!!PjTimingTest commentStamp: '' prior: 0!I run timings of blocks on a Javascript engine.My primary use is to explore how useful a given optimization is, as I record the ratio of unoptimized versus optimized Javascript code.!!PjNodeTimingApplication class methodsFor: 'accessing - description'!appClasses	<pharoJsSkip>	^ super appClasses , { PjTimingApplication }! !!PjNodeTimingApplication class methodsFor: 'accessing - description'!appJsFileName	<pharoJsSkip>	^ 'node.js'! !!PjNodeTimingApplication class methodsFor: 'settings'!playgroundDoNotList	<pharoJsSkip>! !!PjNodeTimingApplication class methodsFor: 'start-stop application'!start	<script>		PjTimingApplication runTimings: self new! !!PjNodeTimingApplication methodsFor: 'accessing'!cr	^self! !!PjNodeTimingApplication methodsFor: 'initialization'!initialize	printedIterations := iterations := 1000000! !!PjNodeTimingApplication methodsFor: 'accessing'!iterations	^ iterations! !!PjNodeTimingApplication methodsFor: 'accessing'!log: aString	console log: aString! !!PjNodeTimingApplication methodsFor: 'accessing'!prefix: aString	prefix := aString! !!PjNodeTimingApplication methodsFor: 'accessing'!runs	^ 10! !!PjNodeTimingApplication methodsFor: 'accessing'!show: aString	console log: aString! !!PjNodeTimingApplication methodsFor: 'accessing'!time	PjTimingApplication allTimingOn: self.	PjTimingApplication jsTimingOn: self top: global.	PjTimingApplication nodeTimingOn: self! !!PjNodeTimingApplication methodsFor: 'accessing'!time: aString with: aBlock ratio: ratio	| iters |	iters := (iterations * ratio) asInteger.	iters isZero ifTrue: [ iters := 1 ].	printedIterations = iters ifFalse: [		self show: 'Running ';show: iters;show: ' iterations';cr.		printedIterations := iters	].	console time: prefix,aString.	iters timesRepeat: [aBlock value].	console timeEnd: prefix,aString! !!PjNodeTimingApplication methodsFor: 'accessing'!warmups	^ 5! !!PjTimingTestTranspiler methodsFor: 'accessing'!delayDNU	^delayDNU! !!PjTimingTestTranspiler methodsFor: 'accessing'!delayDNU: anObject	delayDNU := anObject! !!PjTimingTestTranspiler methodsFor: 'transpiling'!generateCodeStringFrom: jsAst	self delayDNU		ifFalse: [ self enableWriteDnuDuring: [ self writeDnuList ] ].	generator asString: jsAst on: self jsStream! !!PjTimingTestTranspiler methodsFor: 'initailize-release'!initialize	super initialize.	self delayDNU: false.! !!PjBrowserTimingApplication class methodsFor: 'accessing - description'!appClasses	<pharoJsSkip>		^ super appClasses , { PjTimingApplication }! !!PjBrowserTimingApplication class methodsFor: 'settings'!playgroundDoNotList	<pharoJsSkip>	! !!PjBrowserTimingApplication class methodsFor: 'start-stop application'!start	<script>		PjTimingApplication runTimings: self new! !!PjBrowserTimingApplication methodsFor: 'accessing'!cr	^self! !!PjBrowserTimingApplication methodsFor: 'initialization'!initialize	super initialize.	printedIterations := iterations := 1000000! !!PjBrowserTimingApplication methodsFor: 'accessing'!iterations	^ iterations! !!PjBrowserTimingApplication methodsFor: 'accessing'!log: aString	console log: aString.	(document getElementById: #log) ifNotNil: [ : log | log innerHTML: log innerHTML, aString ]! !!PjBrowserTimingApplication methodsFor: 'accessing'!prefix: aString	prefix := aString! !!PjBrowserTimingApplication methodsFor: 'accessing'!runs	^ 10! !!PjBrowserTimingApplication methodsFor: 'accessing'!show: aString	console log: aString.	(document getElementById: #log) ifNotNil: [ : log | log innerHTML: log innerHTML, aString ]! !!PjBrowserTimingApplication methodsFor: 'accessing'!time	PjTimingApplication allTimingOn: self.	PjTimingApplication jsTimingOn: self top: document.	PjTimingApplication browserTimingOn: self! !!PjBrowserTimingApplication methodsFor: 'accessing'!time: aString with: aBlock ratio: ratio	| iters |	iters := (iterations * ratio) asInteger.	iters isZero ifTrue: [ iters := 1 ].	printedIterations = iters ifFalse: [ 		self			show: 'Running ';			show: iters;			show: ' iterations';			cr.		printedIterations := iters ].	console time: prefix , aString.	iters timesRepeat: aBlock.	console timeEnd: prefix , aString! !!PjBrowserTimingApplication methodsFor: 'accessing'!warmups	^ 5! !!PjTimingPlatformApp class methodsFor: 'exporting'!appJsFileName	<pharoJsSkip>		^ 'timing.js'! !!PjTimingPlatformApp class methodsFor: 'timing'!excessiveVariance: results	^ false! !!PjTimingPlatformApp class methodsFor: 'timing'!findBaseIterations: aBlock and: aBlock2 min: mintime	| elapsed |	elapsed := 0.	[ (elapsed := (self timeBlock: aBlock) + (self timeBlock: aBlock2) / 2) < mintime ] whileTrue: [		console log: iterations.		iterations := iterations + iterations	].	[ (elapsed := (self timeBlock: aBlock) + (self timeBlock: aBlock2) / 2) /3  > mintime ] whileTrue: [		console log: iterations.		iterations := iterations * 2 // 3	].! !!PjTimingPlatformApp class methodsFor: 'timing'!findStableTiming: aBlock	| results |	results := #().	[ results size < minimumTrials or: [ self excessiveVariance: results ]] whileTrue: [		results add: (self timeBlock: aBlock)	].	^ results! !!PjTimingPlatformApp class methodsFor: 'for testing'!ifFalseExample: arg	arg < 10 ifFalse: [ ^ arg ]! !!PjTimingPlatformApp class methodsFor: 'for testing'!ifTrueExample: arg	arg >= 10 ifTrue: [ ^ arg ]! !!PjTimingPlatformApp class methodsFor: 'public'!playgroundDoNotList	< pharoJsSkip >! !!PjTimingPlatformApp class methodsFor: 'start-stop application'!start! !!PjTimingPlatformApp class methodsFor: 'timing'!timeBlock: aBlock	<javascript: '	var start= +new Date();	for(var i=this.iterations|0;i>0;--i){aBlock()};	return +new Date()-start;'>! !!PjTimingPlatformApp class methodsFor: 'public'!timeNull: nullBlock nonOptimized: nonBlock optimized: optBlock	| nullTime nonTime optTime |	iterations := 100.	self findBaseIterations: nonBlock and: optBlock min: 400.	minimumTrials := 3.	nullTime := self findStableTiming: nullBlock.	nonTime := self findStableTiming: nonBlock.	optTime := self findStableTiming: optBlock.	^ JSON stringify: { nullTime. nonTime. optTime }! !!PjDbPlan methodsFor: 'execution'!execute	"Execute my constraints in order."	self do: [: c | c execute].! !!PjDbAbstractConstraint class methodsFor: 'testing'!isAbstract	^ self = PjDbAbstractConstraint! !!PjDbAbstractConstraint methodsFor: 'add/remove'!addConstraint	"Activate this constraint and attempt to satisfy it."	self addToGraph.	PjDbPlanner current incrementalAdd: self! !!PjDbAbstractConstraint methodsFor: 'add/remove'!addToGraph	"Add myself to the constraint graph."	self subclassResponsibility! !!PjDbAbstractConstraint methodsFor: 'planning'!chooseMethod: mark	"Decide if I can be satisfied and record that decision. The output of	 the choosen method must not have the given mark and must have a	 walkabout strength less than that of this constraint."	self subclassResponsibility! !!PjDbAbstractConstraint methodsFor: 'add/remove'!destroyConstraint	"Deactivate this constraint, remove it from the constraint graph,	 possibly causing other constraints to be satisfied, and destroy it."	(self isSatisfied) ifTrue: [PjDbPlanner current incrementalRemove: self].	self removeFromGraph.	self release! !!PjDbAbstractConstraint methodsFor: 'planning'!execute	"Enforce this constraint. Assume that it is satisfied."	self subclassResponsibility! !!PjDbAbstractConstraint methodsFor: 'planning'!inputsDo: aBlock	"Assume that I am satisfied. Evaluate the given block on all my current	 input variables."	self subclassResponsibility! !!PjDbAbstractConstraint methodsFor: 'planning'!inputsKnown: mark	"Assume that I am satisfied. Answer true if all my current inputs are	 known. A variable is known if either a) it is 'stay' (i.e. it is a	 constant at plan execution time), b) it has the given mark (indicating	 that it has been computed by a constraint appearing earlier in the	 plan), or c) it is not determined by any constraint."	self inputsDo:		[: v |		 ((v mark = mark) or: [(v stay) or: [v determinedBy == nil]]) ifFalse:			[^false]].	^true! !!PjDbAbstractConstraint methodsFor: 'queries'!isInput	"Normal constraints are not input constraints. An input constraint is	 one that depends on external state, such as the mouse, the keyboard,	 a clock, or some arbitrary piece of imperative code."	^false! !!PjDbAbstractConstraint methodsFor: 'queries'!isSatisfied	"Answer true if this constraint is satisfied in the current solution."	self subclassResponsibility! !!PjDbAbstractConstraint methodsFor: 'printing'!longPrintOn: aStream	 	aStream nextPut: $(.	self shortPrintOn: aStream.	aStream space; nextPutAll: self strength printString.	(self isSatisfied)		ifTrue:			[aStream cr; space; space; space.			 self inputsDo:				[: in | aStream nextPutAll: 'v', in asOop printString, ' '].			aStream nextPutAll: '-> '.			aStream nextPutAll: 'v', self output asOop printString]		ifFalse:			[aStream space; nextPutAll: 'UNSATISFIED'].	aStream nextPut: $); cr.! !!PjDbAbstractConstraint methodsFor: 'planning'!markUnsatisfied	"Record the fact that I am unsatisfied."	self subclassResponsibility! !!PjDbAbstractConstraint methodsFor: 'planning'!output	"Answer my current output variable. Raise an error if I am not	 currently satisfied."	self subclassResponsibility! !!PjDbAbstractConstraint methodsFor: 'printing'!printOn: aStream	self shortPrintOn: aStream! !!PjDbAbstractConstraint methodsFor: 'planning'!recalculate	"Calculate the walkabout strength, the stay flag, and, if it is 'stay',	 the value for the current output of this constraint. Assume this	 constraint is satisfied."	self subclassResponsibility! !!PjDbAbstractConstraint methodsFor: 'add/remove'!removeFromGraph	"Remove myself from the constraint graph."	self subclassResponsibility! !!PjDbAbstractConstraint methodsFor: 'planning'!satisfy: mark	"Attempt to find a way to enforce this (still unsatisfied) constraint.	 If successful, record the solution, perhaps modifying the current	 dataflow graph.  Answer the constraint that this constraint overrides,	 if there is one, or nil, if there isn't."	| overridden out |	self chooseMethod: mark.	(self isSatisfied)		ifTrue:			"constraint can be satisfied"			["mark inputs to allow cycle detection in addPropagate"			 self inputsDo: [: in | in mark: mark].			 out := self output.			 overridden := out determinedBy.			 (overridden == nil) ifFalse: [overridden markUnsatisfied].			 out determinedBy: self.			 (PjDbPlanner current addPropagate: self mark: mark) ifFalse:				[self notify:					('Cycle encountered adding:\   ',					 self printString,					 '\Constraint removed.') withCRs.				 ^nil].			 out mark: mark]		ifFalse:			"constraint cannot be satisfied"			[overridden := nil.			 (strength sameAs: (PjDbStrength required)) ifTrue:				[self notify: 'Failed to satisfy a required constraint']].	^overridden! !!PjDbAbstractConstraint methodsFor: 'printing'!shortPrintOn: aStream	aStream nextPutAll: self class name, '(', self asOop printString, ')'.! !!PjDbAbstractConstraint methodsFor: 'accessing'!strength	"Answer my strength."	^strength! !!PjDbAbstractConstraint methodsFor: 'accessing'!strength: strengthSymbol	"Set my strength."	strength := PjDbStrength of: strengthSymbol.! !!PjDbBinaryConstraint class methodsFor: 'testing'!isAbstract	^ self = PjDbBinaryConstraint! !!PjDbBinaryConstraint methodsFor: 'add/remove'!addToGraph	"Add myself to the constraint graph."	v1 addConstraint: self.	v2 addConstraint: self.	direction := nil.! !!PjDbBinaryConstraint methodsFor: 'planning'!chooseMethod: mark	"Decide if I can be satisfied and which way I should flow based on	 the relative strength of the variables I relate, and record that	 decision."	(v1 mark == mark) ifTrue:		"forward or nothing"		[((v2 mark ~= mark) and: [strength stronger: v2 walkStrength])			ifTrue: [^direction := #forward]			ifFalse: [^direction := nil]].	(v2 mark == mark) ifTrue:		"backward or nothing"		[((v1 mark ~= mark) and: [strength stronger: v1 walkStrength])			ifTrue: [^direction := #backward]			ifFalse: [^direction := nil]].	"if we get here, neither variable is marked, so we have choice"	(v1 walkStrength weaker: v2 walkStrength)		ifTrue:			[(strength stronger: v1 walkStrength)				ifTrue: [^direction := #backward]				ifFalse: [^direction := nil]]		ifFalse:			[(strength stronger: v2 walkStrength)				ifTrue: [^direction := #forward]				ifFalse: [^direction := nil]].! !!PjDbBinaryConstraint methodsFor: 'planning'!execute	"Enforce this constraint. Assume that it is satisfied."	self subclassResponsibility! !!PjDbBinaryConstraint methodsFor: 'planning'!inputsDo: aBlock	"Evaluate the given block on my current input variable."	(direction == #forward)		ifTrue: [aBlock value: v1]		ifFalse: [aBlock value: v2].! !!PjDbBinaryConstraint methodsFor: 'queries'!isSatisfied	"Answer true if this constraint is satisfied in the current solution."	^direction notNil! !!PjDbBinaryConstraint methodsFor: 'planning'!markUnsatisfied	"Record the fact that I am unsatisfied."	direction := nil.! !!PjDbBinaryConstraint methodsFor: 'planning'!output	"Answer my current output variable."	(direction == #forward)		ifTrue: [^v2]		ifFalse: [^v1]! !!PjDbBinaryConstraint methodsFor: 'planning'!recalculate	"Calculate the walkabout strength, the stay flag, and, if it is 'stay',         the value for the current output of this constraint. Assume this	 constraint is satisfied."	| in out |	(direction == #forward)		ifTrue: [in := v1. out := v2]		ifFalse: [in := v2. out := v1].	out walkStrength: (strength weakest: in walkStrength).	out stay: (in stay).	(out stay) ifTrue: [self execute].		"stay optimization"! !!PjDbBinaryConstraint methodsFor: 'add/remove'!removeFromGraph	"Remove myself from the constraint graph."	(v1 == nil) ifFalse: [v1 removeConstraint: self].	(v2 == nil) ifFalse: [v2 removeConstraint: self].	direction := nil.! !!PjDbBinaryConstraint methodsFor: 'initialize-release'!var: variable1 var: variable2 strength: strengthSymbol	"Initialize myself with the given variables and strength."	strength := PjDbStrength of: strengthSymbol.	v1 := variable1.	v2 := variable2.	direction := nil.	self addConstraint.! !!PjDbEqualityConstraint class methodsFor: 'instance creation'!var: variable1 var: variable2 strength: strengthSymbol	"Install a constraint with the given strength equating the given	 variables."	^(self new) var: variable1 var: variable2 strength: strengthSymbol! !!PjDbEqualityConstraint methodsFor: 'execution'!execute	"Enforce this constraint. Assume that it is satisfied."	(direction == #forward)		ifTrue: [v2 value: v1 value]		ifFalse: [v1 value: v2 value].! !!PjDbScaleConstraint class methodsFor: 'instance creation'!var: src var: scale var: offset var: dst strength: strengthSymbol	"Install a scale constraint with the given strength on the given	 variables."	^(self new) src: src scale: scale offset: offset dst: dst strength: strengthSymbol! !!PjDbScaleConstraint methodsFor: 'add/remove'!addToGraph	"Add myself to the constraint graph."	v1 addConstraint: self.	v2 addConstraint: self.	scale addConstraint: self.	offset addConstraint: self.	direction := nil.! !!PjDbScaleConstraint methodsFor: 'planning'!execute	"Enforce this constraint. Assume that it is satisfied."	(direction == #forward)		ifTrue: [v2 value: (v1 value * scale value) + offset value]		ifFalse: [v1 value: (v2 value - offset value) // scale value].! !!PjDbScaleConstraint methodsFor: 'planning'!inputsDo: aBlock	"Evaluate the given block on my current input variable."	(direction == #forward)		ifTrue: [aBlock value: v1; value: scale; value: offset]		ifFalse: [aBlock value: v2; value: scale; value: offset].! !!PjDbScaleConstraint methodsFor: 'planning'!recalculate	"Calculate the walkabout strength, the stay flag, and, if it is 'stay',	 the value for the current output of this constraint. Assume this	 constraint is satisfied."	| in out |	(direction == #forward)		ifTrue: [in := v1. out := v2]		ifFalse: [out := v1. in := v2].	out walkStrength: (strength weakest: in walkStrength).	out stay: ((in stay) and: [(scale stay) and: [offset stay]]).	(out stay) ifTrue: [self execute].		"stay optimization"! !!PjDbScaleConstraint methodsFor: 'add/remove'!removeFromGraph	"Remove myself from the constraint graph."	(v1 == nil) ifFalse: [v1 removeConstraint: self].	(v2 == nil) ifFalse: [v2 removeConstraint: self].	(scale == nil) ifFalse: [scale removeConstraint: self].	(offset == nil) ifFalse: [offset removeConstraint: self].	direction := nil.! !!PjDbScaleConstraint methodsFor: 'initialize-release'!src: srcVar scale: scaleVar offset: offsetVar dst: dstVar strength: strengthSymbol	"Initialize myself with the given variables and strength."	strength := PjDbStrength of: strengthSymbol.	v1 := srcVar.	v2 := dstVar.	scale := scaleVar.	offset := offsetVar.	direction := nil.	self addConstraint.! !!PjDbEditConstraint class methodsFor: 'instance creation'!var: aVariable strength: strengthSymbol	"Install an edit constraint with the given strength on the given	 variable."	^(self new) var: aVariable strength: strengthSymbol! !!PjDbEditConstraint methodsFor: 'execution'!execute	"Edit constraints do nothing."! !!PjDbEditConstraint methodsFor: 'queries'!isInput	"I indicate that a variable is to be changed by imperative code."	^true! !!PjDbStayConstraint class methodsFor: 'instance creation'!var: aVariable strength: strengthSymbol	"Install a stay constraint with the given strength on the given variable."	^(self new) var: aVariable strength: strengthSymbol! !!PjDbStayConstraint methodsFor: 'execution'!execute	"Stay constraints do nothing."! !!PjDbUnaryConstraint class methodsFor: 'testing'!isAbstract	^ self = PjDbUnaryConstraint! !!PjDbUnaryConstraint methodsFor: 'add/remove'!addToGraph	"Add myself to the constraint graph."	output addConstraint: self.	satisfied := false.! !!PjDbUnaryConstraint methodsFor: 'planning'!chooseMethod: mark	"Decide if I can be satisfied and record that decision."	satisfied :=		(output mark ~= mark) and:		[strength stronger: output walkStrength].! !!PjDbUnaryConstraint methodsFor: 'planning'!execute	"Enforce this constraint. Assume that it is satisfied."	self subclassResponsibility! !!PjDbUnaryConstraint methodsFor: 'planning'!inputsDo: aBlock	"I have no input variables."! !!PjDbUnaryConstraint methodsFor: 'queries'!isSatisfied	"Answer true if this constraint is satisfied in the current solution."	^satisfied! !!PjDbUnaryConstraint methodsFor: 'planning'!markUnsatisfied	"Record the fact that I am unsatisfied."	satisfied := false.! !!PjDbUnaryConstraint methodsFor: 'planning'!output	"Answer my current output variable."	^output! !!PjDbUnaryConstraint methodsFor: 'planning'!recalculate	"Calculate the walkabout strength, the stay flag, and, if it is 'stay',	 the value for the current output of this constraint. Assume this	 constraint is satisfied."	output walkStrength: strength.	output stay: (self isInput not).	(output stay) ifTrue: [self execute].	"stay optimization"! !!PjDbUnaryConstraint methodsFor: 'add/remove'!removeFromGraph	"Remove myself from the constraint graph."	(output == nil) ifFalse: [output removeConstraint: self].	satisfied := false.! !!PjDbUnaryConstraint methodsFor: 'initialize-release'!var: aVariable strength: strengthSymbol	"Initialize myself with the given variable and strength."	strength := PjDbStrength of: strengthSymbol.	output := aVariable.	satisfied := false.	self addConstraint.! !!PjDbPlanner class methodsFor: 'benchmarks'!chainTest: n	"Do chain-of-equality-constraints performance tests."	| vars editConstraint plan planner |	planner := PjDbPlanner new.	vars := (1 to: n+1) collect: [ :i | PjDbVariable new].	"thread a chain of equality constraints through the variables"	1 to: n do:		[ :i || v1 v2 |		 v1 := vars at: i.		 v2 := vars at: i + 1.		 PjDbEqualityConstraint var: v1 var: v2 strength: #required].	PjDbStayConstraint var: vars last strength: #strongDefault.	editConstraint := PjDbEditConstraint var: (vars first) strength: #preferred.	plan := planner extractPlanFromConstraints: (Array with: editConstraint).	1 to: 100 do: [ :v | 		vars first value: v.		plan execute.		vars last value ~= v ifTrue: [self error: 'Chain test failed!!']].	editConstraint destroyConstraint! !!PjDbPlanner class methodsFor: 'accessing'!current	^currentPlanner! !!PjDbPlanner class methodsFor: 'instance creation'!new	^currentPlanner := super new initialize! !!PjDbPlanner class methodsFor: 'benchmarks'!projectionTest: n	"This test constructs a two sets of variables related to each other by	 a simple linear transformation (scale and offset)."	| scale offset src dst planner dests |	planner := PjDbPlanner new.	dests := OrderedCollection new.	scale := PjDbVariable value: 10.	offset := PjDbVariable value: 1000.	1 to: n do:		[ :i |		src := PjDbVariable value: i.		dst := PjDbVariable value: i.		dests add: dst.		PjDbStayConstraint var: src strength: #default.		PjDbScaleConstraint var: src var: scale var: offset var: dst strength: #required].	planner changeVar: src newValue: 17.	dst value ~= 1170 ifTrue: [self error: 'Projection test 1 failed!!'].	planner changeVar: dst newValue: 1050.	src value ~= 5 ifTrue: [self error: 'Projection test 2 failed!!'].	planner changeVar: scale newValue: 5.	1 to: n - 1 do: [ :i |		(dests at: i) value ~= (i*5 + 1000)			ifTrue: [self error: 'Projection test 3 failed!!']].	planner changeVar: offset newValue: 2000.	1 to: n - 1 do: [ :i |		(dests at: i) value ~= (i*5 + 2000)			ifTrue: [self error: 'Projection test 4 failed!!']].! !!PjDbPlanner class methodsFor: 'benchmarks'!report: string times: count run: aBlock	<pharoJsSkip>	"Report the time required to execute the given block."	| time |	time := Time millisecondsToRun: [count timesRepeat: aBlock].	Transcript show: string, ' ', (time // count) printString, ' milliseconds'; cr.! !!PjDbPlanner class methodsFor: 'benchmarks'!standardBenchmark	<pharoJsSkip>	"This the combined benchmark."	"PjDbPlanner standardBenchmark"	self report: 'Chain and projection tests' times: 100 run: [		self chainTest: 10000. 		self projectionTest: 10000	]! !!PjDbPlanner methodsFor: 'private'!addConstraintsConsuming: v to: aCollection	| determiningC |	determiningC := v determinedBy.	v constraints do:		[: c |		 ((c == determiningC) or: [c isSatisfied not]) ifFalse:			[aCollection add: c]]! !!PjDbPlanner methodsFor: 'private'!addPropagate: c mark: mark	"Recompute the walkabout strengths and stay flags of all variables	 downstream of the given constraint and recompute the actual values	 of all variables whose stay flag is true. If a cycle is detected,	 remove the given constraint and answer false. Otherwise, answer true.	 Details: Cycles are detected when a marked variable is encountered	 downstream of the given constraint. The sender is assumed to have	 marked the inputs of the given constraint with the given mark. Thus,	 encountering a marked node downstream of the output constraint means	 that there is a path from the constraint's output to one of its	 inputs."	| todo d |	todo := OrderedCollection with: c.	[todo isEmpty] whileFalse:		[d := todo removeFirst.		 (d output mark = mark) ifTrue:			[self incrementalRemove: c.			 ^false].		 d recalculate.		 self addConstraintsConsuming: d output to: todo].	^true! !!PjDbPlanner methodsFor: 'private'!changeVar: aVariable newValue: newValue	| editConstraint plan |	editConstraint := PjDbEditConstraint		                  var: aVariable		                  strength: #preferred.	plan := self extractPlanFromConstraints: (Array with: editConstraint).	10 timesRepeat: [ 		aVariable value: newValue.		plan execute ].	editConstraint destroyConstraint! !!PjDbPlanner methodsFor: 'private'!constraintsConsuming: v do: aBlock	| determiningC |	determiningC := v determinedBy.	v constraints do: [ :c | 		(c == determiningC or: [ c isSatisfied not ]) ifFalse: [ 			aBlock value: c ] ]! !!PjDbPlanner methodsFor: 'planning/value propagation'!extractPlanFromConstraints: constraints	"Extract a plan for resatisfaction starting from the outputs of the	 given constraints, usually a set of input constraints."	| sources |	sources := OrderedCollection new.	constraints do: [ :c | 		(c isInput and: [ c isSatisfied ]) ifTrue: [ sources add: c ] ].	^ self makePlan: sources! !!PjDbPlanner methodsFor: 'planning/value propagation'!extractPlanFromVariables: variables	"Extract a plan from the dataflow graph having the given variables. It	 is assumed that the given set of variables is complete, or at least	 that it contains all the input variables."	| sources |	sources := OrderedCollection new.	variables do: [ :v | 		v constraints do: [ :c | 			(c isInput and: [ c isSatisfied ]) ifTrue: [ sources add: c ] ] ].	^ self makePlan: sources! !!PjDbPlanner methodsFor: 'add/remove'!incrementalAdd: c	"Attempt to satisfy the given constraint and, if successful,	 incrementally update the dataflow graph.	 Details: If satifying the constraint is successful, it may override a	 weaker constraint on its output. The algorithm attempts to resatisfy	 that constraint using some other method. This process is repeated	 until either a) it reaches a variable that was not previously	 determined by any constraint or b) it reaches a constraint that	 is too weak to be satisfied using any of its methods. The variables	 of constraints that have been processed are marked with a unique mark	 value so that we know where we've been. This allows the algorithm to	 avoid getting into an infinite loop even if the constraint graph has	 an inadvertent cycle."	| mark overridden |	mark := self newMark.	overridden := c satisfy: mark.	[overridden == nil] whileFalse:		[overridden := overridden satisfy: mark].! !!PjDbPlanner methodsFor: 'add/remove'!incrementalRemove: c	"Entry point for retracting a constraint. Remove the given constraint,	 which should be satisfied, and incrementally update the dataflow	 graph.	 Details: Retracting the given constraint may allow some currently	 unsatisfiable downstream constraint be satisfied. We thus collect a	 list of unsatisfied downstream constraints and attempt to satisfy	 each one in turn. This list is sorted by constraint strength,	 strongest first, as a heuristic for avoiding unnecessarily adding	 and then overriding weak constraints."	| out unsatisfied |	out := c output.	c markUnsatisfied.	c removeFromGraph.	unsatisfied := self removePropagateFrom: out.	unsatisfied do: [: u | self incrementalAdd: u]! !!PjDbPlanner methodsFor: 'initialization'!initialize	currentMark := 1! !!PjDbPlanner methodsFor: 'planning/value propagation'!makePlan: sources	"Extract a plan for resatisfaction starting from the given satisfied	 source constraints, usually a set of input constraints. This method	 assumes that stay optimization is desired; the plan will contain only	 constraints whose output variables are not stay. Constraints that do	 no computation, such as stay and edit constraints, are not included	 in the plan.	 Details: The outputs of a constraint are marked when it is added to	 the plan under construction. A constraint may be appended to the plan	 when all its input variables are known. A variable is known if either	 a) the variable is marked (indicating that has been computed by a	 constraint appearing earlier in the plan), b) the variable is 'stay'	 (i.e. it is a constant at plan execution time), or c) the variable	 is not determined by any constraint. The last provision is for past	 states of history variables, which are not stay but which are also	 not computed by any constraint."	| mark plan todo c |	mark := self newMark.	plan := PjDbPlan new.	todo := sources.	[todo isEmpty] whileFalse:		[c := todo removeFirst.		 ((c output mark ~= mark) and:		"not in plan already and..."		  [c inputsKnown: mark]) ifTrue:	"eligible for inclusion"			[plan addLast: c.			 c output mark: mark.			 self addConstraintsConsuming: c output to: todo]].	^plan! !!PjDbPlanner methodsFor: 'private'!newMark	"Select a previously unused mark value.	 Details: We just keep incrementing. If necessary, the counter will	 turn into a LargePositiveInteger. In that case, it will be a bit	 slower to compute the next mark but the algorithms will all behave	 correctly. We reserve the value '0' to mean 'unmarked'. Thus, this	 generator starts at '1' and will never produce '0' as a mark value."	^currentMark := currentMark + 1! !!PjDbPlanner methodsFor: 'planning/value propagation'!propagateFrom: v	"The given variable has changed. Propagate new values downstream."	| todo c |	todo := OrderedCollection new.	self addConstraintsConsuming: v to: todo.	[todo isEmpty] whileFalse:		[c := todo removeFirst.		 c execute.		 self addConstraintsConsuming: c output to: todo].! !!PjDbPlanner methodsFor: 'private'!removePropagateFrom: out	"Update the walkabout strengths and stay flags of all variables	 downstream of the given constraint. Answer a collection of unsatisfied	 constraints sorted in order of decreasing strength."	| unsatisfied todo v nextC |	unsatisfied := SortedCollection sortBlock:		[: c1 : c2 | c1 strength stronger: c2 strength].	out determinedBy: nil.	out walkStrength: PjDbStrength absoluteWeakest.	out stay: true.	todo := OrderedCollection with: out.	[todo isEmpty] whileFalse:		[v := todo removeFirst.		 v constraints do:		 	[: c | (c isSatisfied) ifFalse: [unsatisfied add: c]].		 self constraintsConsuming: v do:			[: c |			 c recalculate.			 todo add: c output]].	^unsatisfied! !!PjDbStrength class methodsFor: 'constants'!absoluteStrongest	^AbsoluteStrongest! !!PjDbStrength class methodsFor: 'constants'!absoluteWeakest	^AbsoluteWeakest! !!PjDbStrength class methodsFor: 'class initialization'!initialize	"Initialize the symbolic strength table. Fix the internally caches	 values of all existing instances."	"Strength initialize"	StrengthTable := Dictionary new.	StrengthTable at: #absoluteStrongest put: -10000.	StrengthTable at: #required put: -800.	StrengthTable at: #strongPreferred put: -600.	StrengthTable at: #preferred put: -400.	StrengthTable at: #strongDefault put: -200.	StrengthTable at: #default put: 0.	StrengthTable at: #weakDefault put: 500.	StrengthTable at: #absoluteWeakest put: 10000.	StrengthConstants := Dictionary new.	StrengthTable keys do:		[: strengthSymbol |			StrengthConstants				at: strengthSymbol				put: ((super new) initializeWith: strengthSymbol)].	AbsoluteStrongest := PjDbStrength of: #absoluteStrongest.	AbsoluteWeakest := PjDbStrength of: #absoluteWeakest.	Required := PjDbStrength of: #required.! !!PjDbStrength class methodsFor: 'instance creation'!of: aSymbol	"Answer an instance with the specified strength."	^StrengthConstants at: aSymbol! !!PjDbStrength class methodsFor: 'constants'!required	^Required! !!PjDbStrength methodsFor: 'private'!arithmeticValue	"Answer my arithmetic value. Used for comparisons. Note that	 STRONGER constraints have SMALLER arithmetic values."	^arithmeticValue! !!PjDbStrength methodsFor: 'private'!initializeWith: symVal	"Record my symbolic value and reset my arithmetic value."	symbolicValue := symVal.	arithmeticValue := StrengthTable at: symbolicValue.! !!PjDbStrength methodsFor: 'printing'!printOn: aStream	"Append a string which represents my strength onto aStream."	aStream nextPutAll: '%', symbolicValue, '%'.! !!PjDbStrength methodsFor: 'comparing'!sameAs: aStrength	"Answer true if I am the same strength as the given Strength."	^arithmeticValue = aStrength arithmeticValue! !!PjDbStrength methodsFor: 'comparing'!stronger: aStrength	"Answer true if I am stronger than the given Strength."	^arithmeticValue < aStrength arithmeticValue! !!PjDbStrength methodsFor: 'max/min'!strongest: aStrength	"Answer the stronger of myself and aStrength."	(aStrength stronger: self)		ifTrue: [^aStrength]		ifFalse: [^self].! !!PjDbStrength methodsFor: 'comparing'!weaker: aStrength	"Answer true if I am weaker than the given Strength."	^arithmeticValue > aStrength arithmeticValue! !!PjDbStrength methodsFor: 'max/min'!weakest: aStrength	"Answer the weaker of myself and aStrength."	(aStrength weaker: self)		ifTrue: [^aStrength]		ifFalse: [^self].! !!PjDbVariable class methodsFor: 'instance creation'!value: aValue	^self new value: aValue! !!PjDbVariable methodsFor: 'access'!addConstraint: aConstraint	"Add the given constraint to the set of all constraints that refer	 to me."	constraints add: aConstraint.! !!PjDbVariable methodsFor: 'access'!constraints	"Answer the set of constraints that refer to me."	^constraints! !!PjDbVariable methodsFor: 'access'!determinedBy	"Answer the constraint that determines my value in the current	 dataflow."	^determinedBy! !!PjDbVariable methodsFor: 'access'!determinedBy: aConstraint	"Record that the given constraint determines my value in the current	 data flow."	determinedBy := aConstraint.! !!PjDbVariable methodsFor: 'initialize-release'!initialize	value := 0.	constraints := OrderedCollection new: 2.	determinedBy := nil.	walkStrength := PjDbStrength absoluteWeakest.	stay := true.	mark := 0.! !!PjDbVariable methodsFor: 'printing'!longPrintOn: aStream	self shortPrintOn: aStream.	aStream nextPutAll: '   Constraints: '.	(constraints isEmpty)		ifTrue: [aStream cr; tab; nextPutAll: 'none']		ifFalse:			[constraints do:				[: c | aStream cr; tab. c shortPrintOn: aStream]].	(determinedBy isNil) ifFalse:		[aStream cr; nextPutAll: '   Determined by: '.		 aStream cr; tab. determinedBy shortPrintOn: aStream].	aStream cr.! !!PjDbVariable methodsFor: 'access'!mark	"Answer my mark value."	^mark! !!PjDbVariable methodsFor: 'access'!mark: markValue	"Set my mark value."	mark := markValue.! !!PjDbVariable methodsFor: 'printing'!printOn: aStream	self shortPrintOn: aStream! !!PjDbVariable methodsFor: 'access'!removeConstraint: c	"Remove all traces of c from this variable."	constraints remove: c ifAbsent: [].	(determinedBy == c) ifTrue: [determinedBy := nil].! !!PjDbVariable methodsFor: 'changes'!setValue: aValue	"Attempt to assign the given value to me using a strength of	 #preferred."	self setValue: aValue strength: #preferred.! !!PjDbVariable methodsFor: 'changes'!setValue: aValue strength: strengthSymbol	"Attempt to assign the given value to me using the given strength."	| editConstraint |	editConstraint := PjDbEditConstraint var: self strength: strengthSymbol.	(editConstraint isSatisfied) ifTrue:		[self value: aValue.		 PjDbPlanner propagateFrom: self].	editConstraint destroyConstraint.! !!PjDbVariable methodsFor: 'printing'!shortPrintOn: aStream	aStream nextPutAll: 'V(', self asOop printString, ', '.	aStream nextPutAll: walkStrength printString, ', '.	(stay isNil) ifFalse:		[aStream nextPutAll: (stay ifTrue: ['stay, '] ifFalse: ['changing, '])].	aStream nextPutAll: value printString.	aStream nextPutAll: ')'.	aStream cr.! !!PjDbVariable methodsFor: 'access'!stay	"Answer my stay flag."	^stay! !!PjDbVariable methodsFor: 'access'!stay: aBoolean	"Set my stay flag."	stay := aBoolean! !!PjDbVariable methodsFor: 'access'!value	"Answer my value."	^value! !!PjDbVariable methodsFor: 'access'!value: anObject	"Set my value."	value := anObject.! !!PjDbVariable methodsFor: 'access'!walkStrength	"Answer my walkabout strength in the current dataflow."	^walkStrength! !!PjDbVariable methodsFor: 'access'!walkStrength: aStrength	"Set my walkabout strength in the current dataflow."	walkStrength := aStrength.! !!PjExportBenchmarks class methodsFor: 'benchmarking'!benchAllExport	<script>	self benchExportingNodeTimingApplication.	self benchExportingBrowserTimingApplication ! !!PjExportBenchmarks class methodsFor: 'benchmarking'!benchExporting: appClass	self benchExporting: appClass runsCount: self runsCount! !!PjExportBenchmarks class methodsFor: 'benchmarking'!benchExporting: appClass runsCount: runs	self new benchExporting: appClass runsCount: runs! !!PjExportBenchmarks class methodsFor: 'benchmarking'!benchExportingBrowserTimingApplication	<script>	self benchExporting: PjBrowserTimingApplication ! !!PjExportBenchmarks class methodsFor: 'benchmarking'!benchExportingNodeTimingApplication	<script>	self benchExporting: PjNodeTimingApplication ! !!PjExportBenchmarks class methodsFor: 'benchmarking'!runExporting: appClass	self new runExporting: appClass! !!PjExportBenchmarks class methodsFor: 'benchmarking'!runsCount	^ 100! !!PjExportBenchmarks methodsFor: 'benchmarking'!benchExporting: appClass runsCount: runs	Transcript		cr;		cr;		show: '--- ';		show: appClass;		show: ' export bench at: ';		show: Time now print24;		show: ' - runs: ';		show: runs;		show: '------------'.	runs timesRepeat: [ self runExporting: appClass ]! !!PjExportBenchmarks methodsFor: 'benchmarking'!export: appClass	| exporter |	exporter := PjExporter newWithAppClass: appClass.	^exporter javascriptCode! !!PjExportBenchmarks methodsFor: 'benchmarking'!runExporting: appClass	Smalltalk garbageCollect.	Transcript		  cr;		  show: [ self export: appClass ]		                         timeToRunWithoutGC.! !!PjPharoTimingApplication class methodsFor: 'start-stop application'!start	<script>		Transcript clear.	PjTimingApplication runTimings: self new! !!PjPharoTimingApplication methodsFor: 'accessing'!cr	^Transcript cr! !!PjPharoTimingApplication methodsFor: 'initialization'!initialize	printedIterations := iterations := 1000000! !!PjPharoTimingApplication methodsFor: 'accessing'!iterations	^ iterations! !!PjPharoTimingApplication methodsFor: 'accessing'!log: aString	Transcript show: aString;cr.! !!PjPharoTimingApplication methodsFor: 'accessing'!prefix: aString	prefix := aString! !!PjPharoTimingApplication methodsFor: 'accessing'!runs	^ 10! !!PjPharoTimingApplication methodsFor: 'accessing'!show: aString	Transcript show: aString.! !!PjPharoTimingApplication methodsFor: 'accessing'!time	PjTimingApplication allTimingOn: self! !!PjPharoTimingApplication methodsFor: 'accessing'!time: aString with: aBlock ratio: ratio	| iters |	iters := (iterations * ratio) asInteger.	iters isZero ifTrue: [ iters := 1 ].	printedIterations = iters ifFalse: [		self show: 'Running ';show: iters;show: ' iterations';cr.		printedIterations := iters	].	self		show: prefix;		show: aString;		show: ': ';		show:  (([ iters timesRepeat: aBlock ] timeToRunWithoutGC) printShowingDecimalPlaces: 3);		show: 'ms';		cr! !!PjPharoTimingApplication methodsFor: 'accessing'!warmups	^ 0! !!PjRbBenchmark class methodsFor: 'instance creation'!report: string times: count run: aBlock	<pharoJsSkip>        "Report the time required to execute the given block."        | time |        time := 0.	count timesRepeat: [ time := time + aBlock value ].        Transcript show: string, ' ', (time // count) printString, ' milliseconds'; cr.! !!PjRbBenchmark class methodsFor: 'instance creation'!standardBenchmark	<pharoJsSkip>        "This the combined benchmark."        "PjRbBenchmark standardBenchmark"        self report: 'Richards simulations' times: 100000 run: [ self start ]! !!PjRbBenchmark class methodsFor: 'instance creation'!start    "RichardsBenchmark start"    ^self new start! !!PjRbBenchmark class methodsFor: 'instance creation'!start: trace    "RichardsBenchmark start: true"    ^self new start: trace! !!PjRbBenchmark methodsFor: 'creation'!createDevice: identity priority: priority work: workX state: state     | dataX |    dataX := PjRbDeviceTaskDataRecord create.    self	createTask: identity	priority: priority	work: workX	state: state	function: 	    [:work :word | | data functionWork |	    data := word.	    functionWork := work.	    functionWork isNil		ifTrue:		    [(functionWork := data pending) isNil			ifTrue: [self wait]			ifFalse: 			    [data pending: nil.			    self queuePacket: functionWork]]		ifFalse: 		    [data pending: functionWork.		    tracing			ifTrue: 			    [self trace: functionWork datum].		    self holdSelf]]	data: dataX! !!PjRbBenchmark methodsFor: 'creation'!createHandler: identity priority: priority work: workX state: state     | dataX |    dataX := PjRbHandlerTaskDataRecord create.    self	createTask: identity	priority: priority	work: workX	state: state	function: 	    [:work :word | | data workPacket count devicePacket |	    data := word.	    work isNil		ifFalse: [WorkPacketKind == work kind 		    ifTrue: [data workInAdd: work]		    ifFalse: [data deviceInAdd: work]].	    (workPacket := data workIn) isNil		ifTrue: [self wait]		ifFalse: 		    [count := workPacket datum.		    count > 4			ifTrue: 			    [data workIn: workPacket link.			    self queuePacket: workPacket]			ifFalse:			    [(devicePacket := data deviceIn) isNil				ifTrue: [self wait]				ifFalse: 				    [data deviceIn: devicePacket link.				    devicePacket datum: (workPacket data at: count).				    workPacket datum: count + 1.				    self queuePacket: devicePacket]]]]	data: dataX! !!PjRbBenchmark methodsFor: 'creation'!createIdler: identity priority: priority work: workX state: state     | dataX |    dataX := PjRbIdleTaskDataRecord create.    self	createTask: identity	priority: priority	work: workX	state: state	function: 	    [:work :word | | data |	    data := word.	    data count: data count - 1.	    0 = data count		ifTrue: [self holdSelf]		ifFalse:		    [0 = (data control bitAnd: 1)			ifTrue: 			    [data control: data control // 2.			    self release: DeviceA]			ifFalse: 			    [data control: (data control // 2 bitXor: 53256).			    self release: DeviceB]]]	data: dataX! !!PjRbBenchmark methodsFor: 'creation'!createPacket: link identity: identity kind: kind     ^PjRbPacket	create: link	identity: identity	kind: kind! !!PjRbBenchmark methodsFor: 'creation'!createTask: identity priority: priority work: work state: state function: aBlock data: data     | t |    t := PjRbTaskControlBlock		link: taskList		create: identity		priority: priority		initialWorkQueue: work		initialState: state		function: aBlock		privateData: data.    taskList := t.    taskTable at: identity put: t! !!PjRbBenchmark methodsFor: 'creation'!createWorker: identity priority: priority work: workX state: state     | dataX |    dataX := PjRbWorkerTaskDataRecord create.    self	createTask: identity	priority: priority	work: workX	state: state	function: 	    [:work :word | | data |	    data := word.	    work isNil		ifTrue: [self wait]		ifFalse: 		    [data destination: (HandlerA = data destination			    ifTrue: [HandlerB]			    ifFalse: [HandlerA]).		    work identity: data destination.		    work datum: 1.		    1 to: 4 do: 			[:i | 			data count: data count + 1.			data count > 26 ifTrue: [data count: 1].			work data at: i put: $A asInteger + data count - 1].		    self queuePacket: work]]	data: dataX! !!PjRbBenchmark methodsFor: 'private'!findTask: identity     | t |    t := taskTable at: identity.    t isNil ifTrue: [self error: 'findTask failed'].    ^t! !!PjRbBenchmark methodsFor: 'private'!holdSelf    holdCount := holdCount + 1.    currentTask taskHolding: true.    ^currentTask link! !!PjRbBenchmark methodsFor: 'private'!initScheduler    queuePacketCount := holdCount := 0.    taskTable := Array new: 6.    taskList := nil! !!PjRbBenchmark methodsFor: 'private'!initTrace: trace    tracing := trace.    layout := 0! !!PjRbBenchmark methodsFor: 'private'!queuePacket: packet     | t |    t := self findTask: packet identity.    t isNil ifTrue: [^nil].    queuePacketCount := queuePacketCount + 1.    packet link: nil.    packet identity: currentTaskIdentity.    ^t addInput: packet checkPriority: currentTask! !!PjRbBenchmark methodsFor: 'private'!release: identity     | t |    t := self findTask: identity.    t isNil ifTrue: [^nil].    t taskHolding: false.    t priority > currentTask priority	ifTrue: [^t]	ifFalse: [^currentTask]! !!PjRbBenchmark methodsFor: 'scheduling'!schedule    currentTask := taskList.     [currentTask isNil]	whileFalse: 	    [currentTask isTaskHoldingOrWaiting		ifTrue: [currentTask := currentTask link]		ifFalse: 		    [currentTaskIdentity := currentTask identity.		    tracing ifTrue: [self trace: currentTaskIdentity].		    currentTask := currentTask runTask]]! !!PjRbBenchmark methodsFor: 'initialization'!start    ^self start: false! !!PjRbBenchmark methodsFor: 'initialization'!start: trace    | workQ mark1 mark2 mark3 mark4 |    self initTrace: trace; initScheduler.    mark1 := Time millisecondClockValue.    tracing ifTrue: [self show: 'Bench mark starting'; cr].    self	createIdler: Idler	priority: 0	work: nil	state: PjRbTaskState running.    workQ := self		createPacket: nil		identity: Worker		kind: WorkPacketKind.    workQ := self		createPacket: workQ		identity: Worker		kind: WorkPacketKind.    self	createWorker: Worker	priority: 1000	work: workQ	state: PjRbTaskState waitingWithPacket.    workQ := self		createPacket: nil		identity: DeviceA		kind: DevicePacketKind.    workQ := self		createPacket: workQ		identity: DeviceA		kind: DevicePacketKind.    workQ := self		createPacket: workQ		identity: DeviceA		kind: DevicePacketKind.    self	createHandler: HandlerA	priority: 2000	work: workQ	state: PjRbTaskState waitingWithPacket.    workQ := self		createPacket: nil		identity: DeviceB		kind: DevicePacketKind.    workQ := self		createPacket: workQ		identity: DeviceB		kind: DevicePacketKind.    workQ := self		createPacket: workQ		identity: DeviceB		kind: DevicePacketKind.    self	createHandler: HandlerB	priority: 3000	work: workQ	state: PjRbTaskState waitingWithPacket.    self	createDevice: DeviceA	priority: 4000	work: nil	state: PjRbTaskState waiting.    self	createDevice: DeviceB	priority: 5000	work: nil	state: PjRbTaskState waiting.    tracing ifTrue: [self show: 'Starting'; cr].    mark2 := Time millisecondClockValue.    self schedule.    mark3 := Time millisecondClockValue.    tracing	ifTrue: 	    [self show: 'Finished'; cr.	    self show: 'QueuePacket count = ', queuePacketCount printString;		show: ' HoldCount = ', holdCount printString;		cr.	    self cr; show: 'End of run'; cr].    queuePacketCount = 23246 & (holdCount = 9297) ifFalse: [self error: 'wrong result'].    mark4 := Time millisecondClockValue.    tracing	ifTrue:	    [self show: '***Scheduler time = ', (mark3 - mark2) printString;	        show: ' Total time = ', (mark4 - mark1) printString;	        cr].  ^mark4 - mark1! !!PjRbBenchmark methodsFor: 'private'!trace: id     layout := layout - 1.    0 >= layout	ifTrue: 	    [self cr.	    layout := 50].    self show: id printString! !!PjRbBenchmark methodsFor: 'private'!wait     currentTask taskWaiting: true.    ^currentTask! !!PjRbDeviceTaskDataRecord class methodsFor: 'instance creation'!create    ^super new create! !!PjRbDeviceTaskDataRecord methodsFor: 'initialization'!create    pending := nil! !!PjRbDeviceTaskDataRecord methodsFor: 'accessing'!pending    ^pending! !!PjRbDeviceTaskDataRecord methodsFor: 'accessing'!pending: packet     pending := packet! !!PjRbHandlerTaskDataRecord class methodsFor: 'instance creation'!create    ^super new create! !!PjRbHandlerTaskDataRecord methodsFor: 'initialization'!create    workIn := deviceIn := nil! !!PjRbHandlerTaskDataRecord methodsFor: 'accessing'!deviceIn    ^deviceIn! !!PjRbHandlerTaskDataRecord methodsFor: 'accessing'!deviceIn: aPacket    deviceIn := aPacket! !!PjRbHandlerTaskDataRecord methodsFor: 'accessing'!deviceInAdd: packet    deviceIn := self append: packet head: deviceIn! !!PjRbHandlerTaskDataRecord methodsFor: 'accessing'!workIn    ^workIn! !!PjRbHandlerTaskDataRecord methodsFor: 'accessing'!workIn: aWorkQueue     workIn := aWorkQueue! !!PjRbHandlerTaskDataRecord methodsFor: 'accessing'!workInAdd: packet    workIn := self append: packet head: workIn! !!PjRbIdleTaskDataRecord class methodsFor: 'instance creation'!create    ^super new create! !!PjRbIdleTaskDataRecord methodsFor: 'accessing'!control    ^control! !!PjRbIdleTaskDataRecord methodsFor: 'accessing'!control: aNumber    control := aNumber! !!PjRbIdleTaskDataRecord methodsFor: 'accessing'!count    ^count! !!PjRbIdleTaskDataRecord methodsFor: 'accessing'!count: aCount    count := aCount! !!PjRbIdleTaskDataRecord methodsFor: 'initialization'!create    control := 1.    count := 10000! !!PjRbObject class methodsFor: 'class initialization'!initialize       DeviceA := 5.    DeviceB := 6.    DevicePacketKind := 1.    HandlerA := 3.    HandlerB := 4.    Idler := 1.    Worker := 2.    WorkPacketKind := 2! !!PjRbObject class methodsFor: 'transcript'!show_jsGenerator: transpiler	<pharoJsSkip>		^'console.log(aString.', transpiler pharoJsSelectorPrefix, 'asString())'! !!PjRbObject methodsFor: 'utilities'!append: packet head: queueHead    | mouse link |    packet link: nil.    queueHead isNil ifTrue: [^packet].    mouse := queueHead.    [(link := mouse link) isNil]	whileFalse: [mouse := link].    mouse link: packet.    ^queueHead! !!PjRbObject methodsFor: 'transcript'!cr	<javascript: ''>	Transcript cr! !!PjRbObject methodsFor: 'transcript'!show: aString	<jsGenerator: #show_jsGenerator:>	Transcript show: aString! !!PjRbPacket class methodsFor: 'instance creation'!create: link identity: identity kind: kind     ^super new	link: link	identity: identity	kind: kind! !!PjRbPacket methodsFor: 'accessing'!data    ^data! !!PjRbPacket methodsFor: 'accessing'!datum    ^datum! !!PjRbPacket methodsFor: 'accessing'!datum:    someData    datum := someData! !!PjRbPacket methodsFor: 'accessing'!identity    ^identity! !!PjRbPacket methodsFor: 'accessing'!identity: anIdentity    identity := anIdentity! !!PjRbPacket methodsFor: 'accessing'!kind    ^kind! !!PjRbPacket methodsFor: 'accessing'!link    ^link! !!PjRbPacket methodsFor: 'accessing'!link: aWorkQueue     link := aWorkQueue! !!PjRbPacket methodsFor: 'initialization'!link: aLink identity: anIdentity kind: aKind     link := aLink.    identity := anIdentity.     kind := aKind.    datum := 1.    data := ByteArray new: 4! !!PjRbTaskControlBlock class methodsFor: 'instance creation'!link: link create: identity priority: priority initialWorkQueue: initialWorkQueue initialState: initialState function: aBlock privateData: privateData     ^super new	link: link	identity: identity	priority: priority	initialWorkQueue: initialWorkQueue	initialState: initialState	function: aBlock	privateData: privateData! !!PjRbTaskControlBlock methodsFor: 'scheduling'!addInput: packet checkPriority: oldTask    input isNil	ifTrue: 	    [input := packet.	    packetPendingIV := true.	    priority > oldTask priority ifTrue: [^self]]	ifFalse: 	    [input := self append: packet head: input].    ^oldTask! !!PjRbTaskControlBlock methodsFor: 'accessing'!identity    ^identity! !!PjRbTaskControlBlock methodsFor: 'accessing'!link    ^link! !!PjRbTaskControlBlock methodsFor: 'initialization'!link: aLink identity: anIdentity priority: aPriority initialWorkQueue: anInitialWorkQueue initialState: anInitialState function: aBlock privateData: aPrivateData     link := aLink.    identity := anIdentity.    priority := aPriority.    input := anInitialWorkQueue.    packetPendingIV := anInitialState isPacketPending.    taskWaiting := anInitialState isTaskWaiting.    taskHolding := anInitialState isTaskHolding.    function := aBlock.    handle := aPrivateData! !!PjRbTaskControlBlock methodsFor: 'accessing'!priority    ^priority! !!PjRbTaskControlBlock methodsFor: 'scheduling'!runTask    | message |    self isWaitingWithPacket	ifTrue: 	    [message := input.	    input := message link.	    input isNil		ifTrue: [self running]		ifFalse: [self packetPending]]	ifFalse: [message := nil].    ^function value: message value: handle! !!PjRbTaskState class methodsFor: 'instance creation'!packetPending    ^super new packetPending! !!PjRbTaskState class methodsFor: 'instance creation'!running    ^super new running! !!PjRbTaskState class methodsFor: 'instance creation'!waiting    ^super new waiting! !!PjRbTaskState class methodsFor: 'instance creation'!waitingWithPacket    ^super new waitingWithPacket! !!PjRbTaskState methodsFor: 'accessing'!isPacketPending    ^packetPendingIV! !!PjRbTaskState methodsFor: 'testing'!isRunning    ^packetPendingIV not and: [taskWaiting not and: [taskHolding not]]! !!PjRbTaskState methodsFor: 'accessing'!isTaskHolding    ^taskHolding! !!PjRbTaskState methodsFor: 'testing'!isTaskHoldingOrWaiting    ^taskHolding or: [packetPendingIV not and: [taskWaiting]]! !!PjRbTaskState methodsFor: 'accessing'!isTaskWaiting    ^taskWaiting! !!PjRbTaskState methodsFor: 'testing'!isWaiting    ^packetPendingIV not and: [taskWaiting and: [taskHolding not]]! !!PjRbTaskState methodsFor: 'testing'!isWaitingWithPacket    ^packetPendingIV and: [taskWaiting and: [taskHolding not]]! !!PjRbTaskState methodsFor: 'initialization'!packetPending    packetPendingIV := true.    taskWaiting := false.    taskHolding := false! !!PjRbTaskState methodsFor: 'initialization'!running    packetPendingIV := taskWaiting := taskHolding := false! !!PjRbTaskState methodsFor: 'accessing'!taskHolding: aBoolean    taskHolding := aBoolean! !!PjRbTaskState methodsFor: 'accessing'!taskWaiting: aBoolean     taskWaiting := aBoolean! !!PjRbTaskState methodsFor: 'initialization'!waiting    packetPendingIV := taskHolding := false.    taskWaiting := true! !!PjRbTaskState methodsFor: 'initialization'!waitingWithPacket    taskHolding := false.    taskWaiting := packetPendingIV := true! !!PjRbWorkerTaskDataRecord class methodsFor: 'instance creation'!create    ^super new create! !!PjRbWorkerTaskDataRecord methodsFor: 'accessing'!count    ^count! !!PjRbWorkerTaskDataRecord methodsFor: 'accessing'!count: aCount    count := aCount! !!PjRbWorkerTaskDataRecord methodsFor: 'initialization'!create    destination := HandlerA.    count := 0! !!PjRbWorkerTaskDataRecord methodsFor: 'accessing'!destination    ^destination! !!PjRbWorkerTaskDataRecord methodsFor: 'accessing'!destination: aHandler    destination := aHandler! !!PjTimingApplication class methodsFor: 'timings'!allTimingOn: timer	| x y instance |	x := 0.	y := 1.	instance := self new.	self on: timer time: 'empty' with: [ ].	self on: timer time: 'add-1' with: [ x := x + 1 ].	self on: timer time: 'add-y' with: [ x := x + y ].	self on: timer time: 'add-expr' with: [ x := x + instance one ].	self on: timer time: 'fieldSetI' with: [ y := instance index: 3 ].	self on: timer time: 'fieldSetV' with: [ y := instance instVarNamed: #index put: 3].	self on: timer time: 'fieldGetI' with: [ y := instance index ].	self on: timer time: 'fieldGetV' with: [ y := instance instVarNamed: #index ].	self on: timer time: 'message' with: [ instance ten ].	self on: timer time: 'cond-return' with: [ instance conditionalReturn ].	self on: timer time: 'nonlocal' with: [ instance nonlocalReturn ].	self on: timer time: 'nonlocal-block' with: [ instance nonlocalReturn2 ].	self on: timer time: 'repeatLoop' with: [ instance repeatLoop ].	self on: timer time: 'toDoLoop' with: [ instance toDoLoop ].	self on: timer time: 'whileLoop' with: [ instance whileLoop ].	self on: timer time: 'unoptLoop' with: [ instance whileRemoteLoop ].	self on: timer time: 'DeltaBlue' with: [		PjDbPlanner chainTest: 100. 		PjDbPlanner projectionTest: 100	] ratio: 0.0003.	self on: timer time: 'Richards' with: [ PjRbBenchmark start ] ratio: 0.00005! !!PjTimingApplication class methodsFor: 'timings'!browserTimingOn: timer	self on: timer time: 'docBody' with: [ document body ].! !!PjTimingApplication class methodsFor: 'timings'!jsTimingOn: timer top: top	| x y |	x := self makeObject.	y := 0.	self on: timer time: 'fieldSet' with: [ x index: 1 ].	self on: timer time: 'fieldSetN' with: [ x js_at: #index put: 1 ].	self on: timer time: 'fieldSetX' with: [ x instVarNamed:#index put: 1 ].	self on: timer time: 'fieldGet' with: [ y := x index ].	self on: timer time: 'fieldGetN' with: [ y := x js_at: #index ].	self on: timer time: 'fieldGetX' with: [ y := x instVarNamed:#index ]! !!PjTimingApplication class methodsFor: 'js support'!makeObject	"just here so we can create it the PharoJS and the Amber way"	<javascript:	'var x={};x.index=42;return x'>	<amberJSCode:	'var x={};x.index=42;return $globals.JSObjectProxy._on_(x)'>! !!PjTimingApplication class methodsFor: 'timings'!nodeTimingOn: timer! !!PjTimingApplication class methodsFor: 'running'!on: aTimingApp time: desc with: block	self on: aTimingApp time: desc with: block ratio: 1! !!PjTimingApplication class methodsFor: 'running'!on: aTimingApp time: desc with: block ratio: ratio	aTimingApp prefix: '(warmup)'.	aTimingApp warmups timesRepeat: [ aTimingApp time: desc with: block ratio: ratio ].	aTimingApp prefix: ''.	aTimingApp runs timesRepeat: [ aTimingApp time: desc with: block ratio: ratio ]! !!PjTimingApplication class methodsFor: 'running'!runTimings: aTimingApp	aTimingApp log: 'Running ', aTimingApp iterations asString,' iterations'.	aTimingApp time.	aTimingApp log: 'Done'! !!PjTimingApplication methodsFor: 'cases'!conditionalReturn	self ten > 5 ifTrue: [ ^ #yes ].	^ #no! !!PjTimingApplication methodsFor: 'cases'!conditionalReturn2: aBlock	self ten > 5 ifTrue: aBlock.	^ #no! !!PjTimingApplication methodsFor: 'cases'!conditionalReturn: aBlock	self ten > 5 ifTrue: [aBlock value].	^ #no! !!PjTimingApplication methodsFor: 'cases'!index	^ index! !!PjTimingApplication methodsFor: 'cases'!index: anInteger	index := anInteger! !!PjTimingApplication methodsFor: 'cases'!nonlocalReturn	self conditionalReturn: [ ^ #yes ].	^ #no! !!PjTimingApplication methodsFor: 'cases'!nonlocalReturn2	self conditionalReturn2: [ ^ #yes ].	^ #no! !!PjTimingApplication methodsFor: 'cases'!one	^ 1! !!PjTimingApplication methodsFor: 'cases'!repeatLoop	| x |	x := 0.	10 timesRepeat: [ x := x + 1 ].	^ x! !!PjTimingApplication methodsFor: 'cases'!ten	^ 7500! !!PjTimingApplication methodsFor: 'cases'!toDoLoop	| x |	x := 0.	1 to: 10 do: [ : y | x := x + y ].	^ x! !!PjTimingApplication methodsFor: 'cases'!whileLoop	| x y |	x := y := 0.	[ y < 10 ] whileTrue: [ y := y + 1. x := x + y ].	^ x! !!PjTimingApplication methodsFor: 'cases'!whileRemoteLoop	| x y b1 b2 |	x := y := 0.	b1 := [ y < 10 ].	b2 := [ y := y + 1. x := x + y ].	b1 whileTrue: b2.	^ x! !!PjTimingTest class methodsFor: 'stats'!gatherStatistics	<script>"	self gatherStatistics "	self runTests.	self stats inspect.! !!PjTimingTest class methodsFor: 'initialize-release'!initialize	self reset! !!PjTimingTest class methodsFor: 'testing'!ratio: aString  betterThan: factor for:  aTest	| averages ratio unopt opt base |	averages :=  (((((aString allButFirst: 2)		allButLast: 2)			splitOn: '],[') collect: [ : each |				($, split: each) collect: #asUnsignedInteger ])					collect: #average)						collect: #asFloat.	base := averages first.	opt := averages third.	base * 2 > opt ifTrue: [ base:=0 ].	opt := opt - base.	unopt := averages second - base.	opt > 0 ifFalse: [ ^ aTest fail: 'optimized version inadequate time - rerun test' ].	ratio := unopt / opt.	(stats at: aTest selector ifAbsentPut: [ OrderedCollection new ]) add: ratio.	^ ratio >= factor! !!PjTimingTest class methodsFor: 'initialize-release'!reset	stats := Dictionary new.! !!PjTimingTest class methodsFor: 'stats'!runTests	| instance |	self testSelectors do: [: testName |		instance := self new.		instance selector: testName.		[			instance setUp.			instance perform: testName asSymbol.		] ensure: [[				instance tearDown			] on: Error do: [  ]		]	]! !!PjTimingTest class methodsFor: 'stats'!stats	" self stats  "	^ String streamContents: [ : aStream |		aStream nextPutAll: 'Ratio of unopt/optimized runs';cr.		stats keys sorted do: [ : key |			aStream nextPutAll: (key padRightTo: 30).			(stats at: key) do: [ : each |				aStream nextPutAll: (each printShowingDecimalPlaces: 2);nextPut: $ 			].			aStream cr		]	]! !!PjTimingTest class methodsFor: 'stats'!testSelectors	^(self selectors select: [ :each | (each beginsWith: 'test') and: [each numArgs isZero]])! !!PjTimingTest methodsFor: 'testing support'!assert: aBlock isFasterThan: bBlock with: someOptimizations	| noOptim optim results |	exporter ifNil: [self assert: false description: 'no bridge available'].	self transpiler delayDNU: true.	self transpiler removeAllConversions: someOptimizations.	noOptim := self transpiler convertToJs: bBlock.	self transpiler addAllConversions: someOptimizations.	optim := self transpiler convertToJs: aBlock.	self transpiler delayDNU: false.	results := bridge evalMessage: (PjJavascriptMessage receiverId: #PjTimingPlatformApp selector: #timeNull:nonOptimized:optimized: arguments:  {		PjUnparsedStringNode string: nullBlock.		PjUnparsedStringNode string: noOptim.		PjUnparsedStringNode string: optim }) ."	results := bridge evalJavascript: 'global.PjTimingPlatformApp.', transpiler pharoJsSelectorPrefix, 'timeNull_nonOptimized_optimized_(', nullBlock,',', noOptim,',', optim,')'."	self assert: (self class ratio: results betterThan:  1.2 for: self)! !!PjTimingTest methodsFor: 'testing support'!assert: aBlock isFasterWith: someOptimizations	self assert: aBlock isFasterThan: aBlock with: someOptimizations! !!PjTimingTest methodsFor: 'accessing'!selector	^ selector! !!PjTimingTest methodsFor: 'accessing'!selector: anObject	selector := anObject! !!PjTimingTest methodsFor: 'running'!setUp	bridge := PjBridge new."	bridge withClientLogging."	bridge client openBrowserInBackground: true.	self inform: 'Timing web browser should open in background'.	World doOneCycle;doOneCycle.	bridge initializeWithAppClass: PjTimingPlatformApp.	bridge timeout: 60 seconds.	exporter := bridge exporter.	exporter transpiler: PjTimingTestTranspiler new.	exporter setUpForPolyfill.	self transpiler addAllOptionalConversions.	self transpiler removeAllConversions: { PjIfFalseOptimization }.	self transpiler addAllConversions: { PjIfTrueOptimization }.	nullBlock := self transpiler convertToJs: [  ].	bridge start.	PjBridge soleBridge: bridge.! !!PjTimingTest methodsFor: 'running'!tearDown	bridge stop.! !!PjTimingTest methodsFor: 'testing'!testArithmeticOperators	self assert: [ 1-2 ] isFasterWith: PjArithmeticOptimization allSubclasses! !!PjTimingTest methodsFor: 'testing'!testComparisonOperators	self assert: [ 1<2 ] isFasterWith: PjComparisonOptimization allSubclasses! !!PjTimingTest methodsFor: 'testing'!testIfThen	self with: [ | w | w := 1 ] do: [		self			assert: [ | w | w := 1. w<2 ifTrue: [ w := 0]]			isFasterWith: PjIfTrueIfFalseOptimization withAllSubclasses,							PjComparisonOptimization allSubclasses	]! !!PjTimingTest methodsFor: 'testing'!testNonlocalReturns	bridge timeout: 150 seconds.	self		assert: [ PjTimingPlatformApp ifTrueExample: 15 ]		isFasterThan: [ PjTimingPlatformApp ifFalseExample: 15 ]		with: #()! !!PjTimingTest methodsFor: 'testing'!testTimesRepeat	self with: [ | w | w := 0 . nil] do: [		self			assert: [ | w | 10 timesRepeat: [ w := 0]]			isFasterWith: PjTimesRepeatOptimization withAllSubclasses	]! !!PjTimingTest methodsFor: 'testing'!testToDo	self with: [ | w | w := 10. w := 0 . nil] do: [		self			assert: [ | w | w := 10. 1 to: w do: [ :x| w := x]]			isFasterWith: PjToDoOptimization withAllSubclasses	]! !!PjTimingTest methodsFor: 'testing'!testWhile	self with: [ | w x | x := 10. x := x - 1. w := 0. nil ] do: [		self			assert: [ | w x | x := 10. [x>0] whileTrue: [ x := x - 1. w := 0]]			isFasterWith: PjWhileOptimization allSubclasses	]! !!PjTimingTest methodsFor: 'accessing'!transpiler	^ exporter transpiler! !!PjTimingTest methodsFor: 'testing support'!with: nBlock do: tBlock	| saveBlock |	saveBlock := nullBlock.	[		nullBlock := self transpiler convertToJs: nBlock.		tBlock value	] ensure: [ nullBlock := saveBlock ]! !"PharoJs-Benchmarking"!!PjStatistics commentStamp: '' prior: 0!Displays statistics of classes converted from Pharo to JS on the Transcript.ExamplesTranscript clear.PjStatistics statsForApp: PjCounterBrowserApp .PjStatistics statsForAll: { PjHelloWorldApp. PjMinimalBrowserApplication}!!PjStatistics class methodsFor: 'examples'!example1	Transcript		open;		clear.	self statsForApp: PjCounterBrowserApp! !!PjStatistics class methodsFor: 'examples'!example2	Transcript		open;		clear.	self statsForAll: { 			PjHelloWorldApp.			PjMinimalWebApplication }! !!PjStatistics class methodsFor: 'statistics'!statsForAll: appClasses	appClasses do: [ : cl | self statsForApp: cl ]! !!PjStatistics class methodsFor: 'statistics'!statsForApp: appClass	| exporter actuallyExportedClasses methodsCount jsCode |	exporter := appClass exporterClass newWithAppClass: appClass.	jsCode := String streamContents: [ :stream | exporter writeJsCodeOn: stream ].	actuallyExportedClasses := exporter bootstrapClasses asSet		, exporter nonBootstrapClasses asSet collect: #classToUseForJsConversion.	methodsCount := actuallyExportedClasses		inject: 0		into: [ :count :cl | count + cl selectors size ].	Transcript 		cr;		show: '----------------';		cr;		show: appClass name;		show: ' - ';		show: Date today;		show: ' - ';		show: Time now print24;		cr;		cr;		show: 'Classes: ';		show: actuallyExportedClasses size;		cr;		show: 'Methods: ';		show: methodsCount;		cr;		show: 'Exported JS: ';		show: jsCode size humanReadableSIByteSize;		cr;		show: '----------------'! !"PharoJs-Utilities-Statistics"!!PharoJSTutorial commentStamp: '' prior: 0!I am a tutorial for some of the elements of PharoJS!!PharoJsHelp commentStamp: '' prior: 0!Hierarchical help for PharoJS!!PharoJsHelpApplication commentStamp: '' prior: 0!Help pages to describe Applications with PharoJS!!PjProxy methodsFor: '*PharoJs-Tools-Inspector'!asProxyInfo	| pi |	pi := PjProxyInfo new.	pi oid: self oid.	pi globalName: jsName.	^ pi! !!PjProxy methodsFor: '*PharoJs-Tools-Inspector'!gefFieldValueFor: key	^ self jsBridge: [ :bridge | 		  bridge evalJavascript: jsName , '.' , key ]! !!PjProxy methodsFor: '*PharoJs-Tools-Inspector'!gtInspectorProxyIn: composite	<gtInspectorPresentationOrder: 1>		| associations |	associations := OrderedCollection new.	self keysForProxy associationsDo: [ :assoc | associations add: assoc ].	^ composite table		  title: 'Javascript';		  display: [ :each | associations ];		  column: 'Key' evaluated: #key;		  column: 'Value' evaluated: #value;		  send: #value! !!PjProxy methodsFor: '*PharoJs-Tools-Inspector'!keysForProxy	^ self jsBridge: [ :bridge | 		  [ 		  | msg |		  msg := PjMessageGetKeys newWithId.		  msg proxyInfo: self asProxyInfo.		  bridge sendMessageAndWaitForResponse: msg ]			  on: Error			  do: [ ^ #(  ) ] ]! !!PjMinimalWebApplication class methodsFor: '*PharoJs-Tools'!writePlaygroundContentsOn: str	<pharoJsSkip>	super writePlaygroundContentsOn: str.	str		<< '"Sample code:"';		cr;		<< 'console dir: document.';		cr;		<< 'document fonts. " inspect this "';		cr;		<< 'document body style backgroundColor: ''#fee''.';		cr! !!PjApplication class methodsFor: '*PharoJs-Tools'!classSubclassResponsibilitySet	| set |	set := self == PjApplication ifTrue: [ Set new ] ifFalse: [ self superclass classSubclassResponsibilitySet ].	self class methods do: [:cm | | selector |		selector := cm selector.		(cm sendsSelector: #subclassResponsibility) ifTrue: [				set add: selector			] ifFalse: [				set remove: selector ifAbsent: [ ]			]]..	^ set! !!PjApplication class methodsFor: '*PharoJs-Tools'!isAbstract	^ self subclassResponsibilitySet isNotEmpty or: [			self classSubclassResponsibilitySet isNotEmpty		]! !!PjApplication class methodsFor: '*PharoJs-Tools'!playground	<pharoJsSkip>	^ self bridge playground! !!PjApplication class methodsFor: '*PharoJs-Tools'!subclassResponsibilitySet	| set |	set := self == PjApplication ifTrue: [ Set new ] ifFalse: [ self superclass subclassResponsibilitySet ].	self methods do: [:cm | | selector |		selector := cm selector.		(cm sendsSelector: #subclassResponsibility) ifTrue: [				set add: selector			] ifFalse: [				set remove: selector ifAbsent: [ ]			]]..	^ set! !!PjApplication class methodsFor: '*PharoJs-Tools'!title	<pharoJsSkip>	^ self name! !!PjApplication class methodsFor: '*PharoJs-Tools'!writePlaygroundContentsOn: str	<pharoJsSkip>	str		<< $"		<<			'PharoJS playground preset bindings including the bridge and JS globals.';		cr;		<< 'You can find them all in the bindings menu above.';		<< $";		cr;		cr! !!StPlaygroundPagePresenter methodsFor: '*PharoJs-Tools'!addBinding: aVariable	"Used by PharoJS Playground to add instances of WorkspaceVariable "	text addBinding: aVariable! !!PjBridge methodsFor: '*PharoJs-Tools'!playground	^ PjPlayground openFor: self! !!PjBridge methodsFor: '*PharoJs-Tools'!writePlaygroundContentsOn: str	str		<< $";		<<			'Connection established with Javascript via PharoJS bridge listening on port ';		print: self port;		<< $.;		<< $";		cr;		cr.	self client writePlaygroundContentsOn: str! !!PjProxyField class methodsFor: 'creating'!proxy: aPjProxy key: aString	^ self new		proxy: aPjProxy key: aString;		yourself! !!PjProxyField methodsFor: 'initialization'!proxy: aPjProxy key: aString	proxy := aPjProxy.	key := aString.	value := self! !!PjProxyField methodsFor: 'accessing'!value	value == self ifFalse: [ ^ value ].	value := proxy gefFieldValueFor: key.	proxy := nil.	^ value! !!PjMinimalFileBasedWebApp class methodsFor: '*PharoJs-Tools'!writePlaygroundContentsOn: str	<pharoJsSkip>	super writePlaygroundContentsOn: str.	str		<< '"Sample code:"';		cr;		<< 'console dir: document.';		cr;		<< 'document fonts. " inspect this "';		cr;		<< 'document body style backgroundColor: ''#fee''.';		cr! !!PharoJSTutorial methodsFor: 'lessons'!pjPlayground	^ Lesson		title: 'PharoJS Playground'		lesson:'"The Playground lets you explore the browser side of an app.You can access it from the world menu or do the following:"	PjPlayground popUpMenu'! !!PharoJSTutorial methodsFor: 'lessons'!pjUseHelp	^ Lesson		title: 'Use PharoJS Help instead'		lesson:'"It is very hard to do a tutorial, as most of the interactions are only available inside a PharoJS Playground.So all the information is currently in the Help menu available from the World menu, or doing the following:"	HelpBrowser openOn: PharoJsHelp'! !!PharoJSTutorial methodsFor: 'tutorial'!tutorial	^ #(	pjUseHelp	pjPlayground	)! !!PjBridgeClient methodsFor: '*PharoJs-Tools'!writePlaygroundContentsOn: str	^ self appClass writePlaygroundContentsOn: str! !!PjPlayground class methodsFor: 'world menu'!applicationList	^ (PjApplication allSubclasses select: [ :class |				class isAbstract not and: [ (class hasClassMethod: #playgroundDoNotList) not ]		]) sort: [ : l : r | l name <= r name ]! !!PjPlayground class methodsFor: 'accessing'!defaultTitle	^ 'PharoJS Playground'! !!PjPlayground class methodsFor: 'initialization'!initialize	SystemAnnouncer uniqueInstance		unsubscribe: self;		when: ClassAnnouncement do: [ 			self resetMenuBar ]! !!PjPlayground class methodsFor: 'opening'!open	| playground |	playground := self new.	playground open.	^ playground! !!PjPlayground class methodsFor: 'opening'!openFor: aPjBridge	| playground |	playground := self open.	playground initializeWithBridge: aPjBridge.	^ playground! !!PjPlayground class methodsFor: 'world menu'!pharoJsMenuOn: aBuilder	<worldMenu>	(aBuilder item: #PharoJsPlayground)		order: 40;		label: 'PharoJS';		icon: (self iconNamed: #smallWindowIcon);		with: [ 			self applicationList do: [ :class | 					| n |					n := class name.					(aBuilder item: n asSymbol)						label: n;						with: [ 							(aBuilder item: (n , ':js') asSymbol)								label: 'playground';								action: [ class playground ].							(aBuilder item: (n , ':browse') asSymbol)								label: 'export app';								action: [ class exportApp ].							(aBuilder item: (n , ':browse') asSymbol)								label: 'browse';								action: [ class browse ] ] ].			(aBuilder item: #HelpPharoJs)				label: 'PharoJS Help';				icon: (self iconNamed: #smallHelp);				action: [ HelpBrowser openOn: PharoJsHelp ] ]! !!PjPlayground class methodsFor: 'world menu'!resetMenuBar	<script>	MenubarMorph reset! !!PjPlayground methodsFor: 'accessing'!addBinding: anAssociation	self firstPage addBinding: anAssociation! !!PjPlayground methodsFor: 'initialization'!addWorkspaceVariableNamed: jsGlobalName value: jsGlobal	^ self addBinding:		  (WorkspaceVariable key: jsGlobalName value: jsGlobal)! !!PjPlayground methodsFor: 'accessing'!bridge	^bridge! !!PjPlayground methodsFor: 'accessing'!bridge: aBridge	bridge := aBridge 	! !!PjPlayground methodsFor: 'initialization'!displayWaitingForConnectionMessageForDuration: aDuration	| waitDescription |	waitDescription := String streamContents: [ :str | 		                   str			                   << $";			                   cr;			                   << 'PharoJS bridge server listening on: ';			                   print: bridge serverUrl;			                   cr;			                   << 'Waiting for client connection for ';			                   print: aDuration seconds;			<< ' seconds';			                   cr;			                   << $" ].	self contents: waitDescription! !!PjPlayground methodsFor: 'initialization'!initBindings	| jsGlobal |	self addWorkspaceVariableNamed: #bridge value: bridge.	bridge client jsGlobalNames do: [ :jsGlobalName | 		jsGlobal := PjProxy proxyNamed: jsGlobalName onBridge: bridge.		self addWorkspaceVariableNamed: jsGlobalName value: jsGlobal ]! !!PjPlayground methodsFor: 'initialization'!initTitleWithBridge	| newTitle |	newTitle := String streamContents: [ : ws |		ws << self class defaultTitle;		<< ' - ';		<< bridge clientTitle	].	self title: newTitle! !!PjPlayground methodsFor: 'initialization'!initialContents	^ String streamContents: [ :str | 		  self writePlaygroundContentsOn: str ]! !!PjPlayground methodsFor: 'initialization'!initializeWindow: aWindowPresenter	super initializeWindow: aWindowPresenter.	aWindowPresenter whenClosedDo: [ bridge stop ]! !!PjPlayground methodsFor: 'initialization'!initializeWithBridge: aPjBridge	bridge := aPjBridge.	bridge startWithoutWaitingForClient.	self initTitleWithBridge.	self waitForClientToStart.	self initBindings.	self contents: self initialContents! !!PjPlayground methodsFor: 'accessing'!title		self hasWindow ifFalse: [ ^nil ].	^ self window title! !!PjPlayground methodsFor: 'accessing'!title: aString	self window title: aString! !!PjPlayground methodsFor: 'initialization'!waitForClientToStart	| waitTime endTime |	waitTime := 60 seconds.	endTime := DateAndTime now + waitTime.	bridge waitForClientToStartFor: waitTime doing: [ 		self displayWaitingForConnectionMessageForDuration:			endTime - DateAndTime now.		World doOneCycle ].! !!PjPlayground methodsFor: 'writing'!writePlaygroundContentsOn: aWriteStream 	self bridge writePlaygroundContentsOn: aWriteStream ! !!PjMinimalNodeApplication class methodsFor: '*PharoJs-Tools'!writePlaygroundContentsOn: str	<pharoJsSkip>	super writePlaygroundContentsOn: str.	str		<< '"Sample code:"';		cr;		<< 'console log: ''hello''.';		cr;		<< 'global. " inspect this "';		cr! !!PharoJsHelp class methodsFor: 'accessing'!bookName	^'PharoJS'! !!PharoJsHelp class methodsFor: 'accessing'!key	^ self name! !!PharoJsHelp class methodsFor: 'accessing'!pages	^ (self class methods collect: #selector thenSelect: [ : s | s beginsWith: #topic ]) sort,		(self subclasses collect: #name)! !!PharoJsHelp class methodsFor: 'documentation'!topic0Overview	"This method was automatically generated."	<script: 'self edit: #topic0Overview'>	^HelpTopic		title: 'Introduction'		contents: 'PharoJS allows you to develop code for the web - from the comfort of your Pharo environment.PharoJS can support this several ways:1) PharoJS can export an application to a file ready to be deployed2) PharoJS can interactively run an application in a browser with interaction via a PharoJS playground3) PharoJS can run an application within Pharo that interacts directly with the object in a Javascript engine (web browser of Node)!!' readStream nextChunkText! !!PharoJsHelp class methodsFor: 'documentation'!topicPjInspector	<script: 'self edit: #topicPjInspector'>	^ HelpTopic		title: 'Inspector'		contents:'The Inspector understands PjProxy values and communicates with therelevant Javascript engine (browser or NodeJS) to examine programmatic values.For example by selecting and Cmd-I the following:	document fontsyou would get an inspector showing all the fields of the object-- if document were defined in this scope, which it''s not.However this works fine in a PharoJS Playground, or inmethods of a class that specify the poolDictionary PjDomGlobals'! !!PharoJsHelp class methodsFor: 'documentation'!topicPjPlayground	<script: 'self edit: #topicPjPlayground'>	^ HelpTopic		title: 'Playground'		contents:'The PharoJS Playground lets you explore the browser side of an app.Access the PharoJS Playground from the world menu which will allow you to launch a playground for any app that you have in the image.You can launch the app on Pharo, which means that all of your Pharo Smalltalk code will run in the Pharo image, but you can access the DOM, Javascript libraries, and other Javascript values via proxies visible as globals in the playground.You can also launch the app on the Javascript engine (Web browser or Node). In this case, the code is all translated to Javascript and installed in the JSE.  In addition to the proxies mentioned above, the application and other installed classes running on the JSE are accessible via proxies.'! !!PharoJsHelpApplication class methodsFor: 'accessing'!bookName 	^'Building Applications'! !!PharoJsHelpApplication class methodsFor: 'accessing'!key	^ self name! !!PharoJsHelpApplication class methodsFor: 'accessing'!pages	^ (self class methods collect: #selector thenSelect: [ : s | s beginsWith: #topic ]) sort,		(self subclasses collect: #name)! !!PharoJsHelpApplication class methodsFor: 'pages'!topicApplication	<script: 'self edit: #topicApplication'>	^HelpTopic		title: 'Introduction'		contents: 'To develop an application, whether a Single Page Application (SPA)  or simply code to support a conventional web page, create a class that is a subclass of PjApplication - usually a subclass of PjBrowserApplication or PjNodeApplication.The subclasses define appropriate Javascript values to be referenced by proxies when code is running on Pharo.These are defined by shared pool dictionaries.!!' readStream nextChunkText! !!PharoJsHelpApplication class methodsFor: 'pages'!topicGlobalsAndPolyfills	"This method was automatically generated."	<script: 'self edit: #topicGlobalsAndPolyfills'>	^HelpTopic		title: 'Globals and Polyfills'		contents: 'When code is running on Pharo, references to Javascript values such as the DOM need to be in scope.When code is running on Pharo or a Javascript engine, polyfills are used to sew together the application with other libraries.Both of these requirements are achieved by using Shared Pool Dictionaries.!!' readStream nextChunkText! !!SpCodePresenter methodsFor: '*PharoJs-Tools'!addBinding: aVariable	"Used by PharoJS Playground to add instances of WorkspaceVariable "	self interactionModel addBinding: aVariable! !"PharoJs-Tools"!!PjToolsTestClass1 commentStamp: '' prior: 0!A class used in tests with some "subclass responsibility" methods defined as an indirect subclass of PjApplication. This is used to verify that the class is seen as abstract class without having to explicitly declare #isAbstract.!!PjToolsTestClass2 commentStamp: '' prior: 0!A class used in tests with some "subclass responsibility" methods defined as a subclass of another subclass with "subclass responsibility" methods. This is used to verify that the class is seen as abstract class without having an explicit implementation of an own #isAbstract method.!!PjToolsTestClass3 commentStamp: '' prior: 0!A class used in tests with some concrete methods originally defined as "subclass responsiblity" in one of the superclasses. This is used to verify that the class is seen as non-abstract (concrete) class and returning false for #isAbstract without having an explicit implementation of an own #isAbstract method.!!PjToolsTestClass2b commentStamp: '' prior: 0!A class used in tests with some concrete methods originally defined as "subclass responsiblity" in one of the superclasses. This is used to verify that the class is seen as non-abstract (concrete) class and returning false for #isAbstract without having an explicit implementation of an own #isAbstract method.!!PjAppPlaygroundTest class methodsFor: 'asserting'!shouldInheritSelectors	^true! !!PjAppPlaygroundTest methodsFor: 'tests'!setUpPlayground	playground := PjMinimalFileBasedWebApp playground.	self waitUntil: [ playground bridge isConnected ]! !!PjAppPlaygroundTest methodsFor: 'tests'!testVerifyTitle	self assert: (playground title includesSubstring: 'PharoJS').	self assert:		(playground title includesSubstring: PjMinimalFileBasedWebApp name)! !!PjPlaygroundTest methodsFor: 'testing'!closeWindow	window ifNotNil: [ window delete ]! !!PjPlaygroundTest methodsFor: 'testing'!eval: statementsString	| codePresenter |	codePresenter := playground firstPage text.	^ codePresenter		  evaluate: statementsString		  onCompileError: [ :err | err pass ]		  onError: [ :err | err pass ]! !!PjPlaygroundTest methodsFor: 'testing'!setUp	super setUp.	self setUpPlayground.	window := playground window! !!PjPlaygroundTest methodsFor: 'testing'!setUpPlayground	playground := PjWebApplication playground.	playground title: 'PharoJS Playground Test'! !!PjPlaygroundTest methodsFor: 'testing'!tearDown	super tearDown.	self closeWindow! !!PjPlaygroundTest methodsFor: 'testing'!testReadJsGlobal	|result|	self shouldnt: [result := self eval: 'window.'] raise: Error.	self assert: (result isKindOf: PjProxy).	self assert: result asJSON equals: #window! !!PjPlaygroundTest methodsFor: 'testing'!testSendMessageToGlobal	|result|	self shouldnt: [result := self eval: 'window document.'] raise: Error.	self assert: (result isKindOf: PjProxy).	self assert: result asJSON equals: #document! !!PjPlaygroundTest methodsFor: 'testing'!testSetNewVariable	|result| 	self shouldnt: [result := self eval: 'newVar := 1.'] raise: Error.	self assert: result equals: 1! !!PjToolsTest methodsFor: 'testing'!testClassAbstract	"Test that subclasses of PjApplication return true for #isAbstract although they might 	 not necessarily implement an #isAbstract method. Having a single subclass responsibility	 makes them an abstract class already."			self assert: PjApplication isAbstract.	self assert: PjDOMApplication isAbstract.	self assert: PjFileBasedWebApp isAbstract.	self assert: PjWebApplication isAbstract.	self assert: PjNodeApplication isAbstract.		self assert: PjToolsTestClass1 subclassResponsibilitySet equals: #(m1 m2) asSet.	self assert: PjToolsTestClass1 classSubclassResponsibilitySet equals: #(c1) asSet.	self assert: PjToolsTestClass1 isAbstract.		self assert: PjToolsTestClass2 subclassResponsibilitySet equals: #(m2) asSet.	self assert: PjToolsTestClass2 classSubclassResponsibilitySet isEmpty.	self assert: PjToolsTestClass2 isAbstract.		self assert: PjToolsTestClass3 subclassResponsibilitySet isEmpty.	self assert: PjToolsTestClass3 classSubclassResponsibilitySet isEmpty.	self deny: PjToolsTestClass3 isAbstract.		self assert: PjToolsTestClass2b subclassResponsibilitySet isEmpty.	self assert: PjToolsTestClass2b classSubclassResponsibilitySet equals: #(c1) asSet.	self assert: PjToolsTestClass2b isAbstract! !!PjToolsTestClass1 class methodsFor: 'accessing'!bridgeClientClass	^ nil! !!PjToolsTestClass1 class methodsFor: 'accessing'!c1	^ self subclassResponsibility! !!PjToolsTestClass1 methodsFor: 'abstract sample methods'!m1	^ self subclassResponsibility! !!PjToolsTestClass1 methodsFor: 'abstract sample methods'!m2	^ self subclassResponsibility! !!PjToolsTestClass1 methodsFor: 'abstract sample methods'!m3	^ 18! !!PjToolsTestClass2 class methodsFor: 'accessing'!c1	^ 12! !!PjToolsTestClass2 methodsFor: 'abstract sample methods'!m1	^ 4! !!PjToolsTestClass3 class methodsFor: 'settings'!playgroundDoNotList	<pharoJsSkip>! !!PjToolsTestClass3 methodsFor: 'concrete sample methods'!m2	^ 7! !!PjToolsTestClass2b methodsFor: 'concrete sample methods'!m1	^ #m1! !!PjToolsTestClass2b methodsFor: 'concrete sample methods'!m2	^ #m2! !"PharoJs-Tools-Tests"!!PjCounterController methodsFor: 'actions' stamp: 'AlexandraCroce 3/3/2024 08:24' prior: 34324397!increment	self counter increment.	self updateDisplay! !!PjCounter methodsFor: 'initialize - release' stamp: 'AlexandraCroce 3/3/2024 08:24' prior: 34323817!increment	self count: self count - 1! !!PjHtmlGeneratingCounterApp methodsFor: 'initialize-release' stamp: 'AlexandraCroce 3/3/2024 10:04' prior: 34316752!initialize	| container incrementButton decrementButton |	super initialize.	container := self addElement: 'div' style: self containerCss.	countDisplay := self addElement: 'div' to: container style: {#fontSize -> '300%'}.	self addElement: 'br' to: container.	incrementButton := self addElement: 'button' to: container style: self buttonsSharedCss.	incrementButton innerHTML: 'Open Door'.	self setElement: incrementButton style: {#backgroundColor -> '#ccf5ff'}.	self onClickElement: incrementButton do: [ self count: self count + 1 ].	decrementButton := self addElement: 'button' to: container style: self buttonsSharedCss.	decrementButton innerHTML: 'Decrement'.	self onClickElement: decrementButton do: [ self count: self count - 1 ].	self setElement: decrementButton style: {#backgroundColor -> '#ffe6e6'}.	self count: 0! !